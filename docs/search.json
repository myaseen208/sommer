[{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"background-on-mixed-models","dir":"Articles","previous_headings":"SECTION 1: Introduction","what":"1) Background on mixed models","title":"Quick start for the sommer package","text":"core package mmer function solves mixed model equations. functions interface call NR Direct-Inversion Newton-Raphson Average Information algorithms (Tunnicliffe 1989; Gilmour et al. 1995; Lee et al. 2016). version 2.0, sommer can handle multivariate models. Following Maier et al. (2015), multivariate (extension univariate) mixed model implemented form:  y1=X1β1+Z1u1+ϵ1y_1 = X_1\\beta_1 + Z_1u_1 + \\epsilon_1 y2=X2β2+Z2u2+ϵ2y_2 = X_2\\beta_2 + Z_2u_2 + \\epsilon_2 … yi=Xiβi+Ziui+ϵiy_i = X_i\\beta_i + Z_iu_i + \\epsilon_i  yiy_i vector trait phenotypes, βi\\beta_i vector fixed effects, uiu_i vector random effects individuals eie_i residuals trait ‘’ (= 1, …, t). random effects (u1u_1 … uiu_i eie_i) assumed normally distributed mean zero. X Z incidence matrices fixed random effects respectively. distribution multivariate response phenotypic variance covariance (V) :  Y=Xβ+ZU+ϵiY = X\\beta + ZU + \\epsilon_i  Y ~ MVN(XβX\\beta, V)  𝐘=[y1y2...yt]\\mathbf{Y} = \\left[\\begin{array} {r} y_1 \\\\ y_2 \\\\ ... \\\\ y_t \\\\ \\end{array}\\right]  𝐗=[X100⋮⋱⋮00Xt]\\mathbf{X} = \\left[\\begin{array} {rrr} X_1 & 0 & 0 \\\\ \\vdots & \\ddots & \\vdots\\\\ 0 & 0 & X_t \\\\ \\end{array}\\right]  𝐕=[Z1Kσg12Z1′+Hσϵ12...Z1Kσg1,tZt′+Hσϵ1,t⋮⋱⋮Z1Kσg1,tZt′+Hσϵ1,t...ZtKσgt2Zt′+Hσϵt2]\\mathbf{V} = \\left[\\begin{array} {rrr} Z_1 K{\\sigma^2_{g_{1}}} Z_1' + H{\\sigma^2_{\\epsilon_{1}}} & ... & Z_1 K{\\sigma_{g_{1,t}}} Z_t' + H{\\sigma_{\\epsilon_{1,t}}} \\\\ \\vdots & \\ddots & \\vdots\\\\ Z_1 K{\\sigma_{g_{1,t}}} Z_t' + H{\\sigma_{\\epsilon_{1,t}}} & ... & Z_t K{\\sigma^2_{g_{t}}} Z_t' + H{\\sigma^2_{\\epsilon_{t}}} \\\\ \\end{array}\\right]  K relationship covariance matrix kth random effect (u=1,…,k), H=identity matrix partial identity matrix residual term. terms σgi2\\sigma^2_{g_{}} σϵi2\\sigma^2_{\\epsilon_{}} denote genetic (kth random terms) residual variance trait ‘’, respectively σgij\\sigma_{g_{_{ij}}} σϵij\\sigma_{\\epsilon_{_{ij}}} genetic (kth random terms) residual covariance traits ‘’ ‘j’ (=1,…,t, j=1,…,t). algorithm implemented optimizes log likelihood:  logL=1/2*ln(|V|)+ln(X′|V|X)+Y′PYlogL = 1/2 * ln(|V|) + ln(X'|V|X) + Y'PY  || determinant matrix. REML estimates updated using Newton optimization algorithm form:  θk+1=θk+(Hk)−1*dLdσi2|θk\\theta^{k+1} = \\theta^{k} + (H^{k})^{-1}*\\frac{dL}{d\\sigma^2_i}|\\theta^k  θ\\theta vector variance components random effects covariance components among traits, H−1H^{-1} inverse Hessian matrix second derivatives kth cycle, dLdσi2\\frac{dL}{d\\sigma^2_i} vector first derivatives likelihood respect variance-covariance components. Eigen decomposition relationship matrix proposed Lee Van Der Werf (2016) included Newton-Raphson algorithm improve time efficiency. Additionally, popular vpredict() function estimate standard errors linear combinations variance components (.e. heritabilities genetic correlations) added package well. Please refer canonical papers listed Literature section check algorithms work. tested widely methods make sure provide solution likelihood behaves well complex problems might lead slightly different answers. concern please contact cova_ruber@live.com.mx. following section go detail several examples use mixed models univariate multivariate case use quantitative genetics.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"background-on-covariance-structures","dir":"Articles","previous_headings":"SECTION 1: Introduction","what":"2) Background on covariance structures","title":"Quick start for the sommer package","text":"One major strenghts linear mixed models flexibility specify variance-covariance structures levels. general, variance structures mixed models can seen tensor (kronecker) products multiple variance-covariance stuctures. example, multi-response model (.e. 2 traits) “g” individuals (.e. 100 individuals) tested “e” treatments (.e. 3 environments), variance-covariance random effect “individuals” can seen following multiplicative model: T ⊗\\otimes G ⊗\\otimes : 𝐓=[σgt1,t12σgt1,t2σgt2,t1σgt2,t22]\\mathbf{T} = \\left[\\begin{array} {rr} {\\sigma^2_{g_{_{t1,t1}}}} & {\\sigma_{g_{_{t1,t2}}}} \\\\ {\\sigma_{g_{_{t2,t1}}}} & {\\sigma^2_{g_{_{t2,t2}}}} \\\\ \\end{array}\\right] covariance structure individuals among traits. 𝐆=[σge1,e12σge1,e2σge1,e3σge2,e1σge2,e22σge2,e3σge3,e1σge3,e2σge3,e32]\\mathbf{G} = \\left[\\begin{array} {rrr} {\\sigma^2_{g_{_{e1,e1}}}} & {\\sigma_{g_{_{e1,e2}}}} & {\\sigma_{g_{_{e1,e3}}}} \\\\ {\\sigma_{g_{_{e2,e1}}}} & {\\sigma^2_{g_{_{e2,e2}}}} & {\\sigma_{g_{_{e2,e3}}}} \\\\ {\\sigma_{g_{_{e3,e1}}}} & {\\sigma_{g_{_{e3,e2}}}} & {\\sigma^2_{g_{_{e3,e3}}}} \\\\ \\end{array}\\right] covariance structure individuals among environments. AA square matrix representing covariance among levels individuals (known relationship matrix). T G covariance structures shown unknown matrices estimated whereas known. T G matrices shown called unstructured (US) covariance matrices, although type just one example several covariance structures linear mixed models enable. example, popular covariance structures : Diagonal (DIAG) covariance structures 𝚺=[σge1,e1200⋮⋱⋮00σgei,ei2]\\mathbf{\\Sigma} = \\left[\\begin{array} {rrr} {\\sigma^2_{g_{_{e1,e1}}}} & 0 & 0 \\\\ \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & {\\sigma^2_{g_{_{ei,ei}}}} \\\\ \\end{array}\\right]  Compound simmetry (CS) covariance structures 𝚺=[σg2+σge2σg2σg2σg2σg2σg2+σge2σg2σg2⋮⋮⋱⋮σg2σg2σg2σg2+σge2]\\mathbf{\\Sigma} = \\left[\\begin{array} {rrrr} {\\sigma^2_{g}} + {\\sigma^2_{ge}} & {\\sigma^2_{g}} & {\\sigma^2_{g}} & {\\sigma^2_{g}} \\\\ {\\sigma^2_{g}} & {\\sigma^2_{g}} + {\\sigma^2_{ge}} & {\\sigma^2_{g}} & {\\sigma^2_{g}}\\\\ \\vdots & \\vdots & \\ddots & \\vdots\\\\ {\\sigma^2_{g}} & {\\sigma^2_{g}} & {\\sigma^2_{g}} & {\\sigma^2_{g}} + {\\sigma^2_{ge}}\\\\ \\end{array}\\right] First order autoregressive (AR1) covariance structures 𝚺=σ2[1ρρ2ρ3ρ1ρρ2ρ2ρ1ρρ3ρ2ρ1]\\mathbf{\\Sigma} = \\sigma^2 \\left[\\begin{array} {rrrr} 1 & {\\rho} & {\\rho^2} & {\\rho^3} \\\\ {\\rho} & 1 & {\\rho} & {\\rho^2}\\\\ {\\rho^2} & {\\rho} & 1 & {\\rho} \\\\ {\\rho^3} & {\\rho^2} & {\\rho}  & 1  \\\\ \\end{array}\\right] already mentioned Unstructured (US) covariance structures 𝚺=[σge1,e12σge1,e2σge1,e3⋮⋱⋮σge3,e1σge3,e2σge3,e32]\\mathbf{\\Sigma} = \\left[\\begin{array} {rrr} {\\sigma^2_{g_{_{e1,e1}}}} & {\\sigma_{g_{_{e1,e2}}}} & {\\sigma_{g_{_{e1,e3}}}} \\\\ \\vdots & \\ddots & \\vdots \\\\ {\\sigma_{g_{_{e3,e1}}}} & {\\sigma_{g_{_{e3,e2}}}} & {\\sigma^2_{g_{_{e3,e3}}}} \\\\ \\end{array}\\right] among others. Sommer capabilities fit covariance structures mixed model machinery.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"univariate-homogeneous-variance-models","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer","what":"1) Univariate homogeneous variance models","title":"Quick start for the sommer package","text":"type model refers single response models variable interest (.e. genotypes) needs analyzed interacting 2nd random effect (.e. environments), assume across environments genotypes variance component. -called compound symmetry (CS) model.","code":"library(sommer) ## Loading required package: Matrix ## Loading required package: MASS ## Loading required package: crayon data(DT_example) DT <- DT_example ## solving for r records ans1r <- mmer(Yield~Env,               random= ~ Name + Env:Name,               rcov= ~ units,               data=DT, verbose = FALSE) summary(ans1r)$varcomp ##                       VarComp VarCompSE   Zratio Constraint ## Name.Yield-Yield     3.681877 1.6909561 2.177394   Positive ## Env:Name.Yield-Yield 5.173062 1.4952313 3.459707   Positive ## units.Yield-Yield    4.366285 0.6470458 6.748031   Positive ## solving for c coefficients ans1c <- mmec(Yield~Env,               random= ~ Name + Env:Name,               rcov= ~ units,               data=DT, verbose = FALSE) summary(ans1c)$varcomp ##                   VarComp VarCompSE   Zratio Constraint ## Name:isc:isc     3.683153  1.880974 1.958109   Positive ## Env:Name:isc:isc 5.174116  2.420486 2.137635   Positive ## units:isc:isc    4.359651  2.270467 1.920156   Positive"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"univariate-heterogeneous-variance-models","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer","what":"2) Univariate heterogeneous variance models","title":"Quick start for the sommer package","text":"often multi-environment trials, assumption genetic variance residual variance across locations may naive. , specifying general genetic component location specific genetic variance way go. requires CS+DIAG model (also called heterogeneous CS model). can see special function atr diag can used indicate ’s different variance genotypes environment. done residual. difference atr diag atr function can used specify levels specific environments variance different.","code":"data(DT_example) DT <- DT_example   ans2r <- mmer(Yield~Env,               random= ~Name + vsr(dsr(Env),Name),               rcov= ~ vsr(dsr(Env),units),               data=DT, verbose = FALSE) summary(ans2r)$varcomp ##                             VarComp VarCompSE   Zratio Constraint ## Name.Yield-Yield           2.962851 1.4962000 1.980251   Positive ## CA.2011:Name.Yield-Yield  10.146369 4.5073271 2.251083   Positive ## CA.2012:Name.Yield-Yield   1.877530 1.8697568 1.004158   Positive ## CA.2013:Name.Yield-Yield   6.629152 2.5028114 2.648682   Positive ## CA.2011:units.Yield-Yield  4.942450 1.5245057 3.242001   Positive ## CA.2012:units.Yield-Yield  5.724963 1.3123015 4.362536   Positive ## CA.2013:units.Yield-Yield  2.559880 0.6399685 4.000010   Positive DT=DT[with(DT, order(Env)), ] ans2c <- mmec(Yield~Env,               random= ~Name + vsc(dsc(Env),isc(Name)),               rcov= ~ vsc(dsc(Env),isc(units)),               data=DT, verbose = FALSE) summary(ans2c)$varcomp ##                             VarComp VarCompSE   Zratio Constraint ## Name:isc:isc               2.961884 1.4528416 2.038683   Positive ## Env:Name:CA.2011:CA.2011  10.148234 4.5621620 2.224435   Positive ## Env:Name:CA.2012:CA.2012   1.878549 1.8883269 0.994822   Positive ## Env:Name:CA.2013:CA.2013   6.629514 2.4890963 2.663422   Positive ## Env:units:CA.2011:CA.2011  4.942515 1.5201275 3.251382   Positive ## Env:units:CA.2012:CA.2012  5.724688 1.3325966 4.295890   Positive ## Env:units:CA.2013:CA.2013  2.559825 0.6395343 4.002639   Positive"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"unstructured-variance-models","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer","what":"3) Unstructured variance models","title":"Quick start for the sommer package","text":"relaxed asumption CS+DIAG model unstructured model (US) assumes among levels certain factor (.e. Environments) ’s covariance struture second random effect (.e. Genotypes). can done sommer using usr(.) function: can seen usr(Env) indicates genotypes (Name) can covariance structure among environments (Env).","code":"data(DT_example) DT <- DT_example  ans3r <- mmer(Yield~Env,              random=~ vsr(usr(Env),Name),              rcov=~vsr(dsr(Env),units),               data=DT, verbose = FALSE) summary(ans3r)$varcomp ##                                     VarComp VarCompSE    Zratio Constraint ## CA.2011:Name.Yield-Yield         15.6650010 5.4206906 2.8898534   Positive ## CA.2012:CA.2011:Name.Yield-Yield  6.1101600 2.4850649 2.4587527   Unconstr ## CA.2012:Name.Yield-Yield          4.5296090 1.8208107 2.4876881   Positive ## CA.2013:CA.2011:Name.Yield-Yield  6.3844808 3.0658977 2.0824181   Unconstr ## CA.2013:CA.2012:Name.Yield-Yield  0.3929997 1.5233985 0.2579757   Unconstr ## CA.2013:Name.Yield-Yield          8.5972750 2.4837814 3.4613654   Positive ## CA.2011:units.Yield-Yield         4.9698460 1.5322540 3.2434870   Positive ## CA.2012:units.Yield-Yield         5.6729333 1.3007862 4.3611574   Positive ## CA.2013:units.Yield-Yield         2.5570940 0.6392821 3.9999462   Positive DT=DT[with(DT, order(Env)), ] ans3c <- mmec(Yield~Env,              random=~ vsc(usc(Env),isc(Name)),              rcov=~vsc(dsc(Env),isc(units)),               data=DT, verbose = FALSE) summary(ans3c)$varcomp ##                             VarComp VarCompSE    Zratio Constraint ## Env:Name:CA.2011:CA.2011  14.492642 3.3536970 4.3213927   Positive ## Env:Name:CA.2011:CA.2012   5.804743 1.9402333 2.9917760   Unconstr ## Env:Name:CA.2012:CA.2012   4.456845 2.4466754 1.8215925   Positive ## Env:Name:CA.2011:CA.2013   5.628452 1.5551412 3.6192546   Unconstr ## Env:Name:CA.2012:CA.2013   0.487732 1.4943128 0.3263922   Unconstr ## Env:Name:CA.2013:CA.2013   8.152593 2.0718946 3.9348494   Positive ## Env:units:CA.2011:CA.2011  4.960032 1.5272879 3.2476074   Positive ## Env:units:CA.2012:CA.2012  5.634496 1.3028875 4.3246219   Positive ## Env:units:CA.2013:CA.2013  2.557155 0.6385661 4.0045273   Positive"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"multivariate-homogeneous-variance-models","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer","what":"4) Multivariate homogeneous variance models","title":"Quick start for the sommer package","text":"Currently ’s great push multi-response models. motivated correlation certain variables hide benefit prediction perspective. sommer specify multivariate models response requires use cbind() function response, usr(trait), diag(trait), atr(trait) functions random part model. may notice added usr(trait) behind random effects. indicate structure assumed multivariate model. diag(trait) used behind random effect (.e. Name) indicates traits modeled (Yield Weight) ’s covariance component estimated, whereas usr(trait) assumes random effect, ’s covariance component estimated (.e. covariance Yield Weight random effect Name). applies residual part (rcov). number random effects can specified different structures.","code":"data(DT_example) DT <- DT_example DT$EnvName <- paste(DT$Env,DT$Name)  DT$Yield <- as.vector(scale(DT$Yield)) DT$Weight <- as.vector(scale(DT$Weight))  ans4r <- mmer(cbind(Yield, Weight) ~ Env,              random= ~ vsr(Name, Gtc=unsm(2)),              rcov= ~ vsr(units, Gtc=diag(2)),              data=DT, verbose = FALSE) summary(ans4r)$varcomp ##                         VarComp  VarCompSE   Zratio Constraint ## u:Name.Yield-Yield    0.2448029 0.07278135 3.363540   Positive ## u:Name.Yield-Weight   0.3177637 0.07457957 4.260733   Unconstr ## u:Name.Weight-Weight  0.2813217 0.08054357 3.492789   Positive ## u:units.Yield-Yield   0.3725767 0.04331247 8.602066   Positive ## u:units.Weight-Weight 0.3586951 0.04189443 8.561882   Positive DT2 <- reshape(DT, idvar = c(\"Name\",\"Env\",\"Block\"), varying = list(6:7),         v.names = \"y\", direction = \"long\", timevar = \"trait\", times = colnames(DT)[6:7]) DT2$trait <- as.factor(DT2$trait)  # ans4c <- mmec(y ~ Env:trait, #              random= ~ vsc(usc(trait),isc(Name)), #              rcov= ~ vsc(dsc(trait),isc(units)), returnParam = T,  #              data=DT2, verbose = T) # summary(ans4c)$varcomp"},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"the-vsr-function-for-special-variance-models-and-its-auxiliaries","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 5) Details on special functions for variance models","what":"the vsr() function for special variance models and its auxiliaries","title":"Quick start for the sommer package","text":"sommer function vsr() allows constructing complex variance models passed mmer() function constitutes one important features sommer package. specification vsr() function form: random=~vsr(..., Gu, Gti, Gtc) idea vsr() function reflects special variance structure random effect matrix notation: var(u)=T⨂E⨂...⨂Avar(u) = T \\bigotimes E \\bigotimes ... \\bigotimes … argument vsr() function used specify kronecker products matrices form variance random effect , auxiliary functions dsr(), usr(), csr(), atr(), can used define structured variance structures. idea variance model random effect x (.e. individuals) might require flexible model just: random=~x example, individuals tested different time-points environments, can assume different variance covariance components among individuals different environment-timepoint combinations. example variance structure type: var(u)=T⨂E⨂S⨂Avar(u) = T \\bigotimes E \\bigotimes S \\bigotimes specified vsr() function : random=~vsr(usr(e),usr(s),x, Gu=, Gtc=T) e column vector data frame environments, s column vector dataframe time points, x vector datrame identifier individuals, known square variance covariance matrix among individuals (usually identity matrix; default specified), T square matrices many rows columns number traits specifies trait covariance structure. auxiliary functions build variance models random effect : + dsr() diagonal covariance structure + usr() unstructured covariance + atr() specific levels heterogeneous variance structure + csr() customized covariance structure","code":""},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"the-vsc-function-for-special-variance-models-and-its-auxiliaries","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 5) Details on special functions for variance models","what":"the vsc() function for special variance models and its auxiliaries","title":"Quick start for the sommer package","text":"sommer function vsc() allows constructing complex variance models passed mmec() function constitutes one important features sommer package. specification vsc() function form: random=~vsc(..., Gu) different variance structures input constraints specified within auxiliar function argument theta thetaC. Please notice functions c coefficients end letter c instead r.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"dsr-and-dsc-to-specify-a-diagonal-diag-covariance-structures","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 5) Details on special functions for variance models","what":"dsr() and dsc() to specify a diagonal (DIAG) covariance structures","title":"Quick start for the sommer package","text":"diagonal covariance structure looks like : 𝚺=[σge1,e1200⋮⋱⋮00σgei,ei2]\\mathbf{\\Sigma} = \\left[\\begin{array} {rrr} {\\sigma^2_{g_{_{e1,e1}}}} & 0 & 0 \\\\ \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & {\\sigma^2_{g_{_{ei,ei}}}} \\\\ \\end{array}\\right]  Considering example one random effect (g; indicating .e. individuals) evaluated different treatment levels (e; indicating .e. different treatments) model look like: random=~vsr(dsr(e),g) r records random=~vsc(dsc(e),isc(g)) c coefficients","code":""},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"usr-and-usc-to-specify-an-unstructured-us-covariance","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 5) Details on special functions for variance models","what":"usr() and usc() to specify an unstructured (US) covariance","title":"Quick start for the sommer package","text":"unstructured covariance looks like : 𝐆=[σge1,e12σge1,e2σge1,e3σge2,e1σge2,e22σge2,e3σge3,e1σge3,e2σge3,e32]\\mathbf{G} = \\left[\\begin{array} {rrr} {\\sigma^2_{g_{_{e1,e1}}}} & {\\sigma_{g_{_{e1,e2}}}} & {\\sigma_{g_{_{e1,e3}}}} \\\\ {\\sigma_{g_{_{e2,e1}}}} & {\\sigma^2_{g_{_{e2,e2}}}} & {\\sigma_{g_{_{e2,e3}}}} \\\\ {\\sigma_{g_{_{e3,e1}}}} & {\\sigma_{g_{_{e3,e2}}}} & {\\sigma^2_{g_{_{e3,e3}}}} \\\\ \\end{array}\\right] Considering example one random effect (g; indicating .e. individuals) evaluated different treatment levels (e; indicating .e. different treatments) model look like: random=~vsr(usr(e),g) r records random=~vsc(usc(e),isc(g)) c coefficients","code":""},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"atr-and-atc-to-specify-a-level-specific-heterogeneous-variance","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 5) Details on special functions for variance models","what":"atr() and atc() to specify a level-specific heterogeneous variance","title":"Quick start for the sommer package","text":"diagonal covariance structure specific levels second random effect looks like : 𝚺=[σge1,e1200⋮⋱⋮00σgei,ei2]\\mathbf{\\Sigma} = \\left[\\begin{array} {rrr} {\\sigma^2_{g_{_{e1,e1}}}} & 0 & 0 \\\\ \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & {\\sigma^2_{g_{_{ei,ei}}}} \\\\ \\end{array}\\right] Considering example one random effect (g; indicating .e. individuals) evaluated different treatment levels (e; indicating .e. different treatments ,B,C) model look like: random=~vsr(atr(e,c(\"\",\"B\")),g) random=~vsc(atc(e,c(\"\",\"B\")),isc(g)) variance component g fitted levels B.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"csr-and-csc-to-specify-a-level-specific-variance-covariance-structure","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 5) Details on special functions for variance models","what":"csr() and csc() to specify a level-specific variance-covariance structure","title":"Quick start for the sommer package","text":"customized covariance structure specific levels second random effect (variance covariances) looks .e. like : 𝚺=[σge1,e12σge1,e20⋮⋱⋮00σgei,ei2]\\mathbf{\\Sigma} = \\left[\\begin{array} {rrr} {\\sigma^2_{g_{_{e1,e1}}}} & {\\sigma_{g_{_{e1,e2}}}} & 0 \\\\ \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & {\\sigma^2_{g_{_{ei,ei}}}} \\\\ \\end{array}\\right] Considering example one random effect (g; indicating .e. individuals) evaluated different treatment levels (e; indicating .e. different treatments ,B,C) model look like: random=~vsr(csr(e,c(\"\",\"B\")),g) random=~vsc(csc(e,c(\"\",\"B\")),isc(g)) mm indicates variance covariance components estimated g.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"the-specification-of-multi-trait-constraints-in-the-variance-components-for-the-vsr-function-gtc-argument","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer","what":"6) The specification of multi-trait constraints in the variance components for the vsr function (Gtc argument)","title":"Quick start for the sommer package","text":"One major strengths sommer extreme flexibility specify variance-covariance structures multi-trait framework. Since sommer 3.7 easily achieved use vsr() function ’s argument Gtc. Gtc argument expects matrix constraints variance-covariance components random effect filled numbers according following rules: 0: parameter estimated 1: estimated constrained positive 2: estimated unconstrained 3: estimated fixed value provided Gti useful functions specify quickly contraint matrices unsm() unstructured, fixm() fixed constraint, fcm() fixed effect constraints. Consider multi-trait model 4 traits (y1,…,y4) 1 random effect (u) 1 fixed effect (x) fixed=cbind(y1,y2,y3,y4)~x random= ~vsr(u, Gtc=?) constraint 4 x 4 matrix variance covariance components estimated can : unstructured (variance components positive covariances either positive negative) random= ~vsr(u, Gtc=unsm(4)) random= ~vsr(dsc(x,thetaC=unsm(4)),isc(u)) fixed (variance covariance components indicated 3 considered fixed values provided Gti argument) random= ~vsr(u, Gtc=fixm(4), Gti=mm) random= ~vsr(dsc(x,thetaC=fixm(4)),isc(u)) mm 4 x 4 matrix initial values variance components. constraints fixed effects fixed= cbind(y1,y2,y3,y4)~vsr(x, Gtc=fcm(c(1,0,1,0))) 1’s 0’s indicate traits fixed effect estimated (1’s) won’t (0’s).","code":"unsm(4) ##      [,1] [,2] [,3] [,4] ## [1,]    1    2    2    2 ## [2,]    2    1    2    2 ## [3,]    2    2    1    2 ## [4,]    2    2    2    1 fixm(4) ##      [,1] [,2] [,3] [,4] ## [1,]    3    3    3    3 ## [2,]    3    3    3    3 ## [3,]    3    3    3    3 ## [4,]    3    3    3    3 fcm(c(1,0,1,0)) ##      [,1] [,2] ## [1,]    1    0 ## [2,]    0    0 ## [3,]    0    1 ## [4,]    0    0"},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"random-regression-models","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 7) Special functions for special models","what":"Random regression models","title":"Quick start for the sommer package","text":"order fit random regression models user can use leg() function fit Legendre polynomials. can combined special covariance structures dsr() / dsc(), usr() / usc(), etc. , numeric covariate X used explain trajectory SUBJECTs combined unstructured covariance matrix. details can found theory.","code":"library(orthopolynom) data(DT_legendre) DT <- DT_legendre  mRR2r<-mmer(Y~ 1 + Xf            , random=~ vsr(usr(leg(X,1)),SUBJECT)            , rcov=~vsr(units)            , data=DT, verbose = FALSE) summary(mRR2r)$varcomp ##                         VarComp VarCompSE   Zratio Constraint ## leg0:SUBJECT.Y-Y      2.5782969 0.6717242 3.838326   Positive ## leg1:leg0:SUBJECT.Y-Y 0.4765431 0.2394975 1.989763   Unconstr ## leg1:SUBJECT.Y-Y      0.3497299 0.2183229 1.601893   Positive ## u:units.Y-Y           2.6912226 0.3825197 7.035513   Positive mRR2c<-mmec(Y~ 1 + Xf            , random=~ vsc(usc(leg(X,1)),isc(SUBJECT))            , rcov=~vsc(isc(units))            , data=DT, verbose = FALSE) summary(mRR2c)$varcomp ##                       VarComp VarCompSE   Zratio Constraint ## X:SUBJECT:leg0:leg0 2.5631091 0.4926224 5.202989   Positive ## X:SUBJECT:leg0:leg1 0.4681312 0.1908480 2.452900   Unconstr ## X:SUBJECT:leg1:leg1 0.3477737 0.2828824 1.229393   Positive ## units:isc:isc       2.6914702 0.4614278 5.832918   Positive"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"gwas-models","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 7) Special functions for special models","what":"GWAS models","title":"Quick start for the sommer package","text":"Although genome-wide association studies can conducted variety approaches, use mixed models find associations markers phenotypes still one popular approaches. One classical popular approaches test marker marker trough mixed modeling (1 model marker) obtain marker effect statistic reflecting level association usually provided -log10 p-value. second popular approach assume genetic variance component similar markers therefore variance components estimated (1 model markers) use inverse phenotypic variance matrix (V.inverse) test markers generalized linear model b=(XV−X)−XV−yb=(XV-X)-XV-y. makes GWAS much faster efficient without major loses. Given straightforward extension, sommer provides GWAS function can fit type approaches (aware two methods among many existant literature) univariate multivariate models, way genetically correlated traits can tested together increase power detection. summary GWAS model implemented sommer obtain marker effect generalized linear model form: b = (X’V-X)X’V-y X = ZMi : - b marker effect (dimensions 1 x mt) - y response variable (univariate multivariate) (dimensions 1 x nt) - V- inverse phenotypic variance matrix (dimensions nt x nt) - Z incidence matrix random effect selected (gTerm argument) perform GWAS (dimensions nt x ut) Mi ith column marker matrix (M argument) (dimensions u x m) t traits, n observations, m markers u levels random effect. Depending P3D TRUE FALSE V- matrix calculated used marker tests (P3D=TRUE) estimated REML marker (P3D=FALSE). show simple GWAS model univariate example.  aware marker matrix M imputed (missing data allowed) make sure number rows M matrix equivalent levels gTerm specified (.e. gTerm “id” 300 levels words 300 individuals, M dimensions 300 x m, m number markers).","code":"data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata #### create the variance-covariance matrix A <- A.mat(GT) # additive relationship matrix #### look at the data and fit the model head(DT,3) ##        id Row Col Year      color  Yield FruitAver Firmness Rowf Colf ## P003 P003   3   1 2014 0.10075269 154.67     41.93  588.917    3    1 ## P004 P004   4   1 2014 0.13891940 186.77     58.79  640.031    4    1 ## P005 P005   5   1 2014 0.08681502  80.21     48.16  671.523    5    1 head(MP,3) ##                 Locus Position Chrom ## 1  scaffold_77830_839        0     1 ## 2  scaffold_39187_895        0     1 ## 3 scaffold_50439_2379        0     1 GT[1:3,1:4] ##      scaffold_50439_2381 scaffold_39344_153 uneak_3436043 uneak_2632033 ## P003                   0                  0             0             1 ## P004                   0                  0             0             1 ## P005                   0                 -1             0             1 mix1 <- GWAS(color~1,              random=~vsr(id,Gu=A)              + Rowf + Colf,              rcov=~units,              data=DT, nIters=3,              M=GT, gTerm = \"u:id\",              verbose = FALSE) ## Performing GWAS evaluation ## ms <- as.data.frame(mix1$scores) ms$Locus <- rownames(ms) MP2 <- merge(MP,ms,by=\"Locus\",all.x = TRUE); manhattan(MP2, pch=20,cex=.5, PVCN = \"color\")"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"overlayed-models-the-overlay-function","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 7) Special functions for special models","what":"Overlayed models [the overlay() function]","title":"Quick start for the sommer package","text":"Another useful function overlay function, allows overlay matrices different random effects estimate single variance component overlayed terms. femalef malef random effects overlayed becoming single random effect variance component.","code":"data(\"DT_halfdiallel\") DT <- DT_halfdiallel head(DT) ##   rep geno male female     sugar ## 1   1   12    1      2 13.950509 ## 2   2   12    1      2  9.756918 ## 3   1   13    1      3 13.906355 ## 4   2   13    1      3  9.119455 ## 5   1   14    1      4  5.174483 ## 6   2   14    1      4  8.452221 DT$femalef <- as.factor(DT$female) DT$malef <- as.factor(DT$male) DT$genof <- as.factor(DT$geno) #### model using overlay modhr <- mmer(sugar~1,               random=~vsr(overlay(femalef,malef))               + genof, data=DT,verbose = FALSE)  modhc <- mmec(sugar~1,               random=~vsc(isc(overlay(femalef,malef, sparse = TRUE)))               + genof,data=DT,verbose = FALSE)"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"spatial-models-using-the-2-dimensional-spline","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 7) Special functions for special models","what":"Spatial models (using the 2-dimensional spline)","title":"Quick start for the sommer package","text":"use CPdata show use 2-dimensional splines accomodating spatial effects field experiments. early generation variety trials availability seed low, makes use unreplicated design neccesity anything else. Experimental designs augmented designs partially-replicated (p-rep) designs become common days. order good job modeling spatial trends happening field, special covariance structures proposed accomodate spatial trends (.e. autoregressive residuals; ar1). Unfortunately, covariance structures make modeling rather unstable. recently research groups proposed use 2-dimensional splines overcome issues robust modeling spatial terms (Lee et al. 2013; Rodríguez-Álvarez et al. 2018). example assume unreplicated population row range information available allows usr fit 2 dimensional spline model. Notice job done spl2Da() function takes Row Col information fit spatial kernel.","code":"data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata ### mimic two fields A <- A.mat(GT) mix <- mmer(Yield~1,             random=~vsr(id, Gu=A) +               vsr(Rowf) +               vsr(Colf) +               spl2Da(Row,Col),             rcov=~vsr(units), nIters=3,             data=DT,verbose = FALSE) summary(mix) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC     BIC Method Converge ## Value -151.2647 304.5293 308.421     NR    FALSE ## ============================================================ ## Variance-Covariance components: ##                     VarComp VarCompSE Zratio Constraint ## u:id.Yield-Yield      792.6     317.6 2.4959   Positive ## u:Rowf.Yield-Yield    807.6     371.3 2.1750   Positive ## u:Colf.Yield-Yield    183.2     139.7 1.3121   Positive ## A:all.Yield-Yield     515.8     701.3 0.7354   Positive ## u:units.Yield-Yield  2918.4     292.8 9.9667   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)    132.1     8.761   15.08 ## ============================================================ ## Groups and observations: ##        Yield ## u:id     363 ## u:Rowf    13 ## u:Colf    36 ## A:all    168 ## ============================================================ ## Use the '$' sign to access results and parameters"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"customized-random-effects","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 7) Special functions for special models","what":"Customized random effects","title":"Quick start for the sommer package","text":"One powerful features sommer ability provide customized matrix estimate random effect. example: matrix GT provided random effect encapsulating matrix list provided vsr() function.","code":"data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata  #### look at the data and fit the model mix1 <- mmer(Yield~1,               random=~vsr(list(GT)),               rcov=~units, nIters=3,               data=DT,verbose = FALSE)"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"genomic-selection","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer","what":"10) Genomic selection","title":"Quick start for the sommer package","text":"section decided show way can fit rrBLUP GBLUP model sommer using wheat example data CIMMYT genomic selection framework. case prediction specific individuals within population. basically uses similar model form:  y=Xβ+Zu+ϵy = X\\beta + Zu + \\epsilon  takes advantage variance covariance matrix genotype effect known additive relationship matrix () calculated using .mat function establish connections among individuals predict BLUPs individuals measured. case interest get BLUPs markers random effect actual marker matrix relationship among markers can specified well example assumed diagonal.","code":"data(DT_wheat) DT <- DT_wheat GT <- GT_wheat colnames(DT) <- paste0(\"X\",1:ncol(DT)) DT <- as.data.frame(DT);DT$id <- as.factor(rownames(DT)) # select environment 1 rownames(GT) <- rownames(DT) K <- A.mat(GT) # additive relationship matrix colnames(K) <- rownames(K) <- rownames(DT) # GBLUP pedigree-based approach set.seed(12345) y.trn <- DT vv <- sample(rownames(DT),round(nrow(DT)/5)) y.trn[vv,\"X1\"] <- NA  ## GBLUP ans <- mmer(X1~1,             random=~vsr(id,Gu=K),              rcov=~units, nIters=3,             data=y.trn,verbose = FALSE) # kinship based ans$U$`u:id`$X1 <- as.data.frame(ans$U$`u:id`$X1) rownames(ans$U$`u:id`$X1) <- gsub(\"id\",\"\",rownames(ans$U$`u:id`$X1)) cor(ans$U$`u:id`$X1[vv,],DT[vv,\"X1\"], use=\"complete\") ## [1] 0.5733721 ## rrBLUP ans2 <- mmer(X1~1,              random=~vsr(list(GT), buildGu = FALSE),               rcov=~units, getPEV = FALSE, nIters=3,              data=y.trn,verbose = FALSE) # kinship based  u <- GT %*% as.matrix(ans2$U$`u:GT`$X1) # BLUPs for individuals rownames(u) <- rownames(GT) cor(u[vv,],DT[vv,\"X1\"]) # same correlation ## [1] 0.5771181 # the same can be applied in multi-response models in GBLUP or rrBLUP # same can be achieved with the mmec function (see ?DT_wheat)"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"likelihood-ratio-tests","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer","what":"11) Likelihood ratio tests","title":"Quick start for the sommer package","text":"Likelihood ratio test (LRT) good way investigate significance random effects specific variance-covariance components.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"testing-the-significance-of-a-variance-component","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 11) Likelihood ratio tests","what":"11.1) Testing the significance of a variance component","title":"Quick start for the sommer package","text":"example, imagine researcher like know model improves adding effect spatial kernel capture spatial trend field, base model may look like : model spatial kernel following: test second model brings value let usr fit likelihood ratio test follows: can seen test turns significant despite increase likelihood.","code":"data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata ### mimic two fields A <- A.mat(GT)  mix1 <- mmer(Yield~1,             random=~vsr(id, Gu=A) +               vsr(Rowf) +               vsr(Colf),             rcov=~vsr(units), nIters=3,             data=DT, verbose = FALSE) mix2 <- mmer(Yield~1,             random=~vsr(id, Gu=A) +               vsr(Rowf) +               vsr(Colf) +               spl2Da(Row,Col),             rcov=~vsr(units), nIters=3,             data=DT,verbose = FALSE) lrt <- anova(mix1, mix2) ## Likelihood ratio test for mixed models ## ============================================================== ##      Df      AIC      BIC     loLik   Chisq ChiDf  PrChisq ## mod2  8 304.5293 308.4210 -151.2647                        ## mod1  7 305.1825 309.0741 -151.5912 0.65315     1 0.41899  ## ============================================================== ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"testing-the-significance-of-a-covariance-component","dir":"Articles","previous_headings":"SECTION 2: Different models enabled in sommer > 11) Likelihood ratio tests","what":"11.2) Testing the significance of a covariance component","title":"Quick start for the sommer package","text":"Sometimes researcher interested knowing covariance structure relevant . Assume two multi-trait models, 1) fitting -covariance (independent) among traits, 2) one fitting genetic covariance among yield color following population: can seen, case fitting covariance among genotypes improves model fit considerably probablity Chi-square distribution < 0.05. model covariance preferred model.","code":"data(DT_example) DT <- DT_example  DT$EnvName <- paste(DT$Env,DT$Name) modelBase <- mmer(cbind(Yield, Weight) ~ Env,               random= ~ vsr(Name, Gtc=diag(2)), # here is diag()               rcov= ~ vsr(units, Gtc=unsm(2)), nIters=3,               data=DT,verbose = FALSE)  modelCov <- mmer(cbind(Yield, Weight) ~ Env,               random= ~ vsr(usr(Env),Name, Gtc=unsm(2)), # here is unsm()               rcov= ~ vsr(dsr(Env),units, Gtc=unsm(2)), nIters=3,               data=DT,verbose = FALSE)  lrt <- anova(modelBase, modelCov) ## Likelihood ratio test for mixed models ## ============================================================== ##      Df       AIC       BIC    loLik     Chisq ChiDf                  PrChisq ## mod2 45 -340.4760 -316.9949 176.2380                                          ## mod1 23 -205.0695 -181.5885 108.5347 135.40646    22 2.57838297804313e-18 *** ## ============================================================== ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"background-on-prediction","dir":"Articles","previous_headings":"SECTION 3: The predict function","what":"1) Background on prediction","title":"Quick start for the sommer package","text":"linear mixed model y nx1 vector observations, linear mixed model can written : y=Xτ+Zu+e=Wβ+ey = X\\tau + Zu + e =  W \\beta + e τ\\tau vector tx1 fixed effects, X nxt design matrix associates observations appropriate combinations fixed effects, u qx1 vector random effects, Z nxq matrix associates observations appropriate random effects, e nx1 vector residual errors. shorthand W β\\beta represent combined design matrix vector efects, respectively. assumed: [ue]=N([00],[G(γ)00R(ϕ)]) \\left[\\begin{array} {r} u \\\\ e \\\\ \\end{array}\\right] = N(\\left[\\begin{array} {r} 0 \\\\ 0 \\\\ \\end{array}\\right] , \\left[\\begin{array} {rr} G{(\\gamma)} & 0 \\\\ 0 & R{(\\phi)} \\\\ \\end{array}\\right]) covariance matrices G R random effects residuals functions parameters γ\\gamma ϕ\\phi respectively. covariance matrix data can written : var(y)=σ2(ZGZ′+R)var(y) = \\sigma^2 (ZGZ'+R) variance parameters γ\\gamma ϕ\\phi usually estimated maximum likelihood REML (Patterson Thompson, 1971). BLUP linear combination known D, γ\\gamma, ϕ\\phi : 𝐃𝛃¯=[DτDu][τ¯u¯]=Dτ¯+Duu¯\\mathbf{D\\overline{\\beta}} = \\left[\\begin{array} {rr} D_{\\tau} & D_u \\\\ \\end{array}\\right]  \\left[\\begin{array} {r} \\overline{\\tau} \\\\ \\overline{u} \\\\ \\end{array}\\right] = {D \\overline{\\tau}} + {D_{u}\\overline{u}}  β¯=(τ,u)\\overline{\\beta} = (\\tau, u) solution mixed moel equations: [XTR−1XXTR−1ZZTR−1XZTR−1Z+G−1][τu]=[XTR−1yZTR−1X] \\left[\\begin{array} {rr} X^TR^{-1}X & X^TR^{-1}Z  \\\\ Z^TR^{-1}X & Z^TR^{-1}Z + G^{-1} \\\\ \\end{array}\\right]  \\left[\\begin{array} {r} \\tau \\\\ u \\\\ \\end{array}\\right] = \\left[\\begin{array} {r} X^TR^{-1}y \\\\ Z^TR^{-1}X \\\\ \\end{array}\\right] can also written Cβ¯=WTR−1yC \\overline{\\beta} = W^TR^{-1}y. τ¯\\overline{\\tau} best linear unbiased estimator (BLUE) τ\\tau u¯\\overline{u} best linear unbiased predictor (BLUP) uu, variance var(β¯−β)=C−1var(\\overline{\\beta}-\\beta)=C^{-1}. Consideration values required form confidence intervals make clear prediction error variance (PEV var(β¯−β)var(\\overline{\\beta}-\\beta)), rather variance estimator var(β¯)var(\\overline{\\beta}) usually interest. prediction error variance linear combination Dβ¯D\\overline{\\beta} DC−1DTDC^{-1}D^T. Since variance parameters unknown, replace unknown variance parameters REML estimates use empirical values. predict() function sommer package builts C−1C^{-1} matrix mixed model equations DD matrix linear combinations obtain PEV SEs predictions. means uses DD matrix linear combinations times vector required fixed random effects Xτ¯+Zu¯X\\overline{\\tau} + Z \\overline{u} Dβ¯D\\overline{\\beta}, matrix D linear combination specific fixed /random effects matrices XX /ZZ.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"predicting-means","dir":"Articles","previous_headings":"SECTION 3: The predict function","what":"2) Predicting means","title":"Quick start for the sommer package","text":"sommer package equiped predict() function can used calculate means standard errors fixed random effects specified models fitted mmer() mmec functions. Using yatesoats dataset fit fixed random effects. Now, model can used together classify argument obtain means classify argument. example, model includes fixed formula terms “V” variety, “N” nitrogen treatments, “V:N” interaction variety nitrogen. classify argument can used specify term means desired. following example means nitrogen treatments obtained follows:","code":"library(sommer) data(DT_yatesoats) DT <- DT_yatesoats m3 <- mmer(fixed=Y ~ V + N + V:N,            random = ~ B + B:MP,            rcov=~units,            data = DT, verbose=FALSE) summary(m3)$varcomp ##            VarComp VarCompSE   Zratio Constraint ## B.Y-Y     214.4477 168.62790 1.271722   Positive ## B:MP.Y-Y  106.0508  67.83280 1.563415   Positive ## units.Y-Y 177.0883  37.34293 4.742217   Positive Dt <- m3$Dtable; Dt ##     type term include average ## 1  fixed    1   FALSE   FALSE ## 2  fixed    V   FALSE   FALSE ## 3  fixed    N   FALSE   FALSE ## 4  fixed  V:N   FALSE   FALSE ## 5 random    B   FALSE   FALSE ## 6 random B:MP   FALSE   FALSE # first fixed effect just average Dt[1,\"average\"] = TRUE # second fixed effect include Dt[2,\"include\"] = TRUE # third fixed effect include and average Dt[3,\"include\"] = TRUE Dt[3,\"average\"] = TRUE Dt ##     type term include average ## 1  fixed    1   FALSE    TRUE ## 2  fixed    V    TRUE   FALSE ## 3  fixed    N    TRUE    TRUE ## 4  fixed  V:N   FALSE   FALSE ## 5 random    B   FALSE   FALSE ## 6 random B:MP   FALSE   FALSE pp=predict(object=m3, Dtable=Dt, D=\"N\") pp$pvals ##       N predicted.value std.error ## 0     0        78.16667  13.31581 ## 0.2 0.2        87.41667  14.88566 ## 0.4 0.4        95.50000  14.88566 ## 0.6 0.6       100.58333  14.88566"},{"path":"https://github.com/covaruber/sommer/articles/v1.sommer.quick.start.html","id":"literature","dir":"Articles","previous_headings":"","what":"Literature","title":"Quick start for the sommer package","text":"Covarrubias-Pazaran G. 2016. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6):1-15. Covarrubias-Pazaran G. 2018. Software update: Moving R package sommer multivariate mixed models genome-assisted prediction. doi: https://doi.org/10.1101/354639 Bernardo Rex. 2010. Breeding quantitative traits plants. Second edition. Stemma Press. 390 pp. Gilmour et al. 1995. Average Information REML: efficient algorithm variance parameter estimation linear mixed models. Biometrics 51(4):1440-1450. Henderson C.R. 1975. Best Linear Unbiased Estimation Prediction Selection Model. Biometrics vol. 31(2):423-447. Kang et al. 2008. Efficient control population structure model organism association mapping. Genetics 178:1709-1723. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Lee et al. 2015. MTG2: efficient algorithm multivariate linear mixed model analysis based genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201. Maier et al. 2015. Joint analysis psychiatric disorders increases accuracy risk prediction schizophrenia, bipolar disorder, major depressive disorder. J Hum Genet; 96(2):283-294. Rodriguez-Alvarez, Maria Xose, et al. Correcting spatial heterogeneity plant breeding experiments P-splines. Spatial Statistics 23 (2018): 52-71. Searle. 1993. Applying EM algorithm calculating ML REML estimates variance components. Paper invited 1993 American Statistical Association Meeting, San Francisco. Yu et al. 2006. unified mixed-model method association mapping accounts multiple levels relatedness. Genetics 38:203-208. Tunnicliffe W. 1989. use marginal likelihood time series model estimation. JRSS 51(1):15-27.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"the-specification-of-multiresponse-model","dir":"Articles","previous_headings":"SECTION 1: The new syntax of sommer","what":"1) The specification of multiresponse model","title":"Changes and FAQs for the sommer package","text":"past versions (depending old version) argument called MVM set TRUE user wanted run true multi-trait model since specification fixed= cbind(y1,y2)~x default fit 2 univariate models parallel. longer case, MVM argument doesn’t exist model like one specified run true multi-trait model.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"the-specification-of-multivariate-unknown-covariance-structures","dir":"Articles","previous_headings":"SECTION 1: The new syntax of sommer","what":"2) The specification of multivariate unknown covariance structures","title":"Changes and FAQs for the sommer package","text":"previous versions introduced multivariate solver decided follow asreml syntax specify unknown covariance structure needed estimated. example, diagonal model multitrait model, assuming random effect called re looked something like : fixed= cbind(y1,y2)~x random= ~ diag(trait):re unstructured multitrait model : random= ~ usr(trait):re Although easier users familiar asreml, put lot limitations way constraints variance components specified. model new versions looks like : random= ~ vsr(re, Gtc=unsm(2)) Gtc argument helps usr indicate type structure random effect represents. specified unstructured model function unsm() number 2 2 traits. user can specify either diag() uncm(), customized matrix dimensions t x t (t number traits) containing number 0,1,2,3 specify constraint: 0: estimated 1: estimated constrained positive (.e. variance component) 2: estimated unconstrained (can negative positive, .e. covariance component) 3: estimated fixed (value provided Gti argument) models fit model following variance re: var(u)=Tvar(u) = T⊗\\otimesAA : 𝐯𝐚𝐫(𝐮)=[σgt1,t12σgt1,t2σgt2,t1σgt2,t22]⊗\\mathbf{var(u)} = \\left[\\begin{array} {rr} {\\sigma^2_{g_{_{t1,t1}}}} & {\\sigma_{g_{_{t1,t2}}}} \\\\ {\\sigma_{g_{_{t2,t1}}}} & {\\sigma^2_{g_{_{t2,t2}}}} \\\\ \\end{array}\\right] \\otimes making change now, user full control constraints applied estimation variance components can provide initial values easily using Gti argument.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"the-specification-of-additional-unknown-covariance-structures","dir":"Articles","previous_headings":"SECTION 1: The new syntax of sommer","what":"3) The specification of additional unknown covariance structures","title":"Changes and FAQs for the sommer package","text":"focus moment univariate mixed model can also unknown covariance structures specified. var(u)=Evar(u) = E⊗...⊗\\otimes ... \\otimesFF⊗\\otimesAA : 𝐯𝐚𝐫(𝐮)=[σge1,e12σge1,e2σge1,e3σge2,e1σge2,e22σge2,e3σge3,e1σge3,e2σge3,e32]⊗...⊗[σgf1,f12σgf1,f2σgf2,f1σgf2,f22]⊗\\mathbf{var(u)} = \\left[\\begin{array} {rrr} {\\sigma^2_{g_{_{e1,e1}}}} & {\\sigma_{g_{_{e1,e2}}}} & {\\sigma_{g_{_{e1,e3}}}} \\\\ {\\sigma_{g_{_{e2,e1}}}} & {\\sigma^2_{g_{_{e2,e2}}}} & {\\sigma_{g_{_{e2,e3}}}} \\\\ {\\sigma_{g_{_{e3,e1}}}} & {\\sigma_{g_{_{e3,e2}}}} & {\\sigma^2_{g_{_{e3,e3}}}} \\\\ \\end{array}\\right] \\otimes ... \\otimes \\left[\\begin{array} {rr} {\\sigma^2_{g_{_{f1,f1}}}} & {\\sigma_{g_{_{f1,f2}}}} \\\\ {\\sigma_{g_{_{f2,f1}}}} & {\\sigma^2_{g_{_{f2,f2}}}} \\\\ \\end{array}\\right] \\otimes think multi trait model, similar additional kroneker product multivariate version: var(u)=Tvar(u) =T⊗\\otimesEE⊗...⊗\\otimes ... \\otimesFF⊗\\otimesAA : 𝐯𝐚𝐫(𝐮)=[σgt1,t12σgt1,t2σgt2,t1σgt2,t22]⊗[σge1,e12σge1,e2σge1,e3σge2,e1σge2,e22σge2,e3σge3,e1σge3,e2σge3,e32]⊗...⊗[σgf1,f12σgf1,f2σgf2,f1σgf2,f22]⊗\\mathbf{var(u)} = \\left[\\begin{array} {rr} {\\sigma^2_{g_{_{t1,t1}}}} & {\\sigma_{g_{_{t1,t2}}}} \\\\ {\\sigma_{g_{_{t2,t1}}}} & {\\sigma^2_{g_{_{t2,t2}}}} \\\\ \\end{array}\\right] \\otimes \\left[\\begin{array} {rrr} {\\sigma^2_{g_{_{e1,e1}}}} & {\\sigma_{g_{_{e1,e2}}}} & {\\sigma_{g_{_{e1,e3}}}} \\\\ {\\sigma_{g_{_{e2,e1}}}} & {\\sigma^2_{g_{_{e2,e2}}}} & {\\sigma_{g_{_{e2,e3}}}} \\\\ {\\sigma_{g_{_{e3,e1}}}} & {\\sigma_{g_{_{e3,e2}}}} & {\\sigma^2_{g_{_{e3,e3}}}} \\\\ \\end{array}\\right] \\otimes ... \\otimes \\left[\\begin{array} {rr} {\\sigma^2_{g_{_{f1,f1}}}} & {\\sigma_{g_{_{f1,f2}}}} \\\\ {\\sigma_{g_{_{f2,f1}}}} & {\\sigma^2_{g_{_{f2,f2}}}} \\\\ \\end{array}\\right] \\otimes Getting back point–additional unknown covariance structures besides multi-trait (T) specified asreml syntax. example univariate diagonal unstructured model, assumed random effect called id representing treatments planted different environments coded second random effect called env. model used look like: fixed= y1~x random= ~ diag(env):id random= ~ usr(env):id now specified : fixed= y1~x random= ~ vsr(dsr(env),id) random= ~ vsr(usr(env),id) dsr() usr() functions specify diagonal unstructured models respectively. Now csr() customized structure available. main gain changed formulation new specification vsr() function allows contructing complex moels. example, assume individuals specified column called id tested three environments column called env measured two different time points specified column called time. may want something flexible : fixed= y1~x random= ~ id actually assume individuals correlated within environments different time points want consider envrionments indepedent. variance random effects following: 𝐯𝐚𝐫(𝐮)=[σge1,e12σge1,e2σge1,e3σge2,e1σge2,e22σge2,e3σge3,e1σge3,e2σge3,e32]⊗[σgt1,t12σgt1,t2σgt2,t1σgt2,t22]⊗\\mathbf{var(u)} = \\left[\\begin{array} {rrr} {\\sigma^2_{g_{_{e1,e1}}}} & {\\sigma_{g_{_{e1,e2}}}} & {\\sigma_{g_{_{e1,e3}}}} \\\\ {\\sigma_{g_{_{e2,e1}}}} & {\\sigma^2_{g_{_{e2,e2}}}} & {\\sigma_{g_{_{e2,e3}}}} \\\\ {\\sigma_{g_{_{e3,e1}}}} & {\\sigma_{g_{_{e3,e2}}}} & {\\sigma^2_{g_{_{e3,e3}}}} \\\\ \\end{array}\\right] \\otimes \\left[\\begin{array} {rr} {\\sigma^2_{g_{_{t1,t1}}}} & {\\sigma_{g_{_{t1,t2}}}} \\\\ {\\sigma_{g_{_{t2,t1}}}} & {\\sigma^2_{g_{_{t2,t2}}}} \\\\ \\end{array}\\right] \\otimes  possible previous versions sommer now can specified : random= ~ vsr(usr(env),dsr(time),id) logic can extended many interacting factors desired.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"the-specification-of-unknown-covariance-structures-in-the-residuals","dir":"Articles","previous_headings":"SECTION 1: The new syntax of sommer","what":"4) The specification of unknown covariance structures in the residuals","title":"Changes and FAQs for the sommer package","text":"Previously, sommer limited diagonal models residuals (unstructured available multi-trait ). Now applications discussed random term also apply residual term. Just keep mind residual term always called units. Previous versions: random= ~ diag(trait):diag(env):units random= ~ usr(trait):diag(env):units # limit New versions (>3.7): random= ~ vsr(dsr(env),units, Gtc=mm) ## can extended interacting factors random= ~ vsr(usr(env),units, Gtc=mm) ## can extended interacting factors random= ~ vsr((env),units, Gtc=mm) ## can extended interacting factors random= ~ vsr(csr(env),units, Gtc=mm) ## can extended interacting factors mm can matrix specifying type multi-trait model (constraints). example use unsm() diag(), uncm() customized matrix.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"special-models","dir":"Articles","previous_headings":"SECTION 1: The new syntax of sommer","what":"5) Special models","title":"Changes and FAQs for the sommer package","text":"previous versions use asreml formulation really limited expansion sommer sophistiated models. Now many possible models. Previous versions:","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"overlay-models","dir":"Articles","previous_headings":"SECTION 1: The new syntax of sommer > 5) Special models","what":"Overlay models","title":"Changes and FAQs for the sommer package","text":"Previous version: limited 2 columns random covariance structures. random= ~  x + (y) New versions (>3.7): theory limits. Can extended interacting factors unknown covariance structures can overlay many columns needed. Plus fully functional multivariate models. random=~ vsr(..., overlay(x1,...,xn), Gtc=mm)","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"random-regression-models","dir":"Articles","previous_headings":"SECTION 1: The new syntax of sommer > 5) Special models","what":"Random regression models","title":"Changes and FAQs for the sommer package","text":"Previous version: available New versions (>3.7): theory limits. Can extended interacting factors unknown covariance structures requires use leg() function. Plus fully functional multivariate models. random=~ vsr(usr(leg(v,1)),x) random=~ vsr(dsr(leg(v,1)),x) random=~ vsr(leg(v,1),x)","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"gwas-models","dir":"Articles","previous_headings":"SECTION 1: The new syntax of sommer > 5) Special models","what":"GWAS models","title":"Changes and FAQs for the sommer package","text":"Previous version: univariate models available New versions (>3.7): power mmer() function available plus can fit multivariate GWAS models. See details sommer.start vignettes.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"spatial-models","dir":"Articles","previous_headings":"SECTION 1: The new syntax of sommer > 5) Special models","what":"Spatial models","title":"Changes and FAQs for the sommer package","text":"Previous version: called directly formula random=~ spl2D(Row,Col,=?) New versions (>3.7): called within vsr() function now can combined unknown covariance structures available. random=~ vsr(...,spl2D(Row,Col,=?), Gtc=mm) # mm multi-trait constraint-structure.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"customized-random-effects","dir":"Articles","previous_headings":"SECTION 1: The new syntax of sommer > 5) Special models","what":"Customized random effects","title":"Changes and FAQs for the sommer package","text":"Previous version: provided grouping argument random=~ grp(x), grouping=list(x=Z) New versions (>3.7): called within vsr() function now can combined unknown covariance structures available. random=~vsr(,..., Z, Gtc=mm) # mm multi-trait constraint-structure.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"i-got-an-error-similar-to","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"1) I got an error similar to:","title":"Changes and FAQs for the sommer package","text":"error indicates model singular (phenotypic variance V matrix invertible) therefore model stopped, throwing error message returning empty list. can try simpler model just modify argument tolparinv mmer() function. default 1e-3, means try invert V fails try add small value diagonal V 1e-3 make invertible try bigger biger numbers. fails program return empty list. Sometimes model becomes singular use variance covariance matrices (.e. genomic relationship matrices) full-rank. can try make full-rank try .","code":"# iteration    LogLik     wall    cpu(sec)   restrained #     1      -224.676   18:11:23      3           0 # Sistem is singular. Aborting the job. You could try a bigger tolparinv value."},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"my-model-runs-very-slow","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"2) My model runs very slow","title":"Changes and FAQs for the sommer package","text":"Keep mind sommer uses direct inversion (DI) algorithm can slow large datasets. package focused problems type p > n (random effect levels observations) models dense covariance structures. example, experiment dense covariance structures low-replication (.e. 2000 records 1000 individuals replicated twice covariance structure 1000x1000) direct-inversion used mmer() faster MME-based algorithms Also genomic problems large number random effect levels, .e. 300 individuals (n) 100,000 genetic markers (p). highly replicated trials small covariance structures n > p (.e. 2000 records 200 individuals replicated 10 times covariance structure 200x200) mmec() function sommer MME-based algorithms much faster recommend opt software.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"can-i-run-both-rrblup-for-markers-and-gblup-for-individuals-in-sommer","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"3) Can I run both; rrBLUP for markers and GBLUP for individuals in sommer?","title":"Changes and FAQs for the sommer package","text":"types models can fitted sommer. Please see vignette #1.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"i-am-missing-blups-for-individuals-even-when-i-provided-them-in-the-relationship-matrix","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"4) I am missing BLUPs for individuals even when I provided them in the relationship matrix","title":"Changes and FAQs for the sommer package","text":"got good question past: “want fit animal model sommer package using additive relationship matrix(), matrix contain parents. random effects contains animals random effect including parents matrix. can get random effects parents?” Answer: easy way make sure even parents don’t show dataset, need make sure present levels column contains individuals (.e. animal IDs), addition provided relationship matrix ’s . returned blups. 4.1.2 shouldn’t problem since internally mmer() solver adds missing levels, leave reference people using older versions sommer.","code":"library(sommer) ## Loading required package: Matrix ## Loading required package: MASS ## Loading required package: crayon data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata #### create the variance-covariance matrix A <- A.mat(GT) # additive relationship matrix #### look at the data and fit the model set.seed(12) DT2 <- droplevels(DT[sample(1:nrow(DT),100),]) # we simulate a dataset with only 100 animals nrow(DT2); length(levels(DT2$id)) ## [1] 100 ## [1] 100 # we fit a model with the reduced datatset where only 100 blups will be returned since only # 100 levels exist in the \"id\" column mix1 <- mmer(Yield~1,               random=~vsr(id,Gu=A)                       + Rowf + Colf,               rcov=~units,               data=DT2, verbose = FALSE) ## Adding additional levels of Gu in the model matrix of 'id' summary(mix1) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -47.00674 96.01348 98.61865     NR     TRUE ## ============================================================ ## Variance-Covariance components: ##                   VarComp VarCompSE Zratio Constraint ## u:id.Yield-Yield   1531.7    1000.9  1.530   Positive ## Rowf.Yield-Yield    157.1     297.5  0.528   Positive ## Colf.Yield-Yield      0.0     396.4  0.000   Positive ## units.Yield-Yield  3358.4     883.6  3.801   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)    127.4     7.214   17.66 ## ============================================================ ## Groups and observations: ##      Yield ## u:id   363 ## Rowf    13 ## Colf    35 ## ============================================================ ## Use the '$' sign to access results and parameters length(mix1$U$`u:id`$Yield) # only 100 levels ## [1] 363 # we add additional levels to the \"id\" column and also provide them in the relationship matrix levels(DT2$id) <- c(levels(DT2$id), setdiff(levels(DT$id), levels(DT2$id))) mix2 <- mmer(Yield~1,              random=~vsr(id,Gu=A)              + Rowf + Colf,              rcov=~units,              data=DT2, verbose = FALSE) summary(mix2) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -47.00674 96.01348 98.61865     NR     TRUE ## ============================================================ ## Variance-Covariance components: ##                   VarComp VarCompSE Zratio Constraint ## u:id.Yield-Yield   1531.7    1000.9  1.530   Positive ## Rowf.Yield-Yield    157.1     297.5  0.528   Positive ## Colf.Yield-Yield      0.0     396.4  0.000   Positive ## units.Yield-Yield  3358.4     883.6  3.801   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)    127.4     7.214   17.66 ## ============================================================ ## Groups and observations: ##      Yield ## u:id   363 ## Rowf    13 ## Colf    35 ## ============================================================ ## Use the '$' sign to access results and parameters length(mix2$U$`u:id`$Yield) # now 363 levels ## [1] 363"},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"how-can-i-use-the-ar1-cs-and-arma-functions","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"5) How can I use the AR1(), CS() and ARMA() functions","title":"Changes and FAQs for the sommer package","text":"Sommer doesn’t support estimation additional correlation components like AR1 way asreml . Still, user knows correlation value can iterative approach find best value functions can used specify variance covariance structure given random effect. example, DT_cpdata dataset field row column coordinates. allows fitting row column random effects: user wants relax independence rows define AR1 covariance structure among rows model fitted : done column random effect: hand, like model presence correlation row columns time model look like : Notice specify random effect interaction 2 random effects covariance structure specified Gu argument built using kronecker() function. applies ARMA() CS() functions. Please keep mind correlation values (rho argument) fixed value estimated REML like asreml can always follow iterative approach.","code":"library(sommer) data(DT_cpdata) DT <- DT_cpdata mix1 <- mmer(Yield~1,               random=~ Rowf + Colf,               rcov=~units,               data=DT, verbose = FALSE) summary(mix1)$varcomp ##                     VarComp VarCompSE    Zratio Constraint ## Rowf.Yield-Yield   832.2879  393.8951  2.112968   Positive ## Colf.Yield-Yield   153.9201  126.7582  1.214281   Positive ## units.Yield-Yield 3647.3486  290.4910 12.555804   Positive library(sommer) data(DT_cpdata) DT <- DT_cpdata mixAR1row <- mmer(Yield~1,              random=~ vsr(Rowf, Gu=AR1(Rowf, rho=0.3)) + Colf,              rcov=~units,              data=DT, verbose = FALSE) summary(mixAR1row)$varcomp ##                      VarComp VarCompSE    Zratio Constraint ## u:Rowf.Yield-Yield  791.8219  387.8695  2.041465   Positive ## Colf.Yield-Yield    154.5660  126.8094  1.218885   Positive ## units.Yield-Yield  3643.6027  290.1689 12.556834   Positive library(sommer) data(DT_cpdata) DT <- DT_cpdata mixAR1col <- mmer(Yield~1,              random=~ Rowf + vsr(Colf, Gu=AR1(Colf, rho=0.3)),              rcov=~units,              data=DT, verbose = FALSE) summary(mixAR1col)$varcomp ##                      VarComp VarCompSE    Zratio Constraint ## Rowf.Yield-Yield    830.3623  392.8264  2.113815   Positive ## u:Colf.Yield-Yield  178.7490  134.2703  1.331262   Positive ## units.Yield-Yield  3624.6074  287.6072 12.602629   Positive library(sommer) data(DT_cpdata) DT <- DT_cpdata mixAR1rowcol <- mmer(Yield~1,                   random=~ vsr(Rowf:Colf,                                Gu=kronecker(AR1(Rowf, rho=0.3),AR1(Colf, rho=0.3),make.dimnames = TRUE)                                ),                   rcov=~units,                   data=DT, verbose = FALSE) summary(mixAR1rowcol)$varcomp ##                          VarComp VarCompSE   Zratio Constraint ## u:Rowf:Colf.Yield-Yield 2474.339  730.1474 3.388821   Positive ## units.Yield-Yield       2025.584  622.1023 3.256030   Positive"},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"can-i-run-gwas-in-met-experiments-with-replicates","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"6) Can I run GWAS in MET experiments with replicates?","title":"Changes and FAQs for the sommer package","text":"Yes, please see vignette QG using sommer method GWAS GBLUP.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"how-can-i-constrain-the-value-of-specific-random-effects","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"7) How can I constrain the value of specific random effects?","title":"Changes and FAQs for the sommer package","text":"using vsr() function three additional arguments help control following: Gu: matrix covariances among levels u.th random effect Gti: matrix initial values variance-covariance components Gtc: matrix constraints variance-covariance components Since random effect can seen multi-trait variance covariance structure, univariate models just extension multi-trait variance covariance structure 1 x 1 matrix. inspecting results mixed models fitted mmer() function corresponding variance components stored sigma element, notice random effect contains t x t matrix corresponds multi-trait structure referred . example: sigma element contains random effects id units (error). contains matrix 1 1, multi trait model look like : Notice 2 traits becomes 2 2 matrix. order put constraints random effect matrices can use Gtc argument show . id random effect specified variance components estimated positive (diagonals 1), whereas covariance components estimated unconstrained positive negative (-diagonals 2). hand, units (error) random effect specified Gtc argument variance components estimated positive (diagonals), whereas covariance components estimated (-diagonals 0) user like constrain value fixed change estimation process random effects user needs provide initial value (scaled respect error variance) variance-covariance components Gti argument use matrix value 3 Gtc constraint matrix. vsc() function used mmec() c x c problem theta thetaC arguments can used directly covariance structures. example fix residuals equal 1:","code":"data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata #### create the variance-covariance matrix A <- A.mat(GT) # additive relationship matrix #### look at the data and fit the model mix1 <- mmer(Yield~1,               random=~vsr(id,Gu=A),               rcov=~units,               data=DT, verbose = FALSE) mix1$sigma$`u:id` ##          Yield ## Yield 650.4145 data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata #### create the variance-covariance matrix A <- A.mat(GT) # additive relationship matrix #### look at the data and fit the model mix2 <- mmer(cbind(Yield,color)~1,               random=~vsr(id,Gu=A, Gtc=unsm(2)),               rcov=~vsr(units,Gtc=diag(2)),               data=DT, verbose = FALSE) mix2$sigma$`u:id` ##             Yield       color ## Yield 634.6295932 0.471715518 ## color   0.4717155 0.005126228 unsm(2) ##      [,1] [,2] ## [1,]    1    2 ## [2,]    2    1 mix2$sigma$`u:id` ##             Yield       color ## Yield 634.6295932 0.471715518 ## color   0.4717155 0.005126228 diag(2) ##      [,1] [,2] ## [1,]    1    0 ## [2,]    0    1 mix2$sigma$`u:units` ##          Yield       color ## Yield 4009.336 0.000000000 ## color    0.000 0.002563711 mm <- matrix(3,1,1) ## matrix to fix the var comp initialVal <- mix1$sigma_scaled$`u:id`/2 # we want to fix the vc to be half of the previous uinvariate model  mix3 <- mmer(Yield~1,               random=~vsr(id, Gu=A, Gti=initialVal, Gtc=mm), # constrained               rcov=~vsr(units), # unconstrained               data=DT, verbose = FALSE)  # analyze variance components summary(mix1)$varcomp ##                     VarComp VarCompSE    Zratio Constraint ## u:id.Yield-Yield   650.4145  325.5562  1.997856   Positive ## units.Yield-Yield 4031.0153  344.6051 11.697493   Positive summary(mix3)$varcomp ##                       VarComp VarCompSE    Zratio Constraint ## u:id.Yield-Yield     325.2072  259.0889  1.255196      Fixed ## u:units.Yield-Yield 4051.3786  352.4804 11.493912   Positive mm <- matrix(3,1,1) ## matrix to fix the var comp vei <- var(DT$Yield, na.rm = TRUE) # we want to fix the vc to be half of the previous uinvariate model  mix3 <- mmec(Yield~1,               random=~Rowf, # unconstrained               rcov= ~ vsc(isc(units, thetaC=mm,theta=matrix(1/vei,1,1))), # constrained               data=DT, verbose = FALSE)  # analyze variance components summary(mix3)$varcomp ##                VarComp    VarCompSE       Zratio Constraint ## Rowf:isc:isc  976.0743 8.916127e-16 1.094729e+18   Positive ## units:mm:vei:   1.0000 1.227629e-03 8.145785e+02      Fixed"},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"how-can-i-constrain-two-variance-components-to-be-equal","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"8) How can I constrain two variance components to be equal?","title":"Changes and FAQs for the sommer package","text":"Sometimes built-capacities sommer flexible enough users want. One situations fix variance components equal. Let’s simulate multitrait data: Now lets assume want fit multitrait model unstructured error variance structure built-capacity. easy : now assume like constrain variance y1 y2 equal. requires user take different approach. user can build externally multitrait matrices fit directly. Let’s recreate exact result using built-capabilities: Notice fitted univariate model built kernels fitted kernels one one. Now constrain two variance components equal. done following way:","code":"library(\"MASS\")  ## needed for mvrnorm n <- 100 mu <- c(1,2) Sigma <- matrix(c(10,5,5,10),2,2) Y <- mvrnorm(n,mu,Sigma); colnames(Y) <- c(\"y1\",\"y2\") ## this simulates multivariate normal rvs y <- as.vector(t(Y)) df1 <- data.frame(Y) df2 <- data.frame(y) mix1 <- mmer(cbind(y1,y2)~1, rcov=~vsr(units, Gtc=unsm(2)), data=df1, verbose = FALSE) mix1$sigma ## $`u:units` ##          y1        y2 ## y1 9.902536  5.543521 ## y2 5.543521 10.125877 X <- kronecker(rep(1,n),diag(1,2)) V1 <- matrix(c(1,0,0,0),2,2) V2 <- matrix(c(0,0,0,1),2,2) V3 <- matrix(c(0,1,1,0),2,2) sig1 <- kronecker(diag(1,n),V1) # variance component 1 sig2 <- kronecker(diag(1,n),V2) # variance component 2 gam <- kronecker(diag(1,n),V3) # covariance component # now fit the model mix2 <- mmer(y~X-1, rcov = ~vsr(sig1)+vsr(sig2)+vsr(gam,Gti = matrix(.15)), data=df2, verbose = FALSE) mix2$sigmaVector ## u:sig1.y-y u:sig2.y-y  u:gam.y-y  ##   9.902350  10.125683   5.543179 sig <- sig1+sig2 mix3 <- mmer(y~X-1, rcov = ~vsr(sig)+vsr(gam,Gti = matrix(.15)), data=df2, nIters=30, verbose = FALSE) mix3$sigmaVector ## u:sig.y-y u:gam.y-y  ## 10.014017  5.543179"},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"i-get-an-error-when-installing-directly-from-github","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"9) I get an error when installing directly from github","title":"Changes and FAQs for the sommer package","text":"people experience issues trying install newest version sommer GitHub mac computer using following command line: devtools::install_github(‘covaruber/sommer’) one error messages identified users related installation gfortran compiler. issue, information following website may solve instalation problem: https://www.cynkra.com/blog/2021-03-16-gfortran-macos/","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"i-get-an-error-when-specifying-an-interaction-of-the-form-xz","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"10) I get an error when specifying an interaction of the form X:Z","title":"Changes and FAQs for the sommer package","text":"get error message similar following specifying interaction model: Error X:Z : NA/NaN argument addition: Warning messages: 1: X:Z : numerical expression “n” elements: first used 2: X:Z : numerical expression “n” elements: first used 3: eval(substitute(expr), data, enclos = parent.frame()) : NAs introduced coercion Please check variables interaction class factor. Making factors using .factor() function fix error.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"i-get-the-error-contrasts-tmp-value-contr-funs1-isofnn","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"11) I get the error: contrasts<-(*tmp*, value = contr.funs[1 + isOF[nn]])","title":"Changes and FAQs for the sommer package","text":"get error message similar following fitting model: Error contrasts<-(*tmp*, value = contr.funs[1 + isOF[nn]]) : contrasts can applied factors 2 levels Please check dataset regular dataframe. dataset used input class tibtable may get error message. Please use following command fix issue: dataset <- .data.frame(dataset) put dataset expected format.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"i-get-an-error-error-addition-incompatible-matrix-dimensions-n1xn1-and-n2xn2","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"12) I get an error “Error: addition: incompatible matrix dimensions: n1xn1 and n2xn2”","title":"Changes and FAQs for the sommer package","text":"likely ’re fitting different residual variance different levels random variable. Please make sure sort dataset variables ’re fitting residuals . example: DT=DT[(DT, order(Env)), ] sorts data set named DT levels variable named Env. way model different residual variance level Env can fitted : rcov ~ vsc(dsc(Env), isc(units))","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"my-mmec-model-only-runs-few-iterations-giving-meaningless-results","dir":"Articles","previous_headings":"SECTION 2: Frequently asked questions","what":"13) My mmec model only runs few iterations giving meaningless results","title":"Changes and FAQs for the sommer package","text":"can happen units trait modeled either small big. Try scaling units trait differences levels either big (var>10,000) small units (var < 0.01). Alternatively, modify argument tolParInv smaller value like 1e-8 higher. Last probably best since guaranteed work , scale trait using scale() function.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v2.sommer.changes.and.faqs.html","id":"literature","dir":"Articles","previous_headings":"","what":"Literature","title":"Changes and FAQs for the sommer package","text":"Covarrubias-Pazaran G. 2016. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6):1-15. Covarrubias-Pazaran G. 2018. Software update: Moving R package sommer multivariate mixed models genome-assisted prediction. doi: https://doi.org/10.1101/354639 Bernardo Rex. 2010. Breeding quantitative traits plants. Second edition. Stemma Press. 390 pp. Gilmour et al. 1995. Average Information REML: efficient algorithm variance parameter estimation linear mixed models. Biometrics 51(4):1440-1450. Henderson C.R. 1975. Best Linear Unbiased Estimation Prediction Selection Model. Biometrics vol. 31(2):423-447. Kang et al. 2008. Efficient control population structure model organism association mapping. Genetics 178:1709-1723. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Lee et al. 2015. MTG2: efficient algorithm multivariate linear mixed model analysis based genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201. Maier et al. 2015. Joint analysis psychiatric disorders increases accuracy risk prediction schizophrenia, bipolar disorder, major depressive disorder. J Hum Genet; 96(2):283-294. Rodriguez-Alvarez, Maria Xose, et al. Correcting spatial heterogeneity plant breeding experiments P-splines. Spatial Statistics 23 (2018): 52-71. Searle. 1993. Applying EM algorithm calculating ML REML estimates variance components. Paper invited 1993 American Statistical Association Meeting, San Francisco. Yu et al. 2006. unified mixed-model method association mapping accounts multiple levels relatedness. Genetics 38:203-208. Tunnicliffe W. 1989. use marginal likelihood time series model estimation. JRSS 51(1):15-27.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"backgrounds-in-linear-algebra","dir":"Articles","previous_headings":"SECTION 1: Introduction","what":"Backgrounds in linear algebra","title":"Quantitative genetics using the sommer package","text":"core package mmer() mmec functions solve mixed model equations. functions interface call NR Direct-Inversion Newton-Raphson Average Information mme-based Average Information (Tunnicliffe 1989; Gilmour et al. 1995; Lee et al. 2016). Since version 2.0, sommer can handle multivariate models. Following Maier et al. (2015), multivariate (extension univariate) mixed model implemented form:  y1=X1β1+Z1u1+ϵ1y_1 = X_1\\beta_1 + Z_1u_1 + \\epsilon_1 y2=X2β2+Z2u2+ϵ2y_2 = X_2\\beta_2 + Z_2u_2 + \\epsilon_2 … yi=Xiβi+Ziui+ϵiy_i = X_i\\beta_i + Z_iu_i + \\epsilon_i  yiy_i vector trait phenotypes, βi\\beta_i vector fixed effects, uiu_i vector random effects individuals eie_i residuals trait (= 1, …, t). random effects (u1u_1 … uiu_i eie_i) assumed normally distributed mean zero. X Z incidence matrices fixed random effects respectively. distributions multivariate response phenotypic variance covariance (V) :  Y=Xβ+ZU+ϵiY = X\\beta + ZU + \\epsilon_i  Y ~ MVN(XβX\\beta, V)  𝐘=[y1y2...yt]\\mathbf{Y} = \\left[\\begin{array} {r} y_1 \\\\ y_2 \\\\ ... \\\\ y_t \\\\ \\end{array}\\right]  𝐗=[X1......⋮⋱⋮......Xt]\\mathbf{X} = \\left[\\begin{array} {rrr} X_1 & ... & ... \\\\ \\vdots & \\ddots & \\vdots\\\\ ... & ... & X_t \\\\ \\end{array}\\right]  𝐕=[Z1Kσg12Z1′+Hσϵ12...Z1Kσg1,tZt′+Hσϵ1,t⋮⋱⋮Z1Kσg1,tZt′+Hσϵ1,t...ZtKσgt2Zt′+Hσϵt2]\\mathbf{V} = \\left[\\begin{array} {rrr} Z_1 K{\\sigma^2_{g_{1}}} Z_1' + H{\\sigma^2_{\\epsilon_{1}}} & ... & Z_1 K{\\sigma_{g_{1,t}}} Z_t' + H{\\sigma_{\\epsilon_{1,t}}}\\\\  \\vdots & \\ddots & \\vdots\\\\ Z_1 K{\\sigma_{g_{1,t}}} Z_t' + H{\\sigma_{\\epsilon_{1,t}}} & ... & Z_t K{\\sigma^2_{g_{t}}} Z_t' + H{\\sigma^2_{\\epsilon_{t}}} \\\\ \\end{array}\\right]  K relationship covariance matrix kth random effect (u=1,…,k), R=identity matrix residual term. terms σgi2\\sigma^2_{g_{}} σϵi2\\sigma^2_{\\epsilon_{}} denote genetic (kth random terms) residual variance trait , respectively σgij\\sigma_{g_{_{ij}}} σϵij\\sigma_{\\epsilon_{_{ij}}} genetic (kth random terms) residual covariance traits j (=1,…,t, j=1,…,t). algorithm implemented optimizes log likelihood:  logL=1/2*ln(|V|)+ln(X′|V|X)+Y′PYlogL = 1/2 * ln(|V|) + ln(X'|V|X) + Y'PY  || determinant matrix. REML estimates updated using Newton optimization algorithm form:  θk+1=θk+(Hk)−1*dLdσi2|θk\\theta^{k+1} = \\theta^{k} + (H^{k})^{-1}*\\frac{dL}{d\\sigma^2_i}|\\theta^k  θ\\theta vector variance components random effects covariance components among traits, H−1H^{-1} inverse Hessian matrix second derivatives kth cycle, dLdσi2\\frac{dL}{d\\sigma^2_i} vector first derivatives likelihood respect variance-covariance components. Eigen decomposition relationship matrix proposed Lee Van Der Werf (2016) included Newton-Raphson algorithm improve time efficiency. Additionally, popular vpredict() function estimate standard errors linear combinations variance components (.e. heritabilities genetic correlations) added package well. Please refer canonical papers listed Literature section check algorithms work. tested widely methods make sure provide solution likelihood behaves well, complex problems might lead slightly different answers. concern please contact cova_ruber@live.com.mx. following section go detail several examples use mixed models univariate multivariate case use quantitative genetics.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"marker-and-non-marker-based-heritability-calculation","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics","what":"1) Marker and non-marker based heritability calculation","title":"Quantitative genetics using the sommer package","text":"Heritability one popular parameters among breeding genetics communities insight provides inheritance trait potential selection response. Heritability usually estimated narrow sense (h2h^2; additive variance numerator σA2\\sigma^2_A), broad sense (H2H^2; genetic variance numerator σG2\\sigma^2_G). classical breeding experiment molecular markers, special designs performed estimate dissect additive (σA2\\sigma^2_A) non-additive (e.g., dominance σD2\\sigma^2_D, epistatic σE2\\sigma^2_E) variance along environmental variability. Designs generation analysis, North Carolina designs used dissect σA2\\sigma^2_A σD2\\sigma^2_D estimate narrow sense heritability (h2h^2) using σA2\\sigma^2_A numerator. special design available can still disect genetic variance (σG2\\sigma^2_G) estimate broad sense heritability. first example show broad sense estimation doesn’t use covariance matrices genotypic effect (e.g., genomic-additive relationship matrices). big models relationship matrices, sommer’s direct inversion bad idea use still show , keep mind sparse models relationship matrices special covariance structures recommend using lmer() function lme4 package package using MME-based algorithms (e.g., asreml-R). following dataset 41 potato lines evaluated 5 locations across 3 years RCBD design. show fit model extract variance components calculate h2h^2. estimate broad-sense heritability. Recently markers becoming cheaper, thousand markers can run breeding materials. markers available, special design neccesary dissect additive genetic variance. availability additive, dominance epistatic relationship matrices allow us estimate σA2\\sigma^2_A, σD2\\sigma^2_D σI2\\sigma^2_I, although given , D E orthogonal interpretation models fit matrix time becomes cumbersome. Assume population (even unreplicated) field addition genetic markers. Now can fit model estimate genomic heritability explains portion additive genetic variance (high marker density σA2\\sigma^2_A = σmarkers2\\sigma^2_{markers}) example showed estimate additive (σA2\\sigma^2_A) dominance (σD2\\sigma^2_D) variance components based markers estimate broad (H2H^2) narrow-sense heritability (h2h^2). Notice used vsr() function indicates random effect inside parenthesis (.e. id, idd ide) covariance matrix (, D, E), specified Gu argument vsr() function. Please provide inverse, rather original covariance matrix.","code":"library(sommer) ## Loading required package: Matrix ## Loading required package: MASS ## Loading required package: crayon data(DT_example) DT <- DT_example A <- A_example  ans1 <- mmec(Yield~1,              random= ~ Name + Env + Env:Name + Env:Block,              rcov= ~ units, nIters=3,              data=DT, verbose = FALSE) summary(ans1)$varcomp ##                        VarComp    VarCompSE       Zratio Constraint ## Name:isc:isc      5.922491e+00 4.033870e-16 1.468191e+16   Positive ## Env:isc:isc       1.115162e+02 1.001923e-14 1.113021e+16   Positive ## Env:Name:isc:isc  1.973759e+01 1.155087e-16 1.708752e+17   Positive ## Env:Block:isc:isc 1.000000e-10 1.692545e-04 5.908264e-07      Fixed ## units:isc:isc     1.000000e-10 1.098857e-05 9.100366e-06   Positive (n.env <- length(levels(DT$Env))) ## [1] 3 # vpredict(ans1, h2 ~ V1 / ( V1 + (V3/n.env) + (V5/(2*n.env)) ) ) data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata DT$idd <-DT$id; DT$ide <-DT$id ### look at the data A <- A.mat(GT) # additive relationship matrix D <- D.mat(GT) # dominance relationship matrix E <- E.mat(GT) # epistatic relationship matrix ans.ADE <- mmer(color~1,                   random=~vsr(id,Gu=A) + vsr(idd,Gu=D),                   rcov=~units, nIters=3,                  data=DT,verbose = FALSE) (summary(ans.ADE)$varcomp) ##                       VarComp    VarCompSE   Zratio Constraint ## u:id.color-color  0.003486639 0.0011076709 3.147721   Positive ## u:idd.color-color 0.001286778 0.0005071774 2.537136   Positive ## units.color-color 0.002152054 0.0002976821 7.229372   Positive vpredict(ans.ADE, h2 ~ (V1) / ( V1+V3) ) # narrow sense ##     Estimate         SE ## h2 0.6183417 0.08605268 vpredict(ans.ADE, h2 ~ (V1+V2) / ( V1+V2+V3) ) # broad-sense ##     Estimate         SE ## h2 0.6892552 0.05896317"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"specifying-heterogeneous-variances-in-univariate-models","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics","what":"2) Specifying heterogeneous variances in univariate models","title":"Quantitative genetics using the sommer package","text":"often multi-environment trials, assumption genetic variance across locations may naive. , specifying general genetic component location-specific genetic variance way go. estimate variance components GCA2GCA_2 SCASCA specifying variance structure. previous example showed atr() function used mmer() solver. using atr() function can specify .e. GCA2 different variance different Locations, case locations 3 4, also main GCA variance. considered CS + DIAG (compound symmetry + diagonal) model. addition, functions can added top fit models covariance structures, .e. Gu argument vsr() function indicate covariance matrix (, pedigree genomic relationship matrix)","code":"# data(DT_cornhybrids) # DT <- DT_cornhybrids # DTi <- DTi_cornhybrids # GT <- GT_cornhybrids # ### fit the model # modFD <- mmec(Yield~1,  #               random=~ vsc(atc(Location,c(\"3\",\"4\")),isc(GCA2)),  #               rcov= ~ vsc(dsc(Location),isc(units)), nIters=3, #               returnParam = F, #               data=DT, verbose = FALSE) # summary(modFD) # data(DT_cornhybrids) # DT <- DT_cornhybrids # DTi <- DTi_cornhybrids # GT <- as(GT_cornhybrids, Class = \"dgCMatrix\") # GT[1:4,1:4] # DT=DT[with(DT, order(Location)), ] # ### fit the model # modFD <- mmec(Yield~1,  #               random=~ vsc(atc(Location,c(\"3\",\"4\")),isc(GCA2),Gu=GT),  #               rcov= ~ vsc(dsc(Location),isc(units)), nIters=3, #               data=DT, verbose = FALSE) # summary(modFD)"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"using-the-vpredict-calculator","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics","what":"3) Using the vpredict calculator","title":"Quantitative genetics using the sommer package","text":"Sometimes user needs calculate ratios functions specific variance-covariance components obtain standard errors parameters. Examples genetic correlations, heritabilities, etc. Using CPdata show estimate heritability standard error using vpredict() function uses delta method come parameters. can extended linear combination variance components.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"standar-error-for-heritability","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics > 3) Using the vpredict calculator","what":"3.1) Standar error for heritability","title":"Quantitative genetics using the sommer package","text":"can used multivariate models. Please check documentation vpredict function see examples.","code":"data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata ### look at the data A <- A.mat(GT) # additive relationship matrix ans <- mmer(color~1,                  random=~vsr(id,Gu=A),                  rcov=~units, nIters=3,                 data=DT, verbose = FALSE) (summary(ans.ADE)$varcomp) ##                       VarComp    VarCompSE   Zratio Constraint ## u:id.color-color  0.003486639 0.0011076709 3.147721   Positive ## u:idd.color-color 0.001286778 0.0005071774 2.537136   Positive ## units.color-color 0.002152054 0.0002976821 7.229372   Positive vpredict(ans, h2 ~ (V1) / ( V1+V2) ) ##     Estimate         SE ## h2 0.6405467 0.05805209"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"standar-error-for-genetic-correlation","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics > 3) Using the vpredict calculator","what":"3.2) Standar error for genetic correlation","title":"Quantitative genetics using the sommer package","text":"","code":"## just silenced to avoid too much time building the vignettes # data(DT_btdata) # DT <- DT_btdata # mix3 <- mmer(cbind(tarsus, back) ~ sex, #                random = ~ vsr(dam, Gtc=unsm(2)) + vsr(fosternest,Gtc=diag(2)), #                rcov=~vsr(units,Gtc=unsm(2)), nIters=3, #                data = DT, verbose = FALSE) # summary(mix3) # #### calculate the genetic correlation # vpredict(mix3, gen.cor ~ V2 / sqrt(V1*V3))"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"half-and-full-diallel-designs-use-of-the-overlay","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics","what":"4) Half and full diallel designs (use of the overlay)","title":"Quantitative genetics using the sommer package","text":"breeders looking best single-cross combinations, diallel designs far used design crops like maize. 4 types diallel designs depending whether reciprocal self-crosses (omission parents) performed (full diallel parents n^2; full diallel without parents n(n-1); half diallel parents 1/2 * n(n+1); half diallel without parents 1/2 * n(n-1) ). example show full diallel design (reciprocal crosses performed) half diallel designs (one directions performed). first data set show full diallel among 40 lines 2 heterotic groups, 20 . Therefore 400 possible hybrids possible. pehnotypic data 100 across 4 locations. use data available fit model form:  y=Xβ+Zu1+Zu2+ZuS+ϵy = X\\beta + Zu_1 + Zu_2 + Zu_S + \\epsilon  estimate variance components GCA1GCA_1, GCA2GCA_2 SCASCA use estimate heritability. Additionally BLUPs GCA SCA effects can used predict crosses. Don’t worry much h2 value, data simulated mainly dominance variance, therefore Va simulated extremely small leading value narrow sense h2. second data set show small half diallel 7 parents crossed one direction. n(n-1)/2 possible crosses; 7(6)/2 = 21 unique crosses. Parents appear males females indistictly. two replications CRD. half diallel design single GCA variance component males females can estimated SCA well (σG2CA\\sigma^2_GCA σS2CA\\sigma^2_SCA respectively), BLUPs GCA SCA parents can extracted. show first mmer() function using overlay() function. specific model : y=Xβ+Zug+Zus+ϵy = X\\beta + Zu_g + Zu_s + \\epsilon Notice overlay() argument makes overlap incidence matrices possible making sure male female joint single random effect.","code":"data(DT_cornhybrids) DT <- DT_cornhybrids DTi <- DTi_cornhybrids GT <- GT_cornhybrids  modFD <- mmec(Yield~Location,                random=~GCA1+GCA2+SCA,                rcov=~units, nIters=3,               data=DT, verbose = FALSE) ## Updated VC is not positive definite, changing to EM step ## Update using constraints ## Updated VC is not positive definite, changing to EM step ## Update using constraints (suma <- summary(modFD)$varcomp) ##                    VarComp VarCompSE       Zratio Constraint ## GCA1:isc:isc  1.000000e-10  36.89059 2.710718e-12      Fixed ## GCA2:isc:isc  4.629216e+01  37.14297 1.246324e+00   Positive ## SCA:isc:isc   8.937350e+01  21.56529 4.144322e+00   Positive ## units:isc:isc 2.388020e+02  28.83389 8.281992e+00   Positive Vgca <- sum(suma[1:2,1]) Vsca <- suma[3,1] Ve <- suma[4,1] Va = 4*Vgca Vd = 4*Vsca Vg <- Va + Vd (H2 <- Vg / (Vg + (Ve)) ) ## [1] 0.6944174 (h2 <- Va / (Vg + (Ve)) ) ## [1] 0.2369507 data(\"DT_halfdiallel\") DT <- DT_halfdiallel head(DT) ##   rep geno male female     sugar ## 1   1   12    1      2 13.950509 ## 2   2   12    1      2  9.756918 ## 3   1   13    1      3 13.906355 ## 4   2   13    1      3  9.119455 ## 5   1   14    1      4  5.174483 ## 6   2   14    1      4  8.452221 DT$femalef <- as.factor(DT$female) DT$malef <- as.factor(DT$male) DT$genof <- as.factor(DT$geno) #### model using overlay modh <- mmec(sugar~1,               random=~vsc(isc(overlay(femalef,malef)) )              + genof, nIters=3,              data=DT, verbose = FALSE) summary(modh)$varcomp ##                            VarComp    VarCompSE       Zratio Constraint ## femalef:malef:isc:isc 5.780585e+00 8.281722e-17 6.979932e+16   Positive ## genof:isc:isc         2.133867e+01 7.516095e-17 2.839064e+17   Positive ## units:isc:isc         1.000000e-10 1.697717e-05 5.890264e-06   Positive"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"genomic-selection-predicting-mendelian-sampling","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics","what":"5) Genomic selection: predicting mendelian sampling","title":"Quantitative genetics using the sommer package","text":"section use wheat data CIMMYT show genomic selection performed. case prediction specific individuals within population. basically uses similar model form:  y=Xβ+Zu+ϵy = X\\beta + Zu + \\epsilon  takes advantage variance covariance matrix genotype effect known additive relationship matrix () calculated using .mat function establish connections among individuals predict BLUPs individuals measured. prediction accuracy depends several factors heritability (h2h^2), training population used (TP), size TP, etc. Please notice specifying marker matrix random effect used argument ‘buildGu=FALSE’ inform ‘mmer’ function covariance matrix levels random effect shouldn’t built. Imagine model 100,000 markers, imply relationship matrix 100,000 x 100,000. matrix diagonal compromise speed memory function. setting ‘buildGu=FALSE’ mmer solver avoid matrix multiplications using huge diagonal matrix. want specify relationship matrix marker matrix use ‘buildGu’ argument.","code":"data(DT_wheat) DT <- DT_wheat GT <- GT_wheat[,1:200] colnames(DT) <- paste0(\"X\",1:ncol(DT)) DT <- as.data.frame(DT);DT$id <- as.factor(rownames(DT)) # select environment 1 rownames(GT) <- rownames(DT) K <- A.mat(GT) # additive relationship matrix colnames(K) <- rownames(K) <- rownames(DT) # GBLUP pedigree-based approach set.seed(12345) y.trn <- DT vv <- sample(rownames(DT),round(nrow(DT)/5)) y.trn[vv,\"X1\"] <- NA head(y.trn) ##              X1          X2          X3         X4   id ## 775   1.6716295 -1.72746986 -1.89028479  0.0509159  775 ## 2166 -0.2527028  0.40952243  0.30938553 -1.7387588 2166 ## 2167         NA -0.64862633 -0.79955921 -1.0535691 2167 ## 2465  0.7854395  0.09394919  0.57046773  0.5517574 2465 ## 3881  0.9983176 -0.28248062  1.61868192 -0.1142848 3881 ## 3889  2.3360969  0.62647587  0.07353311  0.7195856 3889 ## GBLUP ans <- mmer(X1~1,             random=~vsr(id,Gu=K),              rcov=~units,nIters=3,             data=y.trn, verbose = FALSE) # kinship based ans$U$`u:id`$X1 <- as.data.frame(ans$U$`u:id`$X1) rownames(ans$U$`u:id`$X1) <- gsub(\"id\",\"\",rownames(ans$U$`u:id`$X1)) cor(ans$U$`u:id`$X1[vv,],DT[vv,\"X1\"], use=\"complete\") ## [1] 0.4310372 ## rrBLUP ans2 <- mmer(X1~1,              random=~vsr(list(GT), buildGu = FALSE),               rcov=~units, getPEV = FALSE, nIters=3,              data=y.trn, verbose = FALSE) # kinship based  u <- GT %*% as.matrix(ans2$U$`u:GT`$X1) # BLUPs for individuals rownames(u) <- rownames(GT) cor(u[vv,],DT[vv,\"X1\"]) # same correlation ## [1] 0.4370181 # the same can be applied in multi-response models in GBLUP or rrBLUP"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"indirect-genetic-effects","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics","what":"6) Indirect genetic effects","title":"Quantitative genetics using the sommer package","text":"General variance structures can used fit indirect genetic effects. , use example dataset show can fit variance covariance components two different random effects. first fit direct genetic effects model: now fit indirect genetic effects model without covariance DGE IGE: now fit indirect genetic effects model covariance DGE IGE use gvsr() function: top can include relationship matrix two random effects forced co-vary","code":"# data(DT_ige) # DT <- DT_ige # Af <- A_ige # An <- A_ige  ## Direct genetic effects model # modDGE <- mmec(trait ~ block, #                random = ~ focal, #                rcov = ~ units, nIters=3, #                data = DT, verbose=FALSE) # summary(modDGE)$varcomp # data(DT_ige) # DT <- DT_ige # A <- A_ige #  # ## Indirect genetic effects model # modIGE <- mmec(trait ~ block, dateWarning = FALSE, #                random = ~ focal + neighbour, verbose = FALSE, #                rcov = ~ units, nIters=100, #               data = DT) # summary(modIGE)$varcomp # ### Indirect genetic effects model # modIGE <- mmec(trait ~ block, dateWarning = FALSE, #                random = ~ covc( vsc(isc(focal)), vsc(isc(neighbour)) ), #                rcov = ~ units, nIters=100, verbose = FALSE, #               data = DT) # summary(modIGE)$varcomp ### Indirect genetic effects model # Ai <- as( solve(A_ige + diag(1e-5, nrow(A_ige),nrow(A_ige) )), Class=\"dgCMatrix\") # # Indirect genetic effects model with covariance between DGE and IGE using relationship matrices # modIGE <- mmec(trait ~ block, dateWarning = FALSE, #                random = ~ covc( vsc(isc(focal), Gu=Ai), vsc(isc(neighbour), Gu=Ai) ), #                rcov = ~ units, nIters=100, verbose = FALSE, #               data = DT) # summary(modIGE)$varcomp"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"genomic-selection-single-cross-prediction","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics","what":"7) Genomic selection: single cross prediction","title":"Quantitative genetics using the sommer package","text":"prediction single cross performance phenotype can dissected three main components, general combining abilities (GCA) specific combining abilities (SCA). can expressed model analyzed diallel experiment mentioned :  y=Xβ+Zu1+Zu2+ZuS+ϵy = X\\beta + Zu_1 + Zu_2 + Zu_S + \\epsilon  :  u1u_1 ~ N(0, K1K_1σu21\\sigma^2_u1) u2u_2 ~ N(0, K2K_2σu22\\sigma^2_u2) usu_s ~ N(0, K3K_3σu2s\\sigma^2_us)  can specify K matrices. main difference model full half diallel designs fact model include variance covariance structures three random effects (GCA1, GCA2 SCA) able predict crosses ocurred yet. use data published Technow et al. (2015) show prediction single crosses. previous model used GCA effects (GCA1 GCA2) practicity, altough ’s shown SCA effect doesn’t actually help much increasing prediction accuracy, increase lot computation intensity required since variance covariance matrix SCA kronecker product variance covariance matrices GCA effects, resulting 10578 x 10578 matrix increases intensive manner computation required. model without covariance structures show SCA variance component insignificant compared GCA effects. including third random effect doesn’t increase prediction accuracy.","code":"data(DT_technow) DT <- DT_technow Md <- (Md_technow*2) - 1 Mf <- (Mf_technow*2) - 1 Ad <- A.mat(Md) Af <- A.mat(Mf) Adi <- as(solve(Ad + diag(1e-4,ncol(Ad),ncol(Ad))), Class=\"dgCMatrix\") Afi <- as(solve(Af + diag(1e-4,ncol(Af),ncol(Af))), Class=\"dgCMatrix\") # RUN THE PREDICTION MODEL y.trn <- DT vv1 <- which(!is.na(DT$GY)) vv2 <- sample(vv1, 100) y.trn[vv2,\"GY\"] <- NA anss2 <- mmec(GY~1,                random=~vsc(isc(dent),Gu=Adi) + vsc(isc(flint),Gu=Afi),                rcov=~units, nIters=15,               data=y.trn, verbose = FALSE)  summary(anss2)$varcomp ##                    VarComp VarCompSE   Zratio Constraint ## dent:Adi:isc:isc  15.86817  2.992973 5.301809   Positive ## flint:Afi:isc:isc 11.29153  3.280194 3.442337   Positive ## units:isc:isc     15.97828  2.831564 5.642916   Positive # zu1 <- model.matrix(~dent-1,y.trn) %*% anss2$uList$`vsc(isc(dent), Gu = Adi)` # zu2 <- model.matrix(~flint-1,y.trn) %*% anss2$uList$`vsc(isc(flint), Gu = Afi)` # u <- zu1+zu2+as.vector(anss2$b) # cor(u[vv2,], DT$GY[vv2])"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"spatial-modeling-using-the-2-dimensional-spline","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics","what":"8) Spatial modeling: using the 2-dimensional spline","title":"Quantitative genetics using the sommer package","text":"use CPdata show use 2-dimensional splines accomodating spatial effects field experiments. early generation variety trials availability seed low, makes use unreplicated designs neccesity anything else. Experimental designs augmented designs partially-replicated (p-rep) designs becoming ever common days. order good job modeling spatial trends happening field, special covariance structures proposed accomodate spatial trends (.e. autoregressive residuals; ar1). Unfortunately, covariance structures make modeling rather unstable. recently, research groups proposed use 2-dimensional splines overcome issues robust modeling spatial terms (Lee et al. 2013; Rodríguez-Álvarez et al. 2018). example assume unreplicated population row range information available allows us fit 2 dimensional spline model. Notice job done spl2Da() function takes Row Col information fit spatial kernel.","code":"data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata ### mimic two fields A <- A.mat(GT) mix <- mmer(Yield~1,             random=~vsr(id, Gu=A) +               vsr(Rowf) +               vsr(Colf) +               spl2Da(Row,Col), nIters=3,             rcov=~vsr(units),             data=DT, verbose = FALSE) summary(mix) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC     BIC Method Converge ## Value -151.2647 304.5293 308.421     NR    FALSE ## ============================================================ ## Variance-Covariance components: ##                     VarComp VarCompSE Zratio Constraint ## u:id.Yield-Yield      792.6     317.6 2.4959   Positive ## u:Rowf.Yield-Yield    807.6     371.3 2.1750   Positive ## u:Colf.Yield-Yield    183.2     139.7 1.3121   Positive ## A:all.Yield-Yield     515.8     701.3 0.7354   Positive ## u:units.Yield-Yield  2918.4     292.8 9.9667   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)    132.1     8.761   15.08 ## ============================================================ ## Groups and observations: ##        Yield ## u:id     363 ## u:Rowf    13 ## u:Colf    36 ## A:all    168 ## ============================================================ ## Use the '$' sign to access results and parameters # make a plot to observe the spatial effects found by the spl2D() W <- with(DT,spl2Da(Row,Col)) # 2D spline incidence matrix DT$spatial <- W$Z$`A:all`%*%mix$U$`A:all`$Yield # 2D spline BLUPs # lattice::levelplot(spatial~Row*Col, data=DT) # plot the spatial effect by row and column"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"multivariate-genetic-models-and-genetic-correlations","dir":"Articles","previous_headings":"SECTION 2: Topics in quantitative genetics","what":"9) Multivariate genetic models and genetic correlations","title":"Quantitative genetics using the sommer package","text":"Sometimes important estimate genetic variance-covariance among traits–multi-reponse models useful task. Let see example 3 traits (color, Yield, Firmness) single random effect (genotype; id) although multiple effects can modeled well. need use variance covariance structure random effect able obtain genetic covariance among traits. Now can extract BLUPs using randef(ans.m) simply ans.m$U. Also, genetic correlations heritabilities can calculated easily.","code":"# data(DT_cpdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # A <- A.mat(GT) # ans.m <- mmer(cbind(Yield,color)~1, #                random=~ vsr(id, Gu=A, Gtc=unsm(2)) #                + vsr(Rowf,Gtc=diag(2)) #                + vsr(Colf,Gtc=diag(2)), #                rcov=~ vsr(units, Gtc=unsm(2)), nIters=3, #                data=DT, verbose = FALSE) # cov2cor(ans.m$sigma$`u:id`)"},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"partitioned-model","dir":"Articles","previous_headings":"SECTION 3: Special topics in Quantitative genetics","what":"1) Partitioned model","title":"Quantitative genetics using the sommer package","text":"partitioned model popularized () show marker effects can obtained fitting GBLUP model reduce computational burden recover creating special matrices MM’ GBLUP M’(M’M)- recover marker effects. show easy example using DT_cpdata:  can seen, two models equivalent exception partitioned model computationally efficient.","code":"library(sommer) data(\"DT_cpdata\") DT <- DT_cpdata M <- GT_cpdata  ################ # MARKER MODEL ################ mix.marker <- mmer(color~1,                    random=~Rowf+vsr(M),                    rcov=~units,data=DT,                     verbose = FALSE)   me.marker <- mix.marker$U$`u:M`$color  ################ # PARTITIONED GBLUP MODEL ################  MMT <-tcrossprod(M) ## MM' = additive relationship matrix  MMTinv<-solve(MMT) ## inverse MTMMTinv<-t(M)%*%MMTinv # M' %*% (M'M)-  mix.part <- mmer(color~1,                  random=~Rowf+vsr(id, Gu=MMT),                  rcov=~units,data=DT,                  verbose = FALSE)  #convert BLUPs to marker effects me=M'(M'M)- u me.part<-MTMMTinv%*%matrix(mix.part$U$`u:id`$color,ncol=1)  # compare marker effects between both models plot(me.marker,me.part)"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"udu-decomposition","dir":"Articles","previous_headings":"SECTION 3: Special topics in Quantitative genetics","what":"2) UDU’ decomposition","title":"Quantitative genetics using the sommer package","text":"Lee Van der Warf (2015) proposed decomposition relationship matrix =UDU’ together transformation response fixed effects Uy = Ux + UZ + e, fit model phenotypic variance matrix V diagonal relationship matrix diagonal matrix D decomposition can inverted easily make multitrait models feasible. can seen, two models equivalent. Despite fact sommer doesn’t take great advantage trick built dense matrices using Armadillo library. software may better using trick.","code":"# data(\"DT_wheat\") # rownames(GT_wheat) <- rownames(DT_wheat) # G <- A.mat(GT_wheat) # Y <- data.frame(DT_wheat) #  # # make the decomposition # UD<-eigen(G) # get the decomposition: G = UDU' # U<-UD$vectors # D<-diag(UD$values)# This will be our new 'relationship-matrix' # rownames(D) <- colnames(D) <- rownames(G) # X<-model.matrix(~1, data=Y) # here: only one fixed effect (intercept) # UX<-t(U)%*%X # premultiply X and y by U'  # UY <- t(U) %*% as.matrix(Y) # multivariate #  # # dataset for decomposed model # DTd<-data.frame(id = rownames(G) ,UY, UX =UX[,1]) # DTd$id<-as.character(DTd$id) #  # modeld <- mmer(cbind(X1,X2) ~ UX - 1,  #               random = ~vsr(id,Gu=D),  #               rcov = ~vsr(units), #               data=DTd, verbose = FALSE) #  # # dataset for normal model # DTn<-data.frame(id = rownames(G) , DT_wheat) # DTn$id<-as.character(DTn$id) #  # modeln <- mmer(cbind(X1,X2) ~ 1,  #               random = ~vsr(id,Gu=G),  #               rcov = ~vsr(units), #               data=DTn, verbose = FALSE) #  # ## compare regular and transformed blups # plot(x=(solve(t(U)))%*%modeld$U$`u:id`$X2[colnames(D)],  #      y=modeln$U$`u:id`$X2[colnames(D)], xlab=\"UDU blup\", #      ylab=\"blup\")"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"mating-designs","dir":"Articles","previous_headings":"SECTION 3: Special topics in Quantitative genetics","what":"3) Mating designs","title":"Quantitative genetics using the sommer package","text":"Estimating variance components topic interest breeding community long time. show calculate additive dominance variance using North Carolina Design (Nested design) North Carolina Design II (Factorial design) using classical Expected Mean Squares method REML methods sommer two equivalent.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"north-carolina-design-i-nested-design","dir":"Articles","previous_headings":"SECTION 3: Special topics in Quantitative genetics > 3) Mating designs","what":"North Carolina Design I (Nested design)","title":"Quantitative genetics using the sommer package","text":"can seen REML method easier manipulating MS arrive results.","code":"data(DT_expdesigns) DT <- DT_expdesigns$car1 DT <- aggregate(yield~set+male+female+rep, data=DT, FUN = mean) DT$setf <- as.factor(DT$set) DT$repf <- as.factor(DT$rep) DT$malef <- as.factor(DT$male) DT$femalef <- as.factor(DT$female) #levelplot(yield~male*female|set, data=DT, main=\"NC design I\") ############################## ## Expected Mean Square method ############################## mix1 <- lm(yield~ setf + setf:repf + femalef:malef:setf + malef:setf, data=DT) MS <- anova(mix1); MS ## Analysis of Variance Table ##  ## Response: yield ##                    Df Sum Sq Mean Sq F value   Pr(>F)     ## setf                1 0.1780 0.17796  1.6646 0.226012     ## setf:repf           2 0.9965 0.49824  4.6605 0.037141 *   ## setf:malef          4 7.3904 1.84759 17.2822 0.000173 *** ## setf:femalef:malef  6 1.6083 0.26806  2.5074 0.095575 .   ## Residuals          10 1.0691 0.10691                      ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ms1 <- MS[\"setf:malef\",\"Mean Sq\"] ms2 <- MS[\"setf:femalef:malef\",\"Mean Sq\"] mse <- MS[\"Residuals\",\"Mean Sq\"] nrep=2 nfem=2 Vfm <- (ms2-mse)/nrep Vm <- (ms1-ms2)/(nrep*nfem)  ## Calculate Va and Vd Va=4*Vm # assuming no inbreeding (4/(1+F)) Vd=4*(Vfm-Vm) # assuming no inbreeding(4/(1+F)^2) Vg=c(Va,Vd); names(Vg) <- c(\"Va\",\"Vd\"); Vg ##        Va        Vd  ##  1.579537 -1.257241 ############################## ## REML method ############################## mix2 <- mmer(yield~ setf + setf:repf,             random=~femalef:malef:setf + malef:setf, nIters=3,             data=DT, verbose = FALSE) vc <- summary(mix2)$varcomp; vc ##                                  VarComp  VarCompSE   Zratio Constraint ## femalef:malef:setf.yield-yield 0.0795986 0.07959526 1.000042   Positive ## malef:setf.yield-yield         0.3875096 0.27561291 1.405992   Positive ## units.yield-yield              0.1080557 0.05294578 2.040875   Positive Vfm <- vc[1,\"VarComp\"] Vm <- vc[2,\"VarComp\"]  ## Calculate Va and Vd Va=4*Vm # assuming no inbreeding (4/(1+F)) Vd=4*(Vfm-Vm) # assuming no inbreeding(4/(1+F)^2) Vg=c(Va,Vd); names(Vg) <- c(\"Va\",\"Vd\"); Vg ##        Va        Vd  ##  1.550038 -1.231644"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"north-carolina-design-ii-factorial-design","dir":"Articles","previous_headings":"SECTION 3: Special topics in Quantitative genetics > 3) Mating designs","what":"North Carolina Design II (Factorial design)","title":"Quantitative genetics using the sommer package","text":"can seen, REML method easier manipulating MS arrive results.","code":"DT <- DT_expdesigns$car2 DT <- aggregate(yield~set+male+female+rep, data=DT, FUN = mean) DT$setf <- as.factor(DT$set) DT$repf <- as.factor(DT$rep) DT$malef <- as.factor(DT$male) DT$femalef <- as.factor(DT$female) #levelplot(yield~male*female|set, data=DT, main=\"NC desing II\") head(DT) ##   set male female rep   yield setf repf malef femalef ## 1   1    1      1   1  831.03    1    1     1       1 ## 2   1    2      1   1 1046.55    1    1     2       1 ## 3   1    3      1   1  853.33    1    1     3       1 ## 4   1    4      1   1  940.00    1    1     4       1 ## 5   1    5      1   1  802.00    1    1     5       1 ## 6   1    1      2   1  625.93    1    1     1       2 N=with(DT,table(female, male, set)) nmale=length(which(N[1,,1] > 0)) nfemale=length(which(N[,1,1] > 0)) nrep=table(N[,,1]) nrep=as.numeric(names(nrep[which(names(nrep) !=0)]))  ############################## ## Expected Mean Square method ##############################  mix1 <- lm(yield~ setf + setf:repf +               femalef:malef:setf + malef:setf + femalef:setf, data=DT) MS <- anova(mix1); MS ## Analysis of Variance Table ##  ## Response: yield ##                    Df  Sum Sq Mean Sq F value    Pr(>F)     ## setf                1  847836  847836 45.6296 1.097e-09 *** ## setf:repf           4  144345   36086  1.9421  0.109652     ## setf:malef          8  861053  107632  5.7926 5.032e-06 *** ## setf:femalef        8  527023   65878  3.5455  0.001227 **  ## setf:femalef:malef 32  807267   25227  1.3577  0.129527     ## Residuals          96 1783762   18581                       ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ms1 <- MS[\"setf:malef\",\"Mean Sq\"] ms2 <- MS[\"setf:femalef\",\"Mean Sq\"] ms3 <- MS[\"setf:femalef:malef\",\"Mean Sq\"] mse <- MS[\"Residuals\",\"Mean Sq\"] nrep=length(unique(DT$rep)) nfem=length(unique(DT$female)) nmal=length(unique(DT$male)) Vfm <- (ms3-mse)/nrep;  Vf <- (ms2-ms3)/(nrep*nmale);  Vm <- (ms1-ms3)/(nrep*nfemale);   Va=4*Vm; # assuming no inbreeding (4/(1+F)) Va=4*Vf; # assuming no inbreeding (4/(1+F)) Vd=4*(Vfm); # assuming no inbreeding(4/(1+F)^2) Vg=c(Va,Vd); names(Vg) <- c(\"Va\",\"Vd\"); Vg ##        Va        Vd  ## 10840.192  8861.659 ############################## ## REML method ##############################  mix2 <- mmer(yield~ setf + setf:repf ,             random=~femalef:malef:setf + malef:setf + femalef:setf,              nIters=3,             data=DT, verbose = FALSE) vc <- summary(mix2)$varcomp; vc ##                                  VarComp VarCompSE    Zratio Constraint ## femalef:malef:setf.yield-yield  2235.754  2320.298 0.9635634   Positive ## malef:setf.yield-yield          5464.494  3484.990 1.5680085   Positive ## femalef:setf.yield-yield        2722.922  2316.795 1.1752969   Positive ## units.yield-yield              18569.305  2665.240 6.9672171   Positive Vfm <- vc[1,\"VarComp\"] Vm <- vc[2,\"VarComp\"] Vf <- vc[3,\"VarComp\"]  Va=4*Vm; # assuming no inbreeding (4/(1+F)) Va=4*Vf; # assuming no inbreeding (4/(1+F)) Vd=4*(Vfm); # assuming no inbreeding(4/(1+F)^2) Vg=c(Va,Vd); names(Vg) <- c(\"Va\",\"Vd\"); Vg ##        Va        Vd  ## 10891.689  8943.017"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"gwas-by-gblup","dir":"Articles","previous_headings":"SECTION 3: Special topics in Quantitative genetics","what":"4) GWAS by GBLUP","title":"Quantitative genetics using the sommer package","text":"Gualdron-Duarte et al. (2014) Bernal-Rubio et al. (2016) proved (SingleStep)GBLUP RRBLUP/SNP-BLUP, dividing estimate marker effect standard error mathematically equivalent fixed regression EMMAX GWAS, even markers estimated random effects GBLUP fixed effects EMMAX. way fitting GBLUP model enough perform GWAS additive -additive effects. Let us use DT_cpdata dataset explore GWAS GBLUP method First fit regular GWAS/EMMAX using GWAS function available sommer first calculates variance components fits regression marker marker fixed effect. compare EMMAX approach proposed Gualdron-Duarte et al. (2014) Bernal-Rubio et al. (2016) start fitting RRBLUP/SNP-BLUP model show estimate marker effect standard error mathematically equivalent fixed regression EMMAX GWAS. Instead fitting RRBLUP/SNP-BLUP model can fit GBLUP model less computationally demanding recover marker effects standard errors genotype effects. Now can look p-values coming 3 approaches indeed show results equivalent.","code":"data(DT_cpdata) DT <- DT_cpdata GT <- GT_cpdata[,1:200] MP <- MP_cpdata #### create the variance-covariance matrix A <- A.mat(GT) # additive relationship matrix n <- nrow(DT) # to be used for degrees of freedom k <- 1 # to be used for degrees of freedom (number of levels in fixed effects) ########################### #### Regular GWAS/EMMAX approach ########################### mix2 <- GWAS(color~1,              random=~vsr(id, Gu=A) + Rowf + Colf,              rcov=~units, M=GT, gTerm = \"u:id\",              verbose = FALSE, nIters=3,              data=DT) ## Performing GWAS evaluation ## ########################### #### GWAS by RRBLUP approach ########################### Z <- GT[as.character(DT$id),] mixRRBLUP <- mmer(color~1,               random=~vsr(Z) + Rowf + Colf,               rcov=~units, nIters=3,               verbose = FALSE,               data=DT)  a <- mixRRBLUP$U$`u:Z`$color # marker effects se.a <- sqrt(diag(kronecker(diag(ncol(Z)),mixRRBLUP$sigma$`u:Z`) - mixRRBLUP$PevU$`u:Z`$color)) # SE of marker effects t.stat <- a/se.a # t-statistic pvalRRBLUP <- dt(t.stat,df=n-k-1) # -log10(pval) ########################### #### GWAS by GBLUP approach ########################### M<- GT MMT <-tcrossprod(M) ## MM' = additive relationship matrix MMTinv<-solve(MMT + diag(1e-6, ncol(MMT), ncol(MMT))) ## inverse of MM' MTMMTinv<-t(M)%*%MMTinv # M' %*% (M'M)- mixGBLUP <- mmer(color~1,              random=~vsr(id, Gu=MMT) + Rowf + Colf,              rcov=~units, nIters=3,              verbose = FALSE,              data=DT) a.from.g <-MTMMTinv%*%matrix(mixGBLUP$U$`u:id`$color,ncol=1) var.g <- kronecker(MMT,mixGBLUP$sigma$`u:id`) - mixGBLUP$PevU$`u:id`$color var.a.from.g <- t(M)%*%MMTinv%*% (var.g) %*% t(MMTinv)%*%M se.a.from.g <- sqrt(diag(var.a.from.g)) t.stat.from.g <- a.from.g/se.a.from.g # t-statistic pvalGBLUP <- dt(t.stat.from.g,df=n-k-1) # -log10(pval) ########################### #### Compare results ########################### # plot(mix2$scores[,1], main=\"GWAS\") plot(-log(pvalRRBLUP), main=\"GWAS by RRBLUP/SNP-BLUP\") plot(-log(pvalGBLUP), main=\"GWAS by GBLUP\")"},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"final-remarks","dir":"Articles","previous_headings":"SECTION 3: Special topics in Quantitative genetics","what":"Final remarks","title":"Quantitative genetics using the sommer package","text":"Keep mind mmer uses direct inversion (DI) algorithm can slow large datasets many records. datasets records coefficients estimated please shift use mmec function.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v3.sommer.qg.html","id":"literature","dir":"Articles","previous_headings":"","what":"Literature","title":"Quantitative genetics using the sommer package","text":"Covarrubias-Pazaran G. 2016. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6):1-15. Covarrubias-Pazaran G. 2018. Software update: Moving R package sommer multivariate mixed models genome-assisted prediction. doi: https://doi.org/10.1101/354639 Bernardo Rex. 2010. Breeding quantitative traits plants. Second edition. Stemma Press. 390 pp. Gilmour et al. 1995. Average Information REML: efficient algorithm variance parameter estimation linear mixed models. Biometrics 51(4):1440-1450. Henderson C.R. 1975. Best Linear Unbiased Estimation Prediction Selection Model. Biometrics vol. 31(2):423-447. Kang et al. 2008. Efficient control population structure model organism association mapping. Genetics 178:1709-1723. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Lee et al. 2015. MTG2: efficient algorithm multivariate linear mixed model analysis based genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201. Maier et al. 2015. Joint analysis psychiatric disorders increases accuracy risk prediction schizophrenia, bipolar disorder, major depressive disorder. J Hum Genet; 96(2):283-294. Rodriguez-Alvarez, Maria Xose, et al. Correcting spatial heterogeneity plant breeding experiments P-splines. Spatial Statistics 23 (2018): 52-71. Searle. 1993. Applying EM algorithm calculating ML REML estimates variance components. Paper invited 1993 American Statistical Association Meeting, San Francisco. Yu et al. 2006. unified mixed-model method association mapping accounts multiple levels relatedness. Genetics 38:203-208. Tunnicliffe W. 1989. use marginal likelihood time series model estimation. JRSS 51(1):15-27.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"single-environment-model","dir":"Articles","previous_headings":"","what":"1) Single environment model","title":"Fitting genotype by environment models in sommer","text":"single-environment model one fitted breeding program can afford one location, leaving possible information available environments. used expand GxE models. model, term estimated one germplasm (called Name). sake example added relationship matrix among levels random effect Name. just diagonal matrix many rows columns levels present random effect Name, non-diagonal relationship matrix used.","code":"library(sommer) ## Loading required package: Matrix ## Loading required package: MASS ## Loading required package: crayon data(DT_example) DT <- DT_example A <- A_example  ansSingle <- mmer(Yield~1,               random= ~ vsr(Name, Gu=A),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansSingle) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -78.80875 159.6175 162.8378     NR     TRUE ## ============================================================ ## Variance-Covariance components: ##                    VarComp VarCompSE Zratio Constraint ## u:Name.Yield-Yield   6.529     2.202  2.965   Positive ## units.Yield-Yield   13.868     1.633  8.494   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)    11.74    0.4876   24.07 ## ============================================================ ## Groups and observations: ##        Yield ## u:Name    41 ## ============================================================ ## Use the '$' sign to access results and parameters # or Ai <- as(solve(A), Class=\"dgCMatrix\") ansSingle <- mmec(Yield~1,               random= ~ vsc(isc(Name), Gu=Ai),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansSingle) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -359.0031 720.0062 723.2266     AI     TRUE ## ============================================================ ## Variance-Covariance components: ##                 VarComp VarCompSE Zratio Constraint ## Name:Ai:isc:isc   6.495     1.479  4.392   Positive ## units:isc:isc    13.869     1.799  7.711   Positive ## ============================================================ ## Fixed effects: ##             Estimate Std.Error t.value ## (Intercept)    11.74    0.4861   24.15 ## ============================================================ ## Use the '$' sign to access results and parameters"},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"met-main-effect-model","dir":"Articles","previous_headings":"","what":"2) MET: main effect model","title":"Fitting genotype by environment models in sommer","text":"multi-environment model one fitted breeding program can afford one location. main effect model assumes GxE doesn’t exist main genotype effect plus fixed effect environment enough predict genotype effect locations interest.","code":"ansMain <- mmer(Yield~Env,               random= ~ vsr(Name, Gu=A),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansMain) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -32.59421 71.18842 80.84949     NR     TRUE ## ============================================================ ## Variance-Covariance components: ##                    VarComp VarCompSE Zratio Constraint ## u:Name.Yield-Yield   4.856    1.5233  3.188   Positive ## units.Yield-Yield    8.109    0.9615  8.434   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)   16.385    0.5849  28.012 ## 2 Yield  EnvCA.2012   -5.688    0.5741  -9.908 ## 3 Yield  EnvCA.2013   -6.218    0.6107 -10.182 ## ============================================================ ## Groups and observations: ##        Yield ## u:Name    41 ## ============================================================ ## Use the '$' sign to access results and parameters # or   Ai <- as(solve(A), Class=\"dgCMatrix\") ansMain <- mmec(Yield~Env,               random= ~ vsc(isc(Name), Gu=Ai),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansMain) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -313.3005 632.6011 642.2621     AI     TRUE ## ============================================================ ## Variance-Covariance components: ##                 VarComp VarCompSE Zratio Constraint ## Name:Ai:isc:isc   4.854     1.449  3.350   Positive ## units:isc:isc     8.109     1.807  4.486   Positive ## ============================================================ ## Fixed effects: ##           Estimate Std.Error t.value ## Intercept   16.385    0.5847  28.021 ## CA.2012     -5.688    0.5741  -9.909 ## CA.2013     -6.219    0.6107 -10.183 ## ============================================================ ## Use the '$' sign to access results and parameters"},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"met-diagonal-model-dg","dir":"Articles","previous_headings":"","what":"3) MET: diagonal model (DG)","title":"Fitting genotype by environment models in sommer","text":"multi-environment model one fitted breeding program can afford one location. diagonal model assumes GxE exists genotype variation expressed differently location, therefore fitting variance component genotype effect location. main drawback model assumes covariance among locations, genotypes independent (despite fact genotypes). fixed effect environment plus location-specific BLUP used predict genotype effect locations interest.","code":"ansDG <- mmer(Yield~Env,               random= ~ vsr(dsr(Env),Name, Gu=A),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansDG) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -21.04157 48.08315 57.74421     NR     TRUE ## ============================================================ ## Variance-Covariance components: ##                          VarComp VarCompSE Zratio Constraint ## CA.2011:Name.Yield-Yield  17.493    6.1099  2.863   Positive ## CA.2012:Name.Yield-Yield   5.337    1.7662  3.022   Positive ## CA.2013:Name.Yield-Yield   7.884    2.5526  3.089   Positive ## units.Yield-Yield          4.381    0.6493  6.747   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)   16.621     0.948  17.532 ## 2 Yield  EnvCA.2012   -5.958     1.045  -5.699 ## 3 Yield  EnvCA.2013   -6.662     1.098  -6.067 ## ============================================================ ## Groups and observations: ##              Yield ## CA.2011:Name    41 ## CA.2012:Name    41 ## CA.2013:Name    41 ## ============================================================ ## Use the '$' sign to access results and parameters # or Ai <- as(solve(A), Class=\"dgCMatrix\") ansDG <- mmec(Yield~Env,               random= ~ vsc(dsc(Env),isc(Name), Gu=Ai),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansDG) ## ============================================================= ##           Multivariate Linear Mixed Model fit by REML           ## **********************  sommer 4.3  **********************  ## ============================================================= ##          logLik      AIC      BIC Method Converge ## Value -301.7528 609.5057 619.1668     AI     TRUE ## ============================================================= ## Variance-Covariance components: ##                             VarComp VarCompSE Zratio Constraint ## Env:Name:Ai:CA.2011:CA.2011  17.124     3.479  4.922   Positive ## Env:Name:Ai:CA.2012:CA.2012   5.351     2.814  1.901   Positive ## Env:Name:Ai:CA.2013:CA.2013   7.904     2.924  2.703   Positive ## units:isc:isc                 4.332     2.258  1.919   Positive ## ============================================================= ## Fixed effects: ##           Estimate Std.Error t.value ## Intercept   16.621    0.9386  17.709 ## CA.2012     -5.958    1.0367  -5.747 ## CA.2013     -6.662    1.0898  -6.113 ## ============================================================= ## Use the '$' sign to access results and parameters"},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"met-compund-symmetry-model-cs","dir":"Articles","previous_headings":"","what":"4) MET: compund symmetry model (CS)","title":"Fitting genotype by environment models in sommer","text":"multi-environment model one fitted breeding program can afford one location. compound symmetry model assumes GxE exists main genotype variance-covariance component expressed across location. addition, assumes main genotype--environment variance expressed across locations. main drawback model assumes variance covariance among locations. fixed effect environment plus main effect BLUP plus genotype--environment effect used predict genotype effect location interest.","code":"E <- diag(length(unique(DT$Env))) rownames(E) <- colnames(E) <- unique(DT$Env) EA <- kronecker(E,A, make.dimnames = TRUE) ansCS <- mmer(Yield~Env,               random= ~ vsr(Name, Gu=A) + vsr(Env:Name, Gu=EA),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansCS) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -20.14538 46.29075 55.95182     NR     TRUE ## ============================================================ ## Variance-Covariance components: ##                        VarComp VarCompSE Zratio Constraint ## u:Name.Yield-Yield       3.682     1.691  2.177   Positive ## u:Env:Name.Yield-Yield   5.173     1.495  3.460   Positive ## units.Yield-Yield        4.366     0.647  6.748   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)   16.496    0.6855  24.065 ## 2 Yield  EnvCA.2012   -5.777    0.7558  -7.643 ## 3 Yield  EnvCA.2013   -6.380    0.7960  -8.015 ## ============================================================ ## Groups and observations: ##            Yield ## u:Name        41 ## u:Env:Name   123 ## ============================================================ ## Use the '$' sign to access results and parameters ## or E <- diag(length(unique(DT$Env)));rownames(E) <- colnames(E) <- unique(DT$Env) Ei <- solve(E) Ai <- solve(A) EAi <- kronecker(Ei,Ai, make.dimnames = TRUE) Ei <- as(Ei, Class=\"dgCMatrix\") Ai <- as(Ai, Class=\"dgCMatrix\") EAi <- as(EAi, Class=\"dgCMatrix\") ansCS <- mmec(Yield~Env,               random= ~ vsc(isc(Name), Gu=Ai) + vsc(isc(Env:Name), Gu=EAi),               rcov= ~ units,                data=DT, verbose = FALSE) summary(ansCS) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -300.8517 607.7034 617.3645     AI     TRUE ## ============================================================ ## Variance-Covariance components: ##                      VarComp VarCompSE Zratio Constraint ## Name:Ai:isc:isc        3.683     1.881  1.958   Positive ## Env:Name:EAi:isc:isc   5.174     2.420  2.138   Positive ## units:isc:isc          4.360     2.270  1.920   Positive ## ============================================================ ## Fixed effects: ##           Estimate Std.Error t.value ## Intercept   16.496    0.6856  24.062 ## CA.2012     -5.777    0.7558  -7.643 ## CA.2013     -6.380    0.7960  -8.015 ## ============================================================ ## Use the '$' sign to access results and parameters"},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"met-unstructured-model-us","dir":"Articles","previous_headings":"","what":"5) MET: unstructured model (US)","title":"Fitting genotype by environment models in sommer","text":"multi-environment model one fitted breeding program can afford one location. unstructured model flexible model assuming GxE exists environment-specific variance exists addition many covariances environment--environment combinations. main drawback difficult make models converge large number variance components, fact variance covariance components zero, difficulty choosing good starting values. fixed effect environment plus environment specific BLUP (adjusted covariances) used predict genotype effect location interest.","code":"ansUS <- mmer(Yield~Env,               random= ~ vsr(usr(Env),Name, Gu=A),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansUS) ## ================================================================== ##             Multivariate Linear Mixed Model fit by REML             ## *************************  sommer 4.3  *************************  ## ================================================================== ##          logLik      AIC      BIC Method Converge ## Value -14.20951 34.41901 44.08008     NR     TRUE ## ================================================================== ## Variance-Covariance components: ##                                  VarComp VarCompSE Zratio Constraint ## CA.2011:Name.Yield-Yield          15.994     5.381  2.972   Positive ## CA.2012:CA.2011:Name.Yield-Yield   6.172     2.503  2.465   Unconstr ## CA.2012:Name.Yield-Yield           5.273     1.750  3.013   Positive ## CA.2013:CA.2011:Name.Yield-Yield   6.366     3.069  2.074   Unconstr ## CA.2013:CA.2012:Name.Yield-Yield   0.376     1.535  0.245   Unconstr ## CA.2013:Name.Yield-Yield           7.689     2.490  3.088   Positive ## units.Yield-Yield                  4.386     0.650  6.748   Positive ## ================================================================== ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)   16.341    0.8141  20.072 ## 2 Yield  EnvCA.2012   -5.696    0.7406  -7.692 ## 3 Yield  EnvCA.2013   -6.286    0.8202  -7.664 ## ================================================================== ## Groups and observations: ##                      Yield ## CA.2011:Name            41 ## CA.2012:CA.2011:Name    82 ## CA.2012:Name            41 ## CA.2013:CA.2011:Name    82 ## CA.2013:CA.2012:Name    82 ## CA.2013:Name            41 ## ================================================================== ## Use the '$' sign to access results and parameters # adjust variance BLUPs by adding covariances # ansUS$U[1:6] <- unsBLUP(ansUS$U[1:6])  # or Ai <- solve(A) Ai <- as(Ai, Class=\"dgCMatrix\") ansUS <- mmec(Yield~Env,               random= ~ vsc(usc(Env),isc(Name), Gu=Ai),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansUS) ## ============================================================= ##           Multivariate Linear Mixed Model fit by REML           ## **********************  sommer 4.3  **********************  ## ============================================================= ##          logLik      AIC     BIC Method Converge ## Value -295.2125 596.4249 606.086     AI     TRUE ## ============================================================= ## Variance-Covariance components: ##                             VarComp VarCompSE Zratio Constraint ## Env:Name:Ai:CA.2011:CA.2011 14.8143     3.513 4.2167   Positive ## Env:Name:Ai:CA.2011:CA.2012  5.7221     1.957 2.9241   Unconstr ## Env:Name:Ai:CA.2012:CA.2012  4.9599     2.263 2.1913   Positive ## Env:Name:Ai:CA.2011:CA.2013  6.1289     2.726 2.2481   Unconstr ## Env:Name:Ai:CA.2012:CA.2013  0.6439     1.899 0.3391   Unconstr ## Env:Name:Ai:CA.2013:CA.2013  7.5772     2.905 2.6084   Positive ## units:isc:isc                4.0134     2.171 1.8483   Positive ## ============================================================= ## Fixed effects: ##           Estimate Std.Error t.value ## Intercept   16.344    0.7847  20.828 ## CA.2012     -5.693    0.7150  -7.963 ## CA.2013     -6.277    0.7918  -7.927 ## ============================================================= ## Use the '$' sign to access results and parameters"},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"met-random-regression-model","dir":"Articles","previous_headings":"","what":"6) MET: random regression model","title":"Fitting genotype by environment models in sommer","text":"multi-environment model one fitted breeding program can afford one location. random regression model assumes environment can seen continuous variable therefore variance component intercept variance component slope can fitted. number variance components depend order Legendre polynomial fitted. addition, unstructured, diagonal variance-covariance structure can put top polynomial model:","code":"library(orthopolynom) DT$EnvN <- as.numeric(as.factor(DT$Env)) ansRR <- mmer(Yield~Env,               random= ~ vsr(leg(EnvN,1),Name),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansRR) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -27.70318 61.40636 71.06743     NR     TRUE ## ============================================================ ## Variance-Covariance components: ##                       VarComp VarCompSE Zratio Constraint ## leg0:Name.Yield-Yield  10.392    3.1473  3.302   Positive ## leg1:Name.Yield-Yield   2.079    0.9792  2.123   Positive ## units.Yield-Yield       6.297    0.8442  7.459   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)   16.541    0.6770  24.432 ## 2 Yield  EnvCA.2012   -5.832    0.6425  -9.078 ## 3 Yield  EnvCA.2013   -6.472    0.8239  -7.854 ## ============================================================ ## Groups and observations: ##           Yield ## leg0:Name    41 ## leg1:Name    41 ## ============================================================ ## Use the '$' sign to access results and parameters # or  ansRR <- mmec(Yield~Env,               random= ~ vsc(dsc(leg(EnvN,1)),isc(Name)),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansRR) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -308.4098 622.8195 632.4806     AI     TRUE ## ============================================================ ## Variance-Covariance components: ##                     VarComp VarCompSE Zratio Constraint ## EnvN:Name:leg0:leg0  10.355     2.319  4.465   Positive ## EnvN:Name:leg1:leg1   2.079     1.759  1.182   Positive ## units:isc:isc         6.304     2.005  3.145   Positive ## ============================================================ ## Fixed effects: ##           Estimate Std.Error t.value ## Intercept   16.541    0.6761  24.467 ## CA.2012     -5.833    0.6421  -9.084 ## CA.2013     -6.472    0.8233  -7.861 ## ============================================================ ## Use the '$' sign to access results and parameters library(orthopolynom) DT$EnvN <- as.numeric(as.factor(DT$Env)) ansRR <- mmer(Yield~Env,               random= ~ vsr(usr(leg(EnvN,1)),Name),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansRR) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -25.56967 57.13935 66.80042     NR     TRUE ## ============================================================ ## Variance-Covariance components: ##                            VarComp VarCompSE Zratio Constraint ## leg0:Name.Yield-Yield       10.791    3.2745  3.295   Positive ## leg1:leg0:Name.Yield-Yield  -2.428    1.3699 -1.772   Unconstr ## leg1:Name.Yield-Yield        2.286    1.0404  2.197   Positive ## units.Yield-Yield            6.260    0.8421  7.434   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)   16.501    0.7778  21.216 ## 2 Yield  EnvCA.2012   -5.791    0.6704  -8.638 ## 3 Yield  EnvCA.2013   -6.476    0.8554  -7.570 ## ============================================================ ## Groups and observations: ##                Yield ## leg0:Name         41 ## leg1:leg0:Name    82 ## leg1:Name         41 ## ============================================================ ## Use the '$' sign to access results and parameters # or  ansRR <- mmec(Yield~Env,               random= ~ vsc(usc(leg(EnvN,1)),isc(Name)),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansRR) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC      BIC Method Converge ## Value -308.7042 623.4085 633.0695     AI     TRUE ## ============================================================ ## Variance-Covariance components: ##                     VarComp VarCompSE  Zratio Constraint ## EnvN:Name:leg0:leg0 10.6512     2.242 4.75048   Positive ## EnvN:Name:leg0:leg1  0.1204     1.445 0.08328   Unconstr ## EnvN:Name:leg1:leg1  2.0947     1.920 1.09114   Positive ## units:isc:isc        6.6403     2.042 3.25168   Positive ## ============================================================ ## Fixed effects: ##           Estimate Std.Error t.value ## Intercept   16.541    0.6826  24.234 ## CA.2012     -5.833    0.6533  -8.929 ## CA.2013     -6.469    0.8349  -7.748 ## ============================================================ ## Use the '$' sign to access results and parameters"},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"other-gxe-covariance-structures","dir":"Articles","previous_headings":"","what":"7) Other GxE covariance structures","title":"Fitting genotype by environment models in sommer","text":"Although commonly used GxE models, autoregressive order 1 (AR1) covariance structures used GxE modeling. show (recommending ).","code":"E <- AR1(DT$Env) # can be AR1() or CS(), etc. rownames(E) <- colnames(E) <- unique(DT$Env) EA <- kronecker(E,A, make.dimnames = TRUE) ansCS <- mmer(Yield~Env,               random= ~ vsr(Name, Gu=A) + vsr(Env:Name, Gu=EA),               rcov= ~ units,               data=DT, verbose = FALSE) summary(ansCS) ## ============================================================ ##          Multivariate Linear Mixed Model fit by REML          ## **********************  sommer 4.3  **********************  ## ============================================================ ##          logLik      AIC     BIC Method Converge ## Value -19.39067 44.78134 54.4424     NR     TRUE ## ============================================================ ## Variance-Covariance components: ##                        VarComp VarCompSE Zratio Constraint ## u:Name.Yield-Yield       2.225    1.7536  1.269   Positive ## u:Env:Name.Yield-Yield   6.424    1.8293  3.512   Positive ## units.Yield-Yield        4.334    0.6418  6.752   Positive ## ============================================================ ## Fixed effects: ##   Trait      Effect Estimate Std.Error t.value ## 1 Yield (Intercept)   16.484    0.6735  24.474 ## 2 Yield  EnvCA.2012   -5.780    0.7365  -7.848 ## 3 Yield  EnvCA.2013   -6.372    0.7799  -8.170 ## ============================================================ ## Groups and observations: ##            Yield ## u:Name        41 ## u:Env:Name   123 ## ============================================================ ## Use the '$' sign to access results and parameters"},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"finlay-wilkinson-regression","dir":"Articles","previous_headings":"","what":"8) Finlay-Wilkinson regression","title":"Fitting genotype by environment models in sommer","text":"","code":"data(DT_h2) DT <- DT_h2  ## build the environmental index ei <- aggregate(y~Env, data=DT,FUN=mean) colnames(ei)[2] <- \"envIndex\" ei$envIndex <- ei$envIndex - mean(ei$envIndex,na.rm=TRUE) # center the envIndex to have clean VCs ei <- ei[with(ei, order(envIndex)), ]  ## add the environmental index to the original dataset DT2 <- merge(DT,ei, by=\"Env\")  # numeric by factor variables like envIndex:Name can't be used in the random part like this # they need to come with the vsc() structure DT2 <- DT2[with(DT2, order(Name)), ] mix2 <- mmec(y~ envIndex,              random=~ Name + vsc(dsc(envIndex),isc(Name)), data=DT2,              rcov=~vsc(dsc(Name),isc(units)),              tolParConvNorm = .0001,              nIters = 50, verbose = FALSE ) ## 'as(<dgeMatrix>, \"dgCMatrix\")' is deprecated. ## Use 'as(., \"CsparseMatrix\")' instead. ## See help(\"Deprecated\") and help(\"Matrix-deprecated\"). # summary(mix2)$varcomp  b=mix2$uList$`vsc(dsc(envIndex), isc(Name))` # adaptability (b) or genotype slopes mu=mix2$uList$`vsc( isc( Name ) )` # general adaptation (mu) or main effect e=sqrt(summary(mix2)$varcomp[-c(1:2),1]) # error variance for each individual  ## general adaptation (main effect) vs adaptability (response to better environments) plot(mu[,1]~b[,1], ylab=\"general adaptation\", xlab=\"adaptability\") text(y=mu[,1],x=b[,1], labels = rownames(mu), cex=0.5, pos = 1) ## prediction across environments Dt <- mix2$Dtable Dt[1,\"average\"]=TRUE Dt[2,\"include\"]=TRUE Dt[3,\"include\"]=TRUE pp <- predict(mix2,Dtable = Dt, D=\"Name\") preds <- pp$pvals # preds[with(preds, order(-predicted.value)), ] ## performance vs stability (deviation from regression line) plot(preds[,2]~e, ylab=\"performance\", xlab=\"stability\") text(y=preds[,2],x=e, labels = rownames(mu), cex=0.5, pos = 1)"},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"factor-analytic-reduced-rank-model","dir":"Articles","previous_headings":"","what":"9) Factor analytic (reduced rank) model","title":"Fitting genotype by environment models in sommer","text":"number environments genotypes evaluated big want consider genetic covariance environments location-specific variance components fit unstructured covariance model since number parameters big matrix can become non-full rank leading singularities. cases suggested dimensionality reduction technique. Among factor analytic structures proposed many research groups (Piepho, Smith, Cullis, Thompson, Meyer, etc.) way go. Sommer reduced-rank factor analytic implementation available rrc() function. show example fit model: can seen genotype BLUPs environments can recovered multiplying loadings (Gamma) factor scores. parsomonious way model unstructured covariance.","code":"data(DT_h2) DT <- DT_h2 DT=DT[with(DT, order(Env)), ] head(DT) ##          Name     Env Loc Year     Block  y ## 67   MSL007-B CA.2011  CA 2011 CA.2011.2  5 ## 105  MSL007-B CA.2011  CA 2011 CA.2011.1  6 ## 308  MSK061-4 CA.2011  CA 2011 CA.2011.2  9 ## 393  MSK061-4 CA.2011  CA 2011 CA.2011.1 10 ## 469 MSR169-8Y CA.2011  CA 2011 CA.2011.1 11 ## 471     NY148 CA.2011  CA 2011 CA.2011.1 11 indNames <- na.omit(unique(DT$Name)) A <- diag(length(indNames)) rownames(A) <- colnames(A) <- indNames  # fit diagonal model first to produce H matrix ansDG <- mmec(y~Env,               random=~ vsc(dsc(Env), isc(Name)),               rcov=~units, nIters = 100,               # we recommend giving more EM iterations at the beggining               emWeight = c(rep(1,10),logspace(10,1,.05), rep(.05,80)),               data=DT, verbose = FALSE)  H0 <- ansDG$uList$`vsc(dsc(Env), isc(Name))` # GxE table  # reduced rank model ansFA <- mmec(y~Env,               random=~vsc( usc(rrc(Env, H = H0, nPC = 3)) , isc(Name)) + # rr                 vsc(dsc(Env), isc(Name)), # diag               rcov=~units,               # we recommend giving more iterations to these models               nIters = 100, verbose = FALSE,               # we recommend giving more EM iterations at the beggining               emWeight = c(rep(1,10),logspace(10,1,.05), rep(.05,80)),               data=DT)  vcFA <- ansFA$theta[[1]] vcDG <- ansFA$theta[[2]]  loadings=with(DT, rrc(Env, nPC = 3, H = H0, returnGamma = TRUE) )$Gamma scores <- ansFA$uList[[1]]  vcUS <- loadings %*% vcFA %*% t(loadings) G <- vcUS + vcDG # colfunc <- colorRampPalette(c(\"steelblue4\",\"springgreen\",\"yellow\")) # hv <- heatmap(cov2cor(G), col = colfunc(100), symm = TRUE)  uFA <- scores %*% t(loadings) uDG <- ansFA$uList[[2]] u <- uFA + uDG"},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"two-stage-analysis","dir":"Articles","previous_headings":"","what":"10) Two stage analysis","title":"Fitting genotype by environment models in sommer","text":"common fit first model accounts variation random design elements, e.g., locations, years, blocks, fixed genotype effects obtain estimated marginal means (EMMs) best linear unbiased estimators (BLUEs) adjusted entry means. adjusted entry means used phenotype response variable GWAS genomic prediction studies.","code":"########## ## stage 1 ## use mmer for dense field trials ########## data(DT_h2) DT <- DT_h2 head(DT) ##                 Name     Env Loc Year     Block y ## 1            W8822-3 FL.2012  FL 2012 FL.2012.1 2 ## 2            W8867-7 FL.2012  FL 2012 FL.2012.2 2 ## 3           MSL007-B MO.2011  MO 2011 MO.2011.1 3 ## 4         CO00270-7W FL.2012  FL 2012 FL.2012.2 3 ## 5 Manistee(MSL292-A) FL.2013  FL 2013 FL.2013.2 3 ## 6           MSM246-B FL.2012  FL 2012 FL.2012.2 3 envs <- unique(DT$Env) BLUEL <- list() XtXL <- list() for(i in 1:length(envs)){   ans1 <- mmer(y~Name-1,                 random=~Block,                 verbose=FALSE,                 data=droplevels(DT[which(DT$Env == envs[i]),]                )   )   ans1$Beta$Env <- envs[i]      BLUEL[[i]] <- ans1$Beta   # to be comparable to 1/(se^2) = 1/PEV = 1/Ci = 1/[(X'X)inv]   XtXL[[i]] <- solve(ans1$VarBeta)  }  DT2 <- do.call(rbind, BLUEL) OM <- do.call(adiag1,XtXL)  ########## ## stage 2 ## use mmec for sparse equation ########## m <- matrix(1/var(DT2$Estimate, na.rm = TRUE)) ans2 <- mmec(Estimate~Env,              random=~Effect + Env:Effect,               rcov=~vsc(isc(units,thetaC = matrix(3), theta = m)),              W=OM,               verbose=FALSE,              data=DT2              ) ## Using the weights matrix summary(ans2)$varcomp ##                     VarComp VarCompSE    Zratio Constraint ## Effect:isc:isc     2.076920 0.5758219  3.606880   Positive ## Env:Effect:isc:isc 3.333792 0.1850479 18.015831   Positive ## units:m:           1.000000 0.1850479  5.404005      Fixed"},{"path":"https://github.com/covaruber/sommer/articles/v4.sommer.gxe.html","id":"literature","dir":"Articles","previous_headings":"","what":"Literature","title":"Fitting genotype by environment models in sommer","text":"Covarrubias-Pazaran G. 2016. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6):1-15. Covarrubias-Pazaran G. 2018. Software update: Moving R package sommer multivariate mixed models genome-assisted prediction. doi: https://doi.org/10.1101/354639 Bernardo Rex. 2010. Breeding quantitative traits plants. Second edition. Stemma Press. 390 pp. Gilmour et al. 1995. Average Information REML: efficient algorithm variance parameter estimation linear mixed models. Biometrics 51(4):1440-1450. Henderson C.R. 1975. Best Linear Unbiased Estimation Prediction Selection Model. Biometrics vol. 31(2):423-447. Kang et al. 2008. Efficient control population structure model organism association mapping. Genetics 178:1709-1723. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Lee et al. 2015. MTG2: efficient algorithm multivariate linear mixed model analysis based genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201. Maier et al. 2015. Joint analysis psychiatric disorders increases accuracy risk prediction schizophrenia, bipolar disorder, major depressive disorder. J Hum Genet; 96(2):283-294. Rodriguez-Alvarez, Maria Xose, et al. Correcting spatial heterogeneity plant breeding experiments P-splines. Spatial Statistics 23 (2018): 52-71. Searle. 1993. Applying EM algorithm calculating ML REML estimates variance components. Paper invited 1993 American Statistical Association Meeting, San Francisco. Yu et al. 2006. unified mixed-model method association mapping accounts multiple levels relatedness. Genetics 38:203-208. Tunnicliffe W. 1989. use marginal likelihood time series model estimation. JRSS 51(1):15-27.","code":""},{"path":"https://github.com/covaruber/sommer/articles/v5.sommer.vs.lme4.html","id":"random-slopes","dir":"Articles","previous_headings":"","what":"1) Random slopes","title":"Translating lme4 models to sommer","text":"simplest model people use random effect desired levels random effect considered intercept.","code":"# install.packages(\"lme4\") # library(lme4) library(sommer) ## Loading required package: Matrix ## Loading required package: MASS ## Loading required package: crayon data(DT_sleepstudy) DT <- DT_sleepstudy ########### ## lme4 ########### # fm1 <- lmer(Reaction ~ Days + (1 | Subject), data=DT) # summary(fm1) # or vc <- VarCorr(fm1); print(vc,comp=c(\"Variance\")) # Random effects: #  Groups   Name        Variance Std.Dev. #  Subject  (Intercept) 1378.2   37.12    #  Residual              960.5   30.99    # Number of obs: 180, groups:  Subject, 18 ########### ## sommer ########### fm2 <- mmer(Reaction ~ Days,             random= ~ Subject,              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp ##                             VarComp VarCompSE   Zratio Constraint ## Subject.Reaction-Reaction 1377.9758  505.0776 2.728246   Positive ## units.Reaction-Reaction    960.4705  107.0638 8.971013   Positive # fm2 <- mmec(Reaction ~ Days, #             random= ~ Subject,  #             data=DT, tolParInv = 1e-6, verbose = FALSE) # summary(fm2)$varcomp"},{"path":"https://github.com/covaruber/sommer/articles/v5.sommer.vs.lme4.html","id":"random-slopes-and-random-intercepts-without-correlation","dir":"Articles","previous_headings":"","what":"2) Random slopes and random intercepts (without correlation)","title":"Translating lme4 models to sommer","text":"model assume random effect different intercepts based levels another variable. addition || lme4 assumes slopes intercepts correlation. Notice Days numerical (factor) variable.","code":"########### ## lme4 ########### # fm1 <- lmer(Reaction ~ Days + (Days || Subject), data=DT) # summary(fm1) # or vc <- VarCorr(fm1); print(vc,comp=c(\"Variance\")) # Random effects: #  Groups    Name        Variance Std.Dev. #  Subject   (Intercept) 627.57   25.051   #  Subject.1 Days         35.86    5.988   #  Residual              653.58   25.565   # Number of obs: 180, groups:  Subject, 18 ########### ## sommer ########### fm2 <- mmer(Reaction ~ Days,             random= ~ Subject + vsr(Days, Subject),              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp ##                                  VarComp VarCompSE   Zratio Constraint ## Subject.Reaction-Reaction      627.54087 283.52939 2.213319   Positive ## Days:Subject.Reaction-Reaction  35.86008  14.53187 2.467686   Positive ## units.Reaction-Reaction        653.58305  76.72711 8.518281   Positive # fm2 <- mmec(Reaction ~ Days, #             random= ~ Subject + vsc(dsc(Days), isc(Subject)), #             data=DT, tolParInv = 1e-6, verbose = FALSE) # summary(fm2)$varcomp"},{"path":"https://github.com/covaruber/sommer/articles/v5.sommer.vs.lme4.html","id":"random-slopes-and-random-intercepts-with-correlation","dir":"Articles","previous_headings":"","what":"3) Random slopes and random intercepts (with correlation)","title":"Translating lme4 models to sommer","text":"model assume random effect different intercepts based levels another variable. addition single | lme4 assumes slopes intercepts correlation estimated. Notice last model require new function called covc() creates two random effects now encapsulated covc() instead just added.","code":"########### ## lme4 ########### # fm1 <- lmer(Reaction ~ Days + (Days | Subject), data=DT) # summary(fm1) # or # vc <- VarCorr(fm1); print(vc,comp=c(\"Variance\")) # Random effects: #  Groups   Name        Variance Std.Dev. Corr #  Subject  (Intercept) 612.10   24.741        #           Days         35.07    5.922   0.07 #  Residual             654.94   25.592        # Number of obs: 180, groups:  Subject, 18 ########### ## sommer ########### ## using mmec() the model would be fm2 <- mmec(Reaction ~ Days,             random= ~ covc( vsc(isc(Subject)) , vsc(isc(Days), isc(Subject)) ),              nIters = 200, data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp ##                          VarComp VarCompSE    Zratio Constraint ## Subject:Days:ran1:ran1 604.88924  466.0748 1.2978371   Positive ## Subject:Days:ran1:ran2  17.58685  105.0473 0.1674183   Unconstr ## Subject:Days:ran2:ran2  34.71088  188.4810 0.1841612   Positive ## units:isc:isc          656.17839  280.5390 2.3389913   Positive cov2cor(fm2$theta[[1]]) ##           [,1]      [,2] ## [1,] 1.0000000 0.1213716 ## [2,] 0.1213716 1.0000000"},{"path":"https://github.com/covaruber/sommer/articles/v5.sommer.vs.lme4.html","id":"random-slopes-with-a-different-intercept","dir":"Articles","previous_headings":"","what":"4) Random slopes with a different intercept","title":"Translating lme4 models to sommer","text":"model assume random effect different intercepts based levels another variable ’s main effect. 0 intercept lme4 assumes random slopes interact intercept without main effect.","code":"########### ## lme4 ########### # fm1 <- lmer(Reaction ~ Days + (0 + Days | Subject), data=DT) # summary(fm1) # or vc <- VarCorr(fm1); print(vc,comp=c(\"Variance\")) # Random effects: #  Groups   Name Variance Std.Dev. #  Subject  Days  52.71    7.26    #  Residual      842.03   29.02    # Number of obs: 180, groups:  Subject, 18 ########### ## sommer ########### fm2 <- mmer(Reaction ~ Days,             random= ~ vsr(Days, Subject),              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp ##                                  VarComp VarCompSE   Zratio Constraint ## Days:Subject.Reaction-Reaction  52.70946  19.09984 2.759681   Positive ## units.Reaction-Reaction        842.02736  93.84640 8.972399   Positive # fm2 <- mmec(Reaction ~ Days, #             random= ~ vsc(dsc(Days), isc(Subject)),  #             data=DT, tolParInv = 1e-6, verbose = FALSE) # summary(fm2)$varcomp"},{"path":"https://github.com/covaruber/sommer/articles/v5.sommer.vs.lme4.html","id":"other-models-available-in-sommer-but-not-in-lme4","dir":"Articles","previous_headings":"","what":"4) Other models available in sommer but not in lme4","title":"Translating lme4 models to sommer","text":"One strengths sommer availability variance covariance structures. section show 4 models available sommer available lme4 might useful.","code":"library(orthopolynom) ## diagonal model fm2 <- mmer(Reaction ~ Days,             random= ~ vsr(dsr(Daysf), Subject),              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp ##                               VarComp VarCompSE    Zratio Constraint ## 0:Subject.Reaction-Reaction  139.5473  399.5095 0.3492967   Positive ## 1:Subject.Reaction-Reaction  196.8544  411.8262 0.4780037   Positive ## 2:Subject.Reaction-Reaction    0.0000  365.3178 0.0000000   Positive ## 3:Subject.Reaction-Reaction  556.0773  501.2665 1.1093445   Positive ## 4:Subject.Reaction-Reaction  855.2104  581.8190 1.4698910   Positive ## 5:Subject.Reaction-Reaction 1699.4269  820.4561 2.0713197   Positive ## 6:Subject.Reaction-Reaction 2910.8975 1175.7872 2.4757011   Positive ## 7:Subject.Reaction-Reaction 1539.6201  779.1437 1.9760413   Positive ## 8:Subject.Reaction-Reaction 2597.5337 1089.4522 2.3842568   Positive ## 9:Subject.Reaction-Reaction 3472.7108 1351.5702 2.5693899   Positive ## units.Reaction-Reaction      879.6958  247.4680 3.5547862   Positive ## unstructured model fm2 <- mmer(Reaction ~ Days,             random= ~ vsr(usr(Daysf), Subject),              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp ##                                 VarComp VarCompSE    Zratio Constraint ## 0:Subject.Reaction-Reaction    402.6286  572.0867 0.7037894   Positive ## 1:0:Subject.Reaction-Reaction 1022.5098  393.6922 2.5972314   Unconstr ## 1:Subject.Reaction-Reaction    417.6460  521.3722 0.8010515   Positive ## 2:0:Subject.Reaction-Reaction  540.3746  287.1704 1.8817210   Unconstr ## 2:1:Subject.Reaction-Reaction  828.5156  325.7576 2.5433499   Unconstr ## 2:Subject.Reaction-Reaction      0.0000  509.8962 0.0000000   Positive ## 3:0:Subject.Reaction-Reaction  798.3750  397.0884 2.0105726   Unconstr ## 3:1:Subject.Reaction-Reaction 1137.3863  443.9056 2.5622256   Unconstr ## 3:2:Subject.Reaction-Reaction 1057.0708  385.9026 2.7392162   Unconstr ## 3:Subject.Reaction-Reaction    760.2469  436.7463 1.7407060   Positive ## 4:0:Subject.Reaction-Reaction  757.8909  411.2464 1.8429119   Unconstr ## 4:1:Subject.Reaction-Reaction 1039.6832  447.5192 2.3232148   Unconstr ## 4:2:Subject.Reaction-Reaction  911.1369  377.9651 2.4106377   Unconstr ## 4:3:Subject.Reaction-Reaction 1590.6778  566.5376 2.8077180   Unconstr ## 4:Subject.Reaction-Reaction    957.1797  364.0599 2.6291817   Positive ## 5:0:Subject.Reaction-Reaction  932.5247  516.7169 1.8047110   Unconstr ## 5:1:Subject.Reaction-Reaction 1179.5219  547.9498 2.1526095   Unconstr ## 5:2:Subject.Reaction-Reaction  859.1635  440.5250 1.9503173   Unconstr ## 5:3:Subject.Reaction-Reaction 1672.9989  664.0846 2.5192556   Unconstr ## 5:4:Subject.Reaction-Reaction 2003.0167  738.6399 2.7117633   Unconstr ## 5:Subject.Reaction-Reaction   2067.9299  553.3254 3.7372765   Positive ## 6:0:Subject.Reaction-Reaction  666.1077  565.7589 1.1773702   Unconstr ## 6:1:Subject.Reaction-Reaction  850.9395  583.6190 1.4580394   Unconstr ## 6:2:Subject.Reaction-Reaction  916.2375  504.0273 1.8178333   Unconstr ## 6:3:Subject.Reaction-Reaction 1785.8432  750.7274 2.3788171   Unconstr ## 6:4:Subject.Reaction-Reaction 2077.5064  822.0777 2.5271412   Unconstr ## 6:5:Subject.Reaction-Reaction 2603.2823 1035.1406 2.5149070   Unconstr ## 6:Subject.Reaction-Reaction   3123.2005 1049.0352 2.9772123   Positive ## 7:0:Subject.Reaction-Reaction  932.8190  490.4744 1.9018709   Unconstr ## 7:1:Subject.Reaction-Reaction  927.3416  492.7764 1.8818709   Unconstr ## 7:2:Subject.Reaction-Reaction  924.7079  426.2387 2.1694602   Unconstr ## 7:3:Subject.Reaction-Reaction 1282.8637  583.3415 2.1991642   Unconstr ## 7:4:Subject.Reaction-Reaction 1549.9053  643.7083 2.4077757   Unconstr ## 7:5:Subject.Reaction-Reaction 1941.5523  811.3286 2.3930529   Unconstr ## 7:6:Subject.Reaction-Reaction 2306.0261  951.5128 2.4235367   Unconstr ## 7:Subject.Reaction-Reaction   1669.8274  612.0081 2.7284398   Positive ## 8:0:Subject.Reaction-Reaction  920.3110  576.8500 1.5954079   Unconstr ## 8:1:Subject.Reaction-Reaction 1044.9313  592.5243 1.7635247   Unconstr ## 8:2:Subject.Reaction-Reaction  831.4993  486.9625 1.7075221   Unconstr ## 8:3:Subject.Reaction-Reaction 1607.0156  717.6871 2.2391591   Unconstr ## 8:4:Subject.Reaction-Reaction 2029.1022  805.6724 2.5185201   Unconstr ## 8:5:Subject.Reaction-Reaction 3058.1945 1093.4722 2.7967739   Unconstr ## 8:6:Subject.Reaction-Reaction 2927.6051 1177.5589 2.4861644   Unconstr ## 8:7:Subject.Reaction-Reaction 2433.2427  957.7103 2.5406876   Unconstr ## 8:Subject.Reaction-Reaction   2947.1635  844.8113 3.4885466   Positive ## 9:0:Subject.Reaction-Reaction 1440.6886  690.1726 2.0874323   Unconstr ## 9:1:Subject.Reaction-Reaction 1514.9679  703.4423 2.1536491   Unconstr ## 9:2:Subject.Reaction-Reaction  967.8504  550.1628 1.7592073   Unconstr ## 9:3:Subject.Reaction-Reaction 1742.6866  797.5934 2.1849310   Unconstr ## 9:4:Subject.Reaction-Reaction 2198.3504  892.7701 2.4623924   Unconstr ## 9:5:Subject.Reaction-Reaction 3236.8715 1196.2341 2.7058847   Unconstr ## 9:6:Subject.Reaction-Reaction 2210.6321 1185.1233 1.8653182   Unconstr ## 9:7:Subject.Reaction-Reaction 2399.5130 1027.8125 2.3345824   Unconstr ## 9:8:Subject.Reaction-Reaction 3847.0132 1391.5584 2.7645359   Unconstr ## 9:Subject.Reaction-Reaction   3946.2369 1228.6678 3.2118013   Positive ## units.Reaction-Reaction        883.2477  577.9203 1.5283210   Positive ## random regression (legendre polynomials) fm2 <- mmer(Reaction ~ Days,             random= ~ vsr(leg(Days,1), Subject),              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp ##                                  VarComp  VarCompSE   Zratio Constraint ## leg0:Subject.Reaction-Reaction 2817.4048 1011.23903 2.786092   Positive ## leg1:Subject.Reaction-Reaction  473.4608  199.53635 2.372805   Positive ## units.Reaction-Reaction         654.9433   77.18822 8.485016   Positive ## unstructured random regression (legendre) fm2 <- mmer(Reaction ~ Days,             random= ~ vsr(usr(leg(Days,1)), Subject),              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp ##                                       VarComp  VarCompSE   Zratio Constraint ## leg0:Subject.Reaction-Reaction      2817.4056 1011.24156 2.786086   Positive ## leg1:leg0:Subject.Reaction-Reaction  869.9590  381.02481 2.283208   Unconstr ## leg1:Subject.Reaction-Reaction       473.4608  199.53612 2.372807   Positive ## units.Reaction-Reaction              654.9428   77.18763 8.485075   Positive # same can be done with the mmec function"},{"path":"https://github.com/covaruber/sommer/articles/v5.sommer.vs.lme4.html","id":"literature","dir":"Articles","previous_headings":"","what":"Literature","title":"Translating lme4 models to sommer","text":"Covarrubias-Pazaran G. 2016. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6):1-15. Covarrubias-Pazaran G. 2018. Software update: Moving R package sommer multivariate mixed models genome-assisted prediction. doi: https://doi.org/10.1101/354639 Bernardo Rex. 2010. Breeding quantitative traits plants. Second edition. Stemma Press. 390 pp. Gilmour et al. 1995. Average Information REML: efficient algorithm variance parameter estimation linear mixed models. Biometrics 51(4):1440-1450. Henderson C.R. 1975. Best Linear Unbiased Estimation Prediction Selection Model. Biometrics vol. 31(2):423-447. Kang et al. 2008. Efficient control population structure model organism association mapping. Genetics 178:1709-1723. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Lee et al. 2015. MTG2: efficient algorithm multivariate linear mixed model analysis based genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201. Maier et al. 2015. Joint analysis psychiatric disorders increases accuracy risk prediction schizophrenia, bipolar disorder, major depressive disorder. J Hum Genet; 96(2):283-294. Rodriguez-Alvarez, Maria Xose, et al. Correcting spatial heterogeneity plant breeding experiments P-splines. Spatial Statistics 23 (2018): 52-71. Searle. 1993. Applying EM algorithm calculating ML REML estimates variance components. Paper invited 1993 American Statistical Association Meeting, San Francisco. Yu et al. 2006. unified mixed-model method association mapping accounts multiple levels relatedness. Genetics 38:203-208. Tunnicliffe W. 1989. use marginal likelihood time series model estimation. JRSS 51(1):15-27.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v6.sommer.spatial.html","id":"backgrounds-in-tensor-products","dir":"Articles","previous_headings":"SECTION 1: Introduction","what":"Backgrounds in tensor products","title":"Spatial modeling using the sommer package","text":"TBD","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/articles/v6.sommer.spatial.html","id":"two-dimensional-splines-multiple-spatial-components","dir":"Articles","previous_headings":"SECTION 2: Spatial models","what":"1) Two dimensional splines (multiple spatial components)","title":"Spatial modeling using the sommer package","text":"example show obtain results using SpATS package. achieved using spl2Db function wrapper tpsmmb function.","code":"library(sommer) ## Loading required package: Matrix ## Loading required package: MASS ## Loading required package: crayon data(DT_yatesoats) DT <- DT_yatesoats DT$row <- as.numeric(as.character(DT$row)) DT$col <- as.numeric(as.character(DT$col)) DT$R <- as.factor(DT$row) DT$C <- as.factor(DT$col)  # SPATS MODEL # m1.SpATS <- SpATS(response = \"Y\", #                   spatial = ~ PSANOVA(col, row, nseg = c(14,21), degree = 3, pord = 2), #                   genotype = \"V\", fixed = ~ 1, #                   random = ~ R + C, data = DT, #                   control = list(tolerance = 1e-04)) #  # summary(m1.SpATS, which = \"variances\") #  # Spatial analysis of trials with splines  #  # Response:                   Y          # Genotypes (as fixed):       V          # Spatial:                    ~PSANOVA(col, row, nseg = c(14, 21), degree = 3, pord = 2) # Fixed:                      ~1         # Random:                     ~R + C     #  #  # Number of observations:        72 # Number of missing data:        0 # Effective dimension:           17.09 # Deviance:                      483.405 #  # Variance components: #                   Variance            SD     log10(lambda) # R                 1.277e+02     1.130e+01           0.49450 # C                 2.673e-05     5.170e-03           7.17366 # f(col)            4.018e-15     6.339e-08          16.99668 # f(row)            2.291e-10     1.514e-05          12.24059 # f(col):row        1.025e-04     1.012e-02           6.59013 # col:f(row)        8.789e+01     9.375e+00           0.65674 # f(col):f(row)     8.036e-04     2.835e-02           5.69565 #  # Residual          3.987e+02     1.997e+01   # SOMMER MODEL m1.sommer <- mmer(Y~1+V+                     spl2Db(col,row, nsegments = c(14,21), degree = c(3,3),                             penaltyord = c(2,2), what = \"base\"),                    random = ~R+C+                     spl2Db(col,row, nsegments = c(14,21), degree = c(3,3),                             penaltyord = c(2,2), what=\"bits\"),                   data=DT, tolParConv = 1e-6, verbose = FALSE) ## Warning: fixed-effect model matrix is rank deficient so dropping 8 columns / coefficients summary(m1.sommer)$varcomp ##                VarComp VarCompSE     Zratio Constraint ## R.Y-Y       125.928235  89.77330  1.4027360   Positive ## C.Y-Y        -7.789528  24.29529 -0.3206189   Positive ## A:fC.Y-Y      0.000000  19.09624  0.0000000   Positive ## A:fR.Y-Y      0.000000  15.87659  0.0000000   Positive ## A:fC.R.Y-Y    0.000000  21.42763  0.0000000   Positive ## A:C.fR.Y-Y   82.177296  92.28630  0.8904604   Positive ## A:fC.fR.Y-Y   0.000000  25.46390  0.0000000   Positive ## units.Y-Y   405.900386  90.48195  4.4859820   Positive # get the fitted values for the spatial kernel and plot # ff <- fitted.mmer(m1.sommer) # DT$fit <- as.matrix(Reduce(\"+\",ff$Zu[-c(1:2)]))  # lattice::levelplot(fit~row*col,data=DT)"},{"path":"https://github.com/covaruber/sommer/articles/v6.sommer.spatial.html","id":"two-dimensional-splines-single-spatial-component","dir":"Articles","previous_headings":"SECTION 2: Spatial models","what":"2) Two dimensional splines (single spatial component)","title":"Spatial modeling using the sommer package","text":"reduce computational burden fitting multiple spatial kernels sommer provides single spatial kernel method spl2Da function. shown, can produce similar results flexible model. Use one fits better needs.","code":"# SOMMER MODEL m2.sommer <- mmer(Y~1+V,                    random = ~R+C+spl2Da(col,row, nsegments = c(14,21), degree = c(3,3), penaltyord = c(2,2)),                   data=DT, tolParConv = 1e-6, verbose = FALSE) summary(m1.sommer)$varcomp ##                VarComp VarCompSE     Zratio Constraint ## R.Y-Y       125.928235  89.77330  1.4027360   Positive ## C.Y-Y        -7.789528  24.29529 -0.3206189   Positive ## A:fC.Y-Y      0.000000  19.09624  0.0000000   Positive ## A:fR.Y-Y      0.000000  15.87659  0.0000000   Positive ## A:fC.R.Y-Y    0.000000  21.42763  0.0000000   Positive ## A:C.fR.Y-Y   82.177296  92.28630  0.8904604   Positive ## A:fC.fR.Y-Y   0.000000  25.46390  0.0000000   Positive ## units.Y-Y   405.900386  90.48195  4.4859820   Positive # get the fitted values for the spatial kernel and plot # ff <- fitted.mmer(m2.sommer) # DT$fit <- as.matrix(Reduce(\"+\",ff$Zu[-c(1:2)]))  # lattice::levelplot(fit~row*col,data=DT)"},{"path":"https://github.com/covaruber/sommer/articles/v6.sommer.spatial.html","id":"spatial-models-in-multiple-trials-at-once","dir":"Articles","previous_headings":"SECTION 2: Spatial models","what":"3) Spatial models in multiple trials at once","title":"Spatial modeling using the sommer package","text":"Sometimes want fit heterogeneous variance components e.g., multiple trials different locations. spatial models can also fitted way using .var .levels arguments. first argument expects variable define levels variance components fitted. second argument way user specify levels spatial kernels fitted user doesn’t want fit levels (e.g., trials fields).","code":"DT2 <- rbind(DT,DT) DT2$Y <- DT2$Y + rnorm(length(DT2$Y)) DT2$trial <- c(rep(\"A\",nrow(DT)),rep(\"B\",nrow(DT))) head(DT2) ##   row col         Y   N          V  B         MP R C trial ## 1   1   1  89.59996 0.2    Victory B2    Victory 1 1     A ## 2   2   1  61.25532   0    Victory B2    Victory 2 1     A ## 3   3   1 118.56274 0.4 Marvellous B2 Marvellous 3 1     A ## 4   4   1 143.99443 0.6 Marvellous B2 Marvellous 4 1     A ## 5   5   1 149.62155 0.6 GoldenRain B2 GoldenRain 5 1     A ## 6   6   1 109.14841 0.2 GoldenRain B2 GoldenRain 6 1     A # SOMMER MODEL m3.sommer <- mmer(Y~1+V,                    random = ~vsr(dsr(trial),R)+vsr(dsr(trial),C)+                     spl2Da(col,row, nsegments = c(14,21), degree = c(3,3),                             penaltyord = c(2,2), at.var = trial),                   rcov = ~vsr(dsr(trial),units),                   data=DT2, tolParConv = 1e-6, verbose = FALSE) summary(m3.sommer)$varcomp ##               VarComp VarCompSE    Zratio Constraint ## A:R.Y-Y     110.48977  84.54017 1.3069500   Positive ## B:R.Y-Y      98.62245  79.02550 1.2479827   Positive ## A:C.Y-Y     142.56456 137.96100 1.0333686   Positive ## B:C.Y-Y     149.42401 141.84342 1.0534434   Positive ## A:all.Y-Y   425.72702 906.61488 0.4695787   Positive ## B:all.Y-Y   359.95531 871.18523 0.4131789   Positive ## A:units.Y-Y 395.80463 208.91326 1.8945884   Positive ## B:units.Y-Y 392.77959 202.73542 1.9374000   Positive # get the fitted values for the spatial kernel and plot # ff <- fitted.mmer(m3.sommer) # DT2$fit <- as.matrix(Reduce(\"+\",ff$Zu[-c(1:4)]))  # lattice::levelplot(fit~row*col|trial,data=DT2)"},{"path":"https://github.com/covaruber/sommer/articles/v6.sommer.spatial.html","id":"literature","dir":"Articles","previous_headings":"","what":"Literature","title":"Spatial modeling using the sommer package","text":"Covarrubias-Pazaran G. 2016. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6):1-15. Covarrubias-Pazaran G. 2018. Software update: Moving R package sommer multivariate mixed models genome-assisted prediction. doi: https://doi.org/10.1101/354639 Bernardo Rex. 2010. Breeding quantitative traits plants. Second edition. Stemma Press. 390 pp. Gilmour et al. 1995. Average Information REML: efficient algorithm variance parameter estimation linear mixed models. Biometrics 51(4):1440-1450. Henderson C.R. 1975. Best Linear Unbiased Estimation Prediction Selection Model. Biometrics vol. 31(2):423-447. Kang et al. 2008. Efficient control population structure model organism association mapping. Genetics 178:1709-1723. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Lee et al. 2015. MTG2: efficient algorithm multivariate linear mixed model analysis based genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201. Maier et al. 2015. Joint analysis psychiatric disorders increases accuracy risk prediction schizophrenia, bipolar disorder, major depressive disorder. J Hum Genet; 96(2):283-294. Rodriguez-Alvarez, Maria Xose, et al. Correcting spatial heterogeneity plant breeding experiments P-splines. Spatial Statistics 23 (2018): 52-71. Searle. 1993. Applying EM algorithm calculating ML REML estimates variance components. Paper invited 1993 American Statistical Association Meeting, San Francisco. Yu et al. 2006. unified mixed-model method association mapping accounts multiple levels relatedness. Genetics 38:203-208. Tunnicliffe W. 1989. use marginal likelihood time series model estimation. JRSS 51(1):15-27.","code":""},{"path":"https://github.com/covaruber/sommer/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Giovanny Covarrubias-Pazaran. Author, maintainer.","code":""},{"path":"https://github.com/covaruber/sommer/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Giovanny C (2016). “Genome assisted prediction quantitative traits using R package sommer.” PLoS ONE, 11, 1-15.","code":"@Article{,   title = {Genome assisted prediction of quantitative traits using the R package sommer},   author = {Covarrubias-Pazaran Giovanny},   journal = {PLoS ONE},   year = {2016},   volume = {11},   pages = {1-15}, }"},{"path":"https://github.com/covaruber/sommer/index.html","id":"sommer-solving-mixed-model-equations-in-r","dir":"","previous_headings":"","what":"sommer","title":"sommer","text":"Structural multivariate-univariate linear mixed model solver estimation multiple random effects unknown variance-covariance structures (e.g., heterogeneous unstructured) known covariance among levels random effects (e.g., pedigree genomic relationship matrices) (Covarrubias-Pazaran, 2016; Maier et al., 2015; Jensen et al., 1997). REML estimates can obtained using Direct-Inversion Newton-Raphson Direct-Inversion Average Information algorithms problems r x r (r number records) using Henderson-based average information algorithm problem c x c (c number coefficients estimate). Spatial models can also fitted using two-dimensional spline functionality available.","code":""},{"path":"https://github.com/covaruber/sommer/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"sommer","text":"can install development version sommer GitHub:","code":"devtools::install_github('covaruber/sommer')"},{"path":"https://github.com/covaruber/sommer/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"sommer","text":"Quick start sommer package Moving newer versions sommer Quantitative genetics using sommer package GxE models sommer lme4 vs sommer Spatial","code":""},{"path":"https://github.com/covaruber/sommer/index.html","id":"development","dir":"","previous_headings":"","what":"Development","title":"sommer","text":"sommer package active development. expert mixed models, statistics programming know implement following: minimum degree ordering algorithm symbolic cholesky factorization factor analytic structure generalized linear models please help us take sommer next level. Drop email push changes github :)","code":""},{"path":"https://github.com/covaruber/sommer/reference/A.mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Additive relationship matrix — A.mat","title":"Additive relationship matrix — A.mat","text":"Calculates realized additive relationship matrix. Currently C++ implementation van Raden (2008).","code":""},{"path":"https://github.com/covaruber/sommer/reference/A.mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Additive relationship matrix — A.mat","text":"","code":"A.mat(X,min.MAF=0,return.imputed=FALSE)"},{"path":"https://github.com/covaruber/sommer/reference/A.mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Additive relationship matrix — A.mat","text":"X Matrix (\\(n \\times m\\)) unphased genotypes \\(n\\) lines \\(m\\) biallelic markers, coded {-1,0,1}. Fractional (imputed) missing values (NA) allowed. min.MAF Minimum minor allele frequency. matrix sensitive rare alleles, default monomorphic markers removed. return.imputed TRUE, imputed marker matrix returned.","code":""},{"path":"https://github.com/covaruber/sommer/reference/A.mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Additive relationship matrix — A.mat","text":"vanraden method: marker matrix centered subtracting column means \\(M= X - ms\\) ms coumn means. \\(=M M'/c\\), \\(c = \\sum_k{d_k}/k\\), mean value diagonal values \\(M M'\\) portion.","code":""},{"path":"https://github.com/covaruber/sommer/reference/A.mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Additive relationship matrix — A.mat","text":"return.imputed = FALSE, \\(n \\times n\\) additive relationship matrix returned. return.imputed = TRUE, function returns list containing $matrix $X imputed marker matrix","code":""},{"path":"https://github.com/covaruber/sommer/reference/A.mat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Additive relationship matrix — A.mat","text":"Endelman, J.B., J.-L. Jannink. 2012. Shrinkage estimation realized relationship matrix. G3:Genes, Genomes, Genetics. 2:1405-1413. doi: 10.1534/g3.112.004259 Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/A.mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Additive relationship matrix — A.mat","text":"","code":"####=========================================#### #### random population of 200 lines with 1000 markers ####=========================================#### X <- matrix(rep(0,200*1000),200,1000) for (i in 1:200) {   X[i,] <- ifelse(runif(1000)<0.5,-1,1) }  A <- A.mat(X)  ####=========================================#### #### take a look at the Genomic relationship matrix  #### (just a small part) ####=========================================#### # colfunc <- colorRampPalette(c(\"steelblue4\",\"springgreen\",\"yellow\")) # hv <- heatmap(A[1:15,1:15], col = colfunc(100),Colv = \"Rowv\") # str(hv)"},{"path":"https://github.com/covaruber/sommer/reference/AI.html","id":null,"dir":"Reference","previous_headings":"","what":"Average Information Algorithm — AI","title":"Average Information Algorithm — AI","text":"Univariate version average information (AI) algorithm.","code":""},{"path":"https://github.com/covaruber/sommer/reference/AI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Average Information Algorithm — AI","text":"","code":"AI(X=NULL,Z=NULL, Zind=NULL, Ai=NULL,y=NULL,S=NULL, H=NULL,     nIters=80, tolParConvLL=1e-4, tolParConvNorm=.05, tolParInv=1e-6, theta=NULL,      thetaC=NULL, thetaF=NULL, addScaleParam=NULL,     weightInfEMv=NULL, weightInfMat=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/AI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Average Information Algorithm — AI","text":"X incidence matrix fixed effects. Z Z list lists element contains Z matrices required covariance structure specified random effect. Zind vector specifying random effect Z matrix belongs . Ai list inverses relationship matrix random effect. y response variable S list residual matrices. H matrix weights. squared via cholesky decomposition apply residual matrices. nIters number REML iterations . tolParConvLL rule stoping optimization problem, difference log-likelihood current past iteration. tolParConvNorm rule stoping optimization problem, difference norms. tolParInv value add diagonals matrix inverted positive-definite. theta initial values vc (matrices symmetric). thetaC constraints vc: 1 positive, 2 unconstrained, 3 fixed. thetaF dataframe indicating fixed constraints x times another vc, rows indicate variance components, columns scale parameters (VC plus additional ones preferred). addScaleParam additional scale parameter included applying constraints thetaF. weightInfEMv vector put diagonal matrix (list many matrices iterations) representing weight assigned EM information matrix. weightInfMat vector weights information matrix operation delta = - * dLu/dLx # unstructured models may require less weight information matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/AI.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Average Information Algorithm — AI","text":"algorithm based Jensen, Madsen Thompson (1997)","code":""},{"path":"https://github.com/covaruber/sommer/reference/AI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Average Information Algorithm — AI","text":"parameters correctly indicated program return list following information: res list different outputs","code":""},{"path":"https://github.com/covaruber/sommer/reference/AI.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Average Information Algorithm — AI","text":"Jensen, J., Mantysaari, E. ., Madsen, P., Thompson, R. (1997). Residual maximum likelihood estimation (co) variance components multivariate mixed linear models using average information. Journal Indian Society Agricultural Statistics, 49, 215-236. Covarrubias-Pazaran G. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 2016, 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/AI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Average Information Algorithm — AI","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================####  data(\"DT_example\") DT <- DT_example K <- A_example #### look at the data and fit the model head(DT) #>                   Name     Env Loc Year     Block Yield    Weight #> 33  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.1     4 -1.904711 #> 65          CO02024-9W CA.2013  CA 2013 CA.2013.1     5 -1.446958 #> 66  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.2     5 -1.516271 #> 67            MSL007-B CA.2011  CA 2011 CA.2011.2     5 -1.435510 #> 68           MSR169-8Y CA.2013  CA 2013 CA.2013.1     5 -1.469051 #> 103         AC05153-1W CA.2013  CA 2013 CA.2013.1     6 -1.307167  zz <- with(DT, vsr(dsr(Env),Name))  Z <- c(list(model.matrix(~Name-1, data=DT)),zz$Z)  Zind <- c(1,2,2,2)  A <- list(diag(41), diag(41))#rep(list(diag(41)),4)  Ai <- lapply(A, function(x){solve(x)})  theta <- list(   matrix(10,1,1),   diag(10,3,3),   diag(10,3,3) );theta #> [[1]] #>      [,1] #> [1,]   10 #>  #> [[2]] #>      [,1] [,2] [,3] #> [1,]   10    0    0 #> [2,]    0   10    0 #> [3,]    0    0   10 #>  #> [[3]] #>      [,1] [,2] [,3] #> [1,]   10    0    0 #> [2,]    0   10    0 #> [3,]    0    0   10 #>   thetaC <- list(   matrix(1,1,1),   diag(1,3,3),   diag(1,3,3) );thetaC #> [[1]] #>      [,1] #> [1,]    1 #>  #> [[2]] #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1 #>  #> [[3]] #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1 #>   X <- model.matrix(~Env, data=DT)  y <- as.matrix(DT$Yield)  DTx <- DT; DTx$units <- as.factor(1:nrow(DTx)) ss <- with(DTx, vsr(dsr(Env),units) )  S <- ss$Z   H <- diag(length(y))  addScaleParam <- 0 nn <- unlist(lapply(thetaC, function(x){length(which(x > 0))})) nn2 <- sum(nn[1:max(Zind)]) ff <- diag(nn2) thetaF <- cbind(ff,matrix(0,nn2,1))  ## apply the function weightInfMat=rep(1,40); # weights for the information matrix weightInfEMv=c(seq(.9,.1,-.1),rep(0,36)); # weights for the EM information matrix  # expr = res3<-AI(X=X,Z=Z, Zind=Zind, #                 Ai=Ai,y=y, #                 S=S, #                 H=H,  #                 nIters=20, tolParConvLL=1e-5, #                 tolParConvNorm=0.05, #                 tolParInv=1e-6,theta=theta, #                 thetaC=thetaC,thetaF=thetaF, #                 addScaleParam=addScaleParam, weightInfEMv = weightInfEMv, #                 weightInfMat = weightInfMat #                  # ) # # compare results # res3$monitor"},{"path":"https://github.com/covaruber/sommer/reference/AR1mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Autocorrelation matrix of order 1. — AR1","title":"Autocorrelation matrix of order 1. — AR1","text":"Creates autocorrelation matrix order one parameters specified.","code":""},{"path":"https://github.com/covaruber/sommer/reference/AR1mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Autocorrelation matrix of order 1. — AR1","text":"","code":"AR1(x,rho=0.25)"},{"path":"https://github.com/covaruber/sommer/reference/AR1mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Autocorrelation matrix of order 1. — AR1","text":"x vector variable define factor levels AR1 covariance structure. rho rho value matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/AR1mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Autocorrelation matrix of order 1. — AR1","text":"Specially useful constructing covariance structures rows ranges capture better spatial variation trends field. rho value assumed fixed values variance component optimized REML.","code":""},{"path":"https://github.com/covaruber/sommer/reference/AR1mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Autocorrelation matrix of order 1. — AR1","text":"everything defined correctly function returns: $nn correlation matrix","code":""},{"path":"https://github.com/covaruber/sommer/reference/AR1mat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Autocorrelation matrix of order 1. — AR1","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/AR1mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Autocorrelation matrix of order 1. — AR1","text":"","code":"x <- 1:4 R1 <- AR1(x,rho=.25) image(R1)"},{"path":"https://github.com/covaruber/sommer/reference/ARMAmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Autocorrelation Moving average. — ARMA","title":"Autocorrelation Moving average. — ARMA","text":"Creates ARMA matrix order one parameters specified.","code":""},{"path":"https://github.com/covaruber/sommer/reference/ARMAmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Autocorrelation Moving average. — ARMA","text":"","code":"ARMA(x, rho=0.25, lambda=0.25)"},{"path":"https://github.com/covaruber/sommer/reference/ARMAmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Autocorrelation Moving average. — ARMA","text":"x vector variable define factor levels ARMA covariance structure. rho rho value matrix. lambda dimensions square matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/ARMAmat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Autocorrelation Moving average. — ARMA","text":"Specially useful constructing covariance structures rows ranges capture better spatial variation trends field. rho value assumed fixed values variance component optimized REML.","code":""},{"path":"https://github.com/covaruber/sommer/reference/ARMAmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Autocorrelation Moving average. — ARMA","text":"everything defined correctly function returns: $nn correlation matrix","code":""},{"path":"https://github.com/covaruber/sommer/reference/ARMAmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Autocorrelation Moving average. — ARMA","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/ARMAmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Autocorrelation Moving average. — ARMA","text":"","code":"x <- 1:4 R1 <- ARMA(x,rho=.25,lambda=0.2) image(R1)"},{"path":"https://github.com/covaruber/sommer/reference/CSmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Compound symmetry matrix — CS","title":"Compound symmetry matrix — CS","text":"Creates compound symmetry matrix parameters specified.","code":""},{"path":"https://github.com/covaruber/sommer/reference/CSmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compound symmetry matrix — CS","text":"","code":"CS(x, rho=0.25)"},{"path":"https://github.com/covaruber/sommer/reference/CSmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compound symmetry matrix — CS","text":"x vector variable define factor levels ARMA covariance structure. rho rho value matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/CSmat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compound symmetry matrix — CS","text":"Specially useful constructing covariance structures rows ranges capture better spatial variation trends field. rho value assumed fixed values variance component optimized REML.","code":""},{"path":"https://github.com/covaruber/sommer/reference/CSmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compound symmetry matrix — CS","text":"everything defined correctly function returns: $nn correlation matrix","code":""},{"path":"https://github.com/covaruber/sommer/reference/CSmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compound symmetry matrix — CS","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/CSmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compound symmetry matrix — CS","text":"","code":"x <- 1:4 R1 <- CS(x,rho=.25) image(R1)"},{"path":"https://github.com/covaruber/sommer/reference/D.mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Dominance relationship matrix — D.mat","title":"Dominance relationship matrix — D.mat","text":"C++ implementation dominance matrix. Calculates realized dominance relationship matrix. Can help increase prediction accuracy 2 conditions met; 1) trait intermediate high heritability, 2) population contains big number individuals half full sibs (HS & FS).","code":""},{"path":"https://github.com/covaruber/sommer/reference/D.mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dominance relationship matrix — D.mat","text":"","code":"D.mat(X,nishio=TRUE,min.MAF=0,return.imputed=FALSE)"},{"path":"https://github.com/covaruber/sommer/reference/D.mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dominance relationship matrix — D.mat","text":"X Matrix (\\(n \\times m\\)) unphased genotypes \\(n\\) lines \\(m\\) biallelic markers, coded {-1,0,1}. Fractional (imputed) missing values (NA) allowed. nishio TRUE Nishio ans Satoh. (2014), otherwise Su et al. (2012). See references. min.MAF Minimum minor allele frequency. D matrix sensitive rare alleles, default monomorphic markers removed. return.imputed TRUE, imputed marker matrix returned.","code":""},{"path":"https://github.com/covaruber/sommer/reference/D.mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dominance relationship matrix — D.mat","text":"additive marker coefficients used compute dominance coefficients : Xd = 1-abs(X) diploids. nishio method: marker matrix centered subtracting column means \\(M= Xd - ms\\) ms column means. \\(=M M'/c\\), \\(c = 2 \\sum_k {p_k (1-p_k)}\\). su method: marker matrix normalized subtracting row means \\(M= Xd - 2pq\\) 2pq product allele frequencies times 2. \\(=M M'/c\\), \\(c = 2 \\sum_k {2pq_k (1-2pq_k)}\\).","code":""},{"path":"https://github.com/covaruber/sommer/reference/D.mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dominance relationship matrix — D.mat","text":"return.imputed = FALSE, \\(n \\times n\\) additive relationship matrix returned. return.imputed = TRUE, function returns list containing $D D matrix $imputed imputed marker matrix","code":""},{"path":"https://github.com/covaruber/sommer/reference/D.mat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Dominance relationship matrix — D.mat","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Nishio M Satoh M. 2014. Including Dominance Effects Genomic BLUP Method Genomic Evaluation. Plos One 9(1), doi:10.1371/journal.pone.0085792 Su G, Christensen , Ostersen T, Henryon M, Lund MS. 2012. Estimating Additive Non-Additive Genetic Variances Predicting Genetic Merits Using Genome-Wide Dense Single Nucleotide Polymorphism Markers. PLoS ONE 7(9): e45293. doi:10.1371/journal.pone.0045293","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/D.mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dominance relationship matrix — D.mat","text":"","code":"####=========================================#### #### EXAMPLE 1 ####=========================================#### ####random population of 200 lines with 1000 markers X <- matrix(rep(0,200*1000),200,1000) for (i in 1:200) {   X[i,] <- sample(c(-1,0,0,1), size=1000, replace=TRUE) }  D <- D.mat(X)"},{"path":"https://github.com/covaruber/sommer/reference/DT_augment.html","id":null,"dir":"Reference","previous_headings":"","what":"DT_augment design example. — DT_augment","title":"DT_augment design example. — DT_augment","text":"dataset contains phenotpic data one trait evaluated experimental design known augmented design. model allows obtain BLUPs genotypes unreplicated dividing field blocks replicating 'check genotypes' blocks unreplicated genotypes randomly within blocks. presence check genotypes (usually cultivars) allows adjustment unreplicated genotypes.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_augment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DT_augment design example. — DT_augment","text":"","code":"data(\"DT_augment\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_augment.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"DT_augment design example. — DT_augment","text":"format :  chr \"DT_augment\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_augment.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"DT_augment design example. — DT_augment","text":"data generated potato study.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_augment.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"DT_augment design example. — DT_augment","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_augment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DT_augment design example. — DT_augment","text":"","code":"# ###=========================================#### # ### AUGMENTED DESIGN EXAMPLE # ###=========================================#### # data(DT_augment) # DT <- DT_augment # head(DT) # ####=========================================#### # #### fit the mixed model and check summary # ####=========================================#### # mix1 <- mmer(TSW ~ Check.Gen, #              random = ~ Block + Genotype:Check, #              data=DT) # summary(mix1)$varcomp #  # mix2 <- mmec(TSW ~ Check.Gen, #              random = ~ Block + Genotype:Check, #              data=DT) # summary(mix2)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/DT_btdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Blue Tit Data for a Quantitative Genetic Experiment — DT_btdata","title":"Blue Tit Data for a Quantitative Genetic Experiment — DT_btdata","text":"data frame 828 rows 7 columns, variables tarsus length (tarsus) colour (back) measured 828 individuals (animal). mother also recorded (dam) together foster nest (fosternest) chicks reared. date first egg nest hatched (hatchdate) recorded together sex (sex) individuals.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_btdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Blue Tit Data for a Quantitative Genetic Experiment — DT_btdata","text":"","code":"data(\"DT_btdata\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_btdata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Blue Tit Data for a Quantitative Genetic Experiment — DT_btdata","text":"format :  chr \"DT_btdata\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_btdata.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Blue Tit Data for a Quantitative Genetic Experiment — DT_btdata","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_btdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Blue Tit Data for a Quantitative Genetic Experiment — DT_btdata","text":"","code":"# ####=========================================#### # #### For CRAN time limitations most lines in the  # #### examples are silenced with one '#' mark,  # #### remove them and run the examples # ####=========================================#### # ####=========================================#### # ####=========================================#### # #### EXAMPLE 1 # #### simple example # ####=========================================#### # ####=========================================#### # data(DT_btdata) # DT <- DT_btdata # head(DT) # mix4 <- mmer(tarsus ~ sex, #              random = ~ dam + fosternest, #              rcov=~units, #              data = DT) # summary(mix4)$varcomp #  # mix5 <- mmec(tarsus ~ sex, #              random = ~ dam + fosternest, #              rcov=~units, #              data = DT) # summary(mix5)$varcomp #  # ####=========================================#### # ####=========================================#### # ####=========================================#### # #### EXAMPLE 2 # #### more complex multivariate model # ####=========================================#### # ####=========================================#### # data(DT_btdata) # DT <- DT_btdata # mix3 <- mmer(cbind(tarsus, back) ~ sex, #                 random = ~ vsr(dam) + vsr(fosternest), #                 rcov= ~ vsr(units, Gtc=diag(2)), #                 data = DT) # summary(mix3) # #### calculate the genetic correlation # cov2cor(mix3$sigma$`u:dam`) # cov2cor(mix3$sigma$`u:fosternest`)"},{"path":"https://github.com/covaruber/sommer/reference/DT_cornhybrids.html","id":null,"dir":"Reference","previous_headings":"","what":"Corn crosses and markers — DT_cornhybrids","title":"Corn crosses and markers — DT_cornhybrids","text":"dataset contains phenotpic data plant height grain yield 100 400 possible hybrids originated 40 inbred lines belonging 2 heterotic groups, 20 lines , 1600 rows exist 400 possible hybrids evaluated 4 locations 100 crosses phenotypic information.  purpose data show predict 300 crosses. data contains 3 elements. first phenotypic data parent information cross evaluated 4 locations. 1200 rows missing data 100 crosses performed chosen able estimate GCA SCA effects everything. second element data set phenotypic data relevant information 40. third element genomic relationship matrix 40 inbred lines originated 511 SNP markers calculated using .mat function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_cornhybrids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Corn crosses and markers — DT_cornhybrids","text":"","code":"data(\"DT_cornhybrids\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_cornhybrids.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Corn crosses and markers — DT_cornhybrids","text":"format :  chr \"DT_cornhybrids\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_cornhybrids.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Corn crosses and markers — DT_cornhybrids","text":"data generated corn study.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_cornhybrids.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Corn crosses and markers — DT_cornhybrids","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_cornhybrids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Corn crosses and markers — DT_cornhybrids","text":"","code":"# ####=========================================#### # #### For CRAN time limitations most lines in the  # #### examples are silenced with one '#' mark,  # #### remove them and run the examples using # #### command + shift + C |OR| control + shift + C # ####=========================================#### #  # data(DT_cornhybrids) # DT <- DT_cornhybrids # DTi <- DTi_cornhybrids # GT <- GT_cornhybrids # hybrid2 <- DT # extract cross data # A <- GT # K1 <- A[levels(hybrid2$GCA1), levels(hybrid2$GCA1)]; dim(K1) # K2 <- A[levels(hybrid2$GCA2), levels(hybrid2$GCA2)]; dim(K2) # S <- kronecker(K1, K2) ; dim(S) # rownames(S) <- colnames(S) <- levels(hybrid2$SCA) #  # ans <- mmer(Yield ~ Location, #              random = ~ vsr(GCA1,Gu=K1) + vsr(GCA2,Gu=K2), # + vsr(SCA,Gu=S), #              rcov=~units, #              data=hybrid2) # summary(ans)$varcomp #  # ## mmec uses the inverse of the relationship matrix # K1i <- as(solve(K1 + diag(1e-4,ncol(K1),ncol(K1))), Class=\"dgCMatrix\") # K2i <- as(solve(K2 + diag(1e-4,ncol(K2),ncol(K2))), Class=\"dgCMatrix\") # Si <- as(solve(S + diag(1e-4,ncol(S),ncol(S))), Class=\"dgCMatrix\") # ans2 <- mmec(Yield ~ Location, #             random = ~ vsc(isc(GCA1),Gu=K1i) + vsc(isc(GCA2),Gu=K2i), # + vsc(isc(SCA),Gu=Si), #             rcov=~units, #             data=hybrid2) # summary(ans2)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/DT_cpdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Genotypic and Phenotypic data for a CP population — DT_cpdata","title":"Genotypic and Phenotypic data for a CP population — DT_cpdata","text":"CP population F1 cross designation cross 2 highly heterozygote individuals; .e. humans, fruit crops, bredding populations recurrent selection. dataset contains phenotpic data 363 siblings F1 cross. averages 2 environments evaluated 4 traits; color, yield, fruit average weight, firmness. columns CPgeno file markers whereas rows individuals. CPpheno data frame contains measurements 363 siblings, mentioned averages 2 environments.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_cpdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Genotypic and Phenotypic data for a CP population — DT_cpdata","text":"","code":"data(\"DT_cpdata\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_cpdata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Genotypic and Phenotypic data for a CP population — DT_cpdata","text":"format :  chr \"DT_cpdata\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_cpdata.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Genotypic and Phenotypic data for a CP population — DT_cpdata","text":"data simulated fruit breeding applications.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_cpdata.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Genotypic and Phenotypic data for a CP population — DT_cpdata","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_cpdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genotypic and Phenotypic data for a CP population — DT_cpdata","text":"","code":"# ####=========================================#### # #### For CRAN time limitations most lines in the # #### examples are silenced with one '#' mark, # #### remove them and run the examples using # #### command + shift + C |OR| control + shift + C # ####=========================================#### # # data(DT_cpdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # #### create the variance-covariance matrix # A <- A.mat(GT) # additive relationship matrix # #### look at the data and fit the model # head(DT) # mix1 <- mmer(Yield~1, #               random=~vsr(id,Gu=A) #                       + Rowf + Colf, #               rcov=~units, #               data=DT) # summary(mix1)$varcomp # # ## mmec uses the inverse of the relationship matrix # Ai <- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class=\"dgCMatrix\") # mix2 <- mmec(Yield~1, #              random=~vsc(isc(id),Gu=Ai) #              + Rowf + Colf, #              rcov=~units, #              data=DT) # summary(mix2)$varcomp # # vg <- summary(mix2)$varcomp[1,1] # genetic variance # G <- A*vg # genetic variance-covariance # Ci <- mix2$Ci # coefficient matrix # ind <- as.vector(mix2$partitions$`vsc(isc(id), Gu = Ai)`) # ind <- seq(ind[1],ind[2]) # Ctt <- Ci[ind,ind] # portion of Ci for genotypes # R2 <- (G - Ctt)/G # reliability matrix # mean(diag(R2)) # average reliability of the trial # # ####====================#### # #### multivariate model #### # ####     2 traits       #### # ####====================#### # #### be patient take some time # ans.m <- mmer(cbind(Yield,color)~1, #                random=~ vsr(id, Gu=A) #                + vsr(Rowf,Gtc=diag(2)) #                + vsr(Colf,Gtc=diag(2)), #                rcov=~ vsr(units), #                data=DT) # cov2cor(ans.m$sigma$`u:id`)"},{"path":"https://github.com/covaruber/sommer/reference/DT_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Broad sense heritability calculation. — DT_example","title":"Broad sense heritability calculation. — DT_example","text":"dataset contains phenotpic data 41 potato lines evaluated 3 environments RCBD design. phenotypic trait tuber quality show obtain estimate DT_example trait.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broad sense heritability calculation. — DT_example","text":"","code":"data(\"DT_example\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_example.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Broad sense heritability calculation. — DT_example","text":"format :  chr \"DT_example\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_example.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Broad sense heritability calculation. — DT_example","text":"data generated potato study.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_example.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Broad sense heritability calculation. — DT_example","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Broad sense heritability calculation. — DT_example","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================#### ####=========================================#### #### EXAMPLES #### Different models with sommer ####=========================================####  data(DT_example) DT <- DT_example A <- A_example head(DT) #>                   Name     Env Loc Year     Block Yield    Weight #> 33  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.1     4 -1.904711 #> 65          CO02024-9W CA.2013  CA 2013 CA.2013.1     5 -1.446958 #> 66  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.2     5 -1.516271 #> 67            MSL007-B CA.2011  CA 2011 CA.2011.2     5 -1.435510 #> 68           MSR169-8Y CA.2013  CA 2013 CA.2013.1     5 -1.469051 #> 103         AC05153-1W CA.2013  CA 2013 CA.2013.1     6 -1.307167  ####=========================================#### #### Univariate homogeneous variance models  #### ####=========================================####  ## Compound simmetry (CS) model ans1 <- mmer(Yield~Env,              random= ~ Name + Env:Name,              rcov= ~ units,              data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -31.2668   1:14:59      0           0 #>     2      -23.2804   1:14:59      0           0 #>     3      -20.4746   1:14:59      0           0 #>     4      -20.1501   1:14:59      0           0 #>     5      -20.1454   1:14:59      0           0 #>     6      -20.1454   1:14:59      0           0 summary(ans1)$varcomp #>                       VarComp VarCompSE   Zratio Constraint #> Name.Yield-Yield     3.681877 1.6909561 2.177394   Positive #> Env:Name.Yield-Yield 5.173062 1.4952313 3.459707   Positive #> units.Yield-Yield    4.366285 0.6470458 6.748031   Positive  ans1b <- mmec(Yield~Env,              random= ~ Name + Env:Name,              rcov= ~ units,              data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -327.295   1:15:0      0           0 #>     2      -311.454   1:15:0      0           0 #>     3      -304.865   1:15:0      0           0 #>     4      -302.661   1:15:0      0           0 #>     5      -301.766   1:15:0      0           0 #>     6      -301.251   1:15:0      0           0 #>     7      -300.978   1:15:0      0           0 #>     8      -300.877   1:15:0      0           0 #>     9      -300.855   1:15:0      0           0 #>     10      -300.852   1:15:0      0           0 #>     11      -300.852   1:15:0      0           0 summary(ans1b)$varcomp #>                   VarComp VarCompSE   Zratio Constraint #> Name:isc:isc     3.683153  1.880974 1.958109   Positive #> Env:Name:isc:isc 5.174116  2.420486 2.137635   Positive #> units:isc:isc    4.359651  2.270467 1.920156   Positive  # ####===========================================#### # #### Univariate heterogeneous variance models  #### # ####===========================================#### #  # ## Compound simmetry (CS) + Diagonal (DIAG) model # ans2 <- mmer(Yield~Env, #              random= ~Name + vsr(dsr(Env),Name), #              rcov= ~ vsr(dsr(Env),units), #              data=DT) # summary(ans2) #  # DT=DT[with(DT, order(Env)), ] # ans2b <- mmec(Yield~Env, #              random= ~Name + vsc(dsc(Env),isc(Name)) + #                       vsc(atc(Env, c(\"CA.2011\") ),isc(Block)) , #              rcov= ~ vsc(dsc(Env),isc(units)), #              data=DT) # summary(ans2b) #  # ####==========================================#### # #### Multivariate homogeneous variance models #### # ####==========================================#### #  # ## Multivariate Compound simmetry (CS) model # DT$EnvName <- paste(DT$Env,DT$Name) # ans4 <- mmer(cbind(Yield, Weight) ~ Env, #               random= ~ vsr(Name) + vsr(EnvName), #               rcov= ~ vsr(units), #               data=DT) # summary(ans4)"},{"path":"https://github.com/covaruber/sommer/reference/DT_expdesigns.html","id":null,"dir":"Reference","previous_headings":"","what":"Data for different experimental designs — DT_expdesigns","title":"Data for different experimental designs — DT_expdesigns","text":"following data list containing data frames different type experimental designs relevant plant breeding: 1) Augmented designs (2 examples) 2) Incomplete block designs (1 example) 3) Split plot design (2 examples) 4) Latin square designs (1 example) 5) North Carolina designs ,II III fit shown Examples section. may help get introduced experimental designs relevant plant breeding. Good luck.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_expdesigns.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data for different experimental designs — DT_expdesigns","text":"Different based design.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_expdesigns.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data for different experimental designs — DT_expdesigns","text":"Datasets detail can found agricolae package. just show datasets analyze using sommer package.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_expdesigns.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Data for different experimental designs — DT_expdesigns","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_expdesigns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data for different experimental designs — DT_expdesigns","text":"","code":"# #### =================================== #### # #### ===== Augmented Block Design 1 ==== #### # #### =================================== #### # data(DT_expdesigns) # DT <- DT_expdesigns # names(DT) # data1 <- DT$au1 # head(data1) # ## response variable: \"yield\" # ## check indicator: \"entryc\" ('nc' for all unreplicated, but personal.name for checks) # ## blocking factor: \"block\" # ## treatments, personal names for replicated and non-replicated: \"trt\" # ## check no check indicator: \"new\" # mix1 <- mmer(yield~entryc, #              random=~block+trt, #              rcov=~units, tolpar = 1e-6, #              data=data1) # summary(mix1)$varcomp #  # mix1b <- mmec(yield~entryc, #              random=~block+trt, #              rcov=~units, tolParConv = 1e-6, #              data=data1) # summary(mix1b)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/DT_fulldiallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Full diallel data for corn hybrids — DT_fulldiallel","title":"Full diallel data for corn hybrids — DT_fulldiallel","text":"dataset contains phenotpic data 36 winter bean hybrids, coming full diallel design evaluated 9 traits. column male female origin columns included well.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_fulldiallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Full diallel data for corn hybrids — DT_fulldiallel","text":"","code":"data(\"DT_fulldiallel\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_fulldiallel.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Full diallel data for corn hybrids — DT_fulldiallel","text":"format :  chr \"DT_fulldiallel\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_fulldiallel.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Full diallel data for corn hybrids — DT_fulldiallel","text":"data generated winter bean study originally included agridat package.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_fulldiallel.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Full diallel data for corn hybrids — DT_fulldiallel","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_fulldiallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Full diallel data for corn hybrids — DT_fulldiallel","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the #### examples are silenced with one '#' mark, #### remove them and run the examples ####=========================================#### data(DT_fulldiallel) DT <- DT_fulldiallel head(DT) #>   female male yield stems nodes pods seeds weight height width flower #> 1    G24  G24 172.8  20.5  2.99 1.45  2.91   68.7  20.05 16.04  10.38 #> 2    G31  G24 247.7  26.8  3.24 1.39  3.00   69.5  25.13 22.29  10.68 #> 3    G36  G24 267.5  26.3  3.42 1.31  3.13   75.5  23.20 20.88   7.93 #> 4    G55  G24 301.7  28.8  3.98 1.34  2.64   77.2  25.20 24.00   5.37 #> 5    G64  G24 267.5  29.7  3.34 1.27  3.15   69.8  23.97 23.67   3.35 #> 6    G67  G24 262.0  28.3  2.69 1.52  2.80   81.8  23.33 20.79  12.00 mix <- mmer(stems~1, random=~female+male, data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -15.1177   1:15:0      0           0 #>     2      -14.9349   1:15:0      0           0 #>     3      -14.8855   1:15:0      0           0 #>     4      -14.8811   1:15:0      0           0 #>     5      -14.881   1:15:0      0           0 summary(mix) #> ============================================================ #>          Multivariate Linear Mixed Model fit by REML          #> **********************  sommer 4.3  **********************  #> ============================================================ #>          logLik      AIC      BIC Method Converge #> Value -14.88101 31.76201 33.34553     NR     TRUE #> ============================================================ #> Variance-Covariance components: #>                    VarComp VarCompSE Zratio Constraint #> female.stems-stems   1.984     1.829  1.085   Positive #> male.stems-stems     1.775     1.699  1.045   Positive #> units.stems-stems    5.292     1.497  3.535   Positive #> ============================================================ #> Fixed effects: #>   Trait      Effect Estimate Std.Error t.value #> 1 stems (Intercept)    27.52    0.8795   31.29 #> ============================================================ #> Groups and observations: #>        stems #> female     6 #> male       6 #> ============================================================ #> Use the '$' sign to access results and parameters  mixb <- mmec(stems~1, random=~female+male, data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -54.4362   1:15:0      0           0 #>     2      -54.2835   1:15:0      0           0 #>     3      -54.2126   1:15:0      0           0 #>     4      -54.176   1:15:0      0           0 #>     5      -54.1604   1:15:0      0           0 #>     6      -54.1551   1:15:0      0           0 #>     7      -54.1536   1:15:0      0           0 #>     8      -54.1532   1:15:0      0           0 summary(mixb)$varcomp #>                 VarComp VarCompSE   Zratio Constraint #> female:isc:isc 1.974269  1.505941 1.310987   Positive #> male:isc:isc   1.769532  1.507346 1.173939   Positive #> units:isc:isc  5.292799  1.806661 2.929603   Positive  ####=========================================#### ####=========================================#### #### Multivariate model example ####=========================================#### ####=========================================####  data(DT_fulldiallel) DT <- DT_fulldiallel head(DT) #>   female male yield stems nodes pods seeds weight height width flower #> 1    G24  G24 172.8  20.5  2.99 1.45  2.91   68.7  20.05 16.04  10.38 #> 2    G31  G24 247.7  26.8  3.24 1.39  3.00   69.5  25.13 22.29  10.68 #> 3    G36  G24 267.5  26.3  3.42 1.31  3.13   75.5  23.20 20.88   7.93 #> 4    G55  G24 301.7  28.8  3.98 1.34  2.64   77.2  25.20 24.00   5.37 #> 5    G64  G24 267.5  29.7  3.34 1.27  3.15   69.8  23.97 23.67   3.35 #> 6    G67  G24 262.0  28.3  2.69 1.52  2.80   81.8  23.33 20.79  12.00  mix <- mmer(cbind(stems,pods,seeds)~1,              random=~vsr(female) + vsr(male),              rcov=~vsr(units),              data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -63.6729   1:15:1      1           0 #>     2      -40.8016   1:15:1      1           0 #>     3      -27.2147   1:15:1      1           0 #>     4      -24.2403   1:15:1      1           0 #>     5      -24.1945   1:15:1      1           0 #>     6      -24.194   1:15:1      1           0 summary(mix) #> ============================================================ #>          Multivariate Linear Mixed Model fit by REML          #> **********************  sommer 4.3  **********************  #> ============================================================ #>          logLik      AIC      BIC Method Converge #> Value -24.19402 54.38805 62.43444     NR     TRUE #> ============================================================ #> Variance-Covariance components: #>                        VarComp VarCompSE  Zratio Constraint #> u:female.stems-stems  1.983920  1.829197  1.0846   Positive #> u:female.stems-pods   0.047557  0.056891  0.8359   Unconstr #> u:female.stems-seeds -0.202772  0.156026 -1.2996   Unconstr #> u:female.pods-pods    0.003453  0.003268  1.0565   Positive #> u:female.pods-seeds  -0.007714  0.006429 -1.1998   Unconstr #> u:female.seeds-seeds  0.027291  0.018584  1.4686   Positive #> u:male.stems-stems    1.775485  1.698746  1.0452   Positive #> u:male.stems-pods     0.030613  0.061605  0.4969   Unconstr #> u:male.stems-seeds   -0.171257  0.162701 -1.0526   Unconstr #> u:male.pods-pods      0.005240  0.004390  1.1938   Positive #> u:male.pods-seeds    -0.006019  0.007864 -0.7654   Unconstr #> u:male.seeds-seeds    0.037802  0.025226  1.4985   Positive #> u:units.stems-stems   5.291650  1.496464  3.5361   Positive #> u:units.stems-pods   -0.077067  0.048449 -1.5907   Unconstr #> u:units.stems-seeds   0.059026  0.052802  1.1179   Unconstr #> u:units.pods-pods     0.009972  0.002820  3.5360   Positive #> u:units.pods-seeds    0.001446  0.002253  0.6417   Unconstr #> u:units.seeds-seeds   0.012510  0.003540  3.5343   Positive #> ============================================================ #> Fixed effects: #>   Trait      Effect Estimate Std.Error t.value #> 1 stems (Intercept)   27.519   0.87952   31.29 #> 2  pods (Intercept)    1.336   0.04154   32.17 #> 3 seeds (Intercept)    2.855   0.10581   26.98 #> ============================================================ #> Groups and observations: #>          stems pods seeds #> u:female     6    6     6 #> u:male       6    6     6 #> ============================================================ #> Use the '$' sign to access results and parameters #### genetic variance covariance cov2cor(mix$sigma$`u:female`) #>            stems       pods      seeds #> stems  1.0000000  0.5745963 -0.8714338 #> pods   0.5745963  1.0000000 -0.7946327 #> seeds -0.8714338 -0.7946327  1.0000000 cov2cor(mix$sigma$`u:male`) #>            stems       pods      seeds #> stems  1.0000000  0.3173646 -0.6610472 #> pods   0.3173646  1.0000000 -0.4276277 #> seeds -0.6610472 -0.4276277  1.0000000 cov2cor(mix$sigma$`u:units`) #>            stems       pods     seeds #> stems  1.0000000 -0.3354943 0.2294149 #> pods  -0.3354943  1.0000000 0.1294200 #> seeds  0.2294149  0.1294200 1.0000000"},{"path":"https://github.com/covaruber/sommer/reference/DT_gryphon.html","id":null,"dir":"Reference","previous_headings":"","what":"Gryphon data from the Journal of Animal Ecology — DT_gryphon","title":"Gryphon data from the Journal of Animal Ecology — DT_gryphon","text":"dataset included Journal animal ecology Wilson et al. (2010; see references) help users understand use mixed models animal datasets pedigree data. dataset contains 3 elements: gryphon; variables indicating animal, mother animal, sex animal, two quantitative traits named 'BWT' 'TARSUS'. pedi; dataset 2 columns indicating sire dam animals contained gryphon dataset. ; additive relationship matrix formed using 'getA()' function used pedi dataframe.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_gryphon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gryphon data from the Journal of Animal Ecology — DT_gryphon","text":"","code":"data(\"DT_gryphon\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_gryphon.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Gryphon data from the Journal of Animal Ecology — DT_gryphon","text":"format :  chr \"DT_gryphon\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_gryphon.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Gryphon data from the Journal of Animal Ecology — DT_gryphon","text":"data comes Journal Animal Ecology. Please, using data cite Wilson et al. publication. using mixed model solver please cite Covarrubias' publication.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_gryphon.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gryphon data from the Journal of Animal Ecology — DT_gryphon","text":"Wilson AJ, et al. (2010) ecologist's guide animal model. Journal Animal Ecology 79(1): 13-26. Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_gryphon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gryphon data from the Journal of Animal Ecology — DT_gryphon","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples using #### command + shift + C |OR| control + shift + C ####=========================================#### # data(DT_gryphon) # DT <- DT_gryphon # A <- A_gryphon # P <- P_gryphon # #### look at the data # head(DT) # #### fit the model with no fixed effects (intercept only) # mix1 <- mmer(BWT~1, #              random=~vsr(ANIMAL,Gu=A), #              rcov=~units, #              data=DT) # summary(mix1)$varcomp #  # ## mmec uses the inverse of the relationship matrix # Ai <- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class=\"dgCMatrix\") # mix1b <- mmec(BWT~1, #              random=~vsc(isc(ANIMAL),Gu=Ai), #              rcov=~units, tolParConv = 1e-5, #              data=DT) # summary(mix1b)$varcomp #  # #### fit the multivariate model with no fixed effects (intercept only) # mix2 <- mmer(cbind(BWT,TARSUS)~1, #              random=~vsr(ANIMAL,Gu=A), #              rcov=~vsr(units), #              na.method.Y = \"include2\", #              data=DT) # summary(mix2) # cov2cor(mix2$sigma$`u:ANIMAL`) # cov2cor(mix2$sigma$`u:units`)"},{"path":"https://github.com/covaruber/sommer/reference/DT_h2.html","id":null,"dir":"Reference","previous_headings":"","what":"Broad sense heritability calculation. — DT_h2","title":"Broad sense heritability calculation. — DT_h2","text":"dataset contains phenotpic data 41 potato lines evaluated 5 locations across 3 years RCBD design. phenotypic trait tuber quality show obtain estimate DT_h2 trait.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_h2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broad sense heritability calculation. — DT_h2","text":"","code":"data(\"DT_h2\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_h2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Broad sense heritability calculation. — DT_h2","text":"format :  chr \"DT_h2\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_h2.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Broad sense heritability calculation. — DT_h2","text":"data generated potato study.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_h2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Broad sense heritability calculation. — DT_h2","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_h2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Broad sense heritability calculation. — DT_h2","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================#### data(DT_h2) DT <- DT_h2 head(DT) #>                 Name     Env Loc Year     Block y #> 1            W8822-3 FL.2012  FL 2012 FL.2012.1 2 #> 2            W8867-7 FL.2012  FL 2012 FL.2012.2 2 #> 3           MSL007-B MO.2011  MO 2011 MO.2011.1 3 #> 4         CO00270-7W FL.2012  FL 2012 FL.2012.2 3 #> 5 Manistee(MSL292-A) FL.2013  FL 2013 FL.2013.2 3 #> 6           MSM246-B FL.2012  FL 2012 FL.2012.2 3 ####=========================================#### #### fit the mixed model (very heavy model) ####=========================================#### # ans1 <- mmer(y~Env, #               random=~vsr(dsr(Env),Name) + vsr(dsr(Env),Block), #               rcov=~vsr(dsr(Env),units), #               data=DT) # summary(ans1)$varcomp #  # DT=DT[with(DT, order(Env)), ] # ans1b <- mmec(y~Env, #              random=~vsc(dsc(Env),isc(Name)) + vsc(dsc(Env),isc(Block)), #              rcov=~vsc(dsc(Env),isc(units)), #              data=DT) # summary(ans1b)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/DT_halfdiallel.html","id":null,"dir":"Reference","previous_headings":"","what":"half diallel data for corn hybrids — DT_halfdiallel","title":"half diallel data for corn hybrids — DT_halfdiallel","text":"dataset contains phenotpic data 21 corn hybrids, 2 technical repetitions, coming half diallel design evaluated sugar content. column geno indicates hybrid male female origin columns included well.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_halfdiallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"half diallel data for corn hybrids — DT_halfdiallel","text":"","code":"data(\"DT_halfdiallel\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_halfdiallel.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"half diallel data for corn hybrids — DT_halfdiallel","text":"format :  chr \"DT_halfdiallel\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_halfdiallel.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"half diallel data for corn hybrids — DT_halfdiallel","text":"data generated corn study.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_halfdiallel.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"half diallel data for corn hybrids — DT_halfdiallel","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_halfdiallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"half diallel data for corn hybrids — DT_halfdiallel","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================####  data(\"DT_halfdiallel\") DT <- DT_halfdiallel head(DT) #>   rep geno male female     sugar #> 1   1   12    1      2 13.950509 #> 2   2   12    1      2  9.756918 #> 3   1   13    1      3 13.906355 #> 4   2   13    1      3  9.119455 #> 5   1   14    1      4  5.174483 #> 6   2   14    1      4  8.452221 DT$femalef <- as.factor(DT$female) DT$malef <- as.factor(DT$male) DT$genof <- as.factor(DT$geno)  A <- diag(7); colnames(A) <- rownames(A) <- 1:7;A # if you want to provide a covariance matrix #>   1 2 3 4 5 6 7 #> 1 1 0 0 0 0 0 0 #> 2 0 1 0 0 0 0 0 #> 3 0 0 1 0 0 0 0 #> 4 0 0 0 1 0 0 0 #> 5 0 0 0 0 1 0 0 #> 6 0 0 0 0 0 1 0 #> 7 0 0 0 0 0 0 1 #### model using overlay modh <- mmer(sugar~1,               random=~vsr(overlay(femalef,malef, sparse = FALSE), Gu=A)               + genof,              data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -10.425   1:15:1      0           0 #>     2      -6.487   1:15:1      0           0 #>     3      -5.732   1:15:1      0           0 #>     4      -5.67494   1:15:1      0           0 #>     5      -5.67441   1:15:1      0           0 summary(modh)$varcomp #>                              VarComp VarCompSE   Zratio Constraint #> u:femalef:malef.sugar-sugar 5.507899 3.5741151 1.541052   Positive #> genof.sugar-sugar           1.815784 1.3629575 1.332238   Positive #> units.sugar-sugar           3.117538 0.9626094 3.238632   Positive  Ai <- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class=\"dgCMatrix\") modhb <- mmec(sugar~1,               random=~vsc(isc(overlay(femalef,malef, sparse = TRUE)), Gu=Ai)               + genof,              data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -66.9631   1:15:1      0           0 #>     2      -62.779   1:15:1      0           0 #>     3      -60.5877   1:15:1      0           0 #>     4      -60.1123   1:15:1      0           0 #>     5      -60.0669   1:15:1      0           0 #>     6      -60.0549   1:15:1      0           0 #>     7      -60.05   1:15:1      0           0 #>     8      -60.0481   1:15:1      0           0 #>     9      -60.0473   1:15:1      0           0 summary(modhb)$varcomp #>                           VarComp VarCompSE   Zratio Constraint #> femalef:malef:Ai:isc:isc 5.421024  1.956277 2.771092   Positive #> genof:isc:isc            1.815385  2.972937 0.610637   Positive #> units:isc:isc            3.119559  2.997912 1.040577   Positive"},{"path":"https://github.com/covaruber/sommer/reference/DT_ige.html","id":null,"dir":"Reference","previous_headings":"","what":"Data to fit indirect genetic effects. — DT_ige","title":"Data to fit indirect genetic effects. — DT_ige","text":"dataset contains phenotpic data 98 individuals measured purpose identifying effect neighbour focal individual.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_ige.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data to fit indirect genetic effects. — DT_ige","text":"","code":"data(\"DT_ige\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_ige.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data to fit indirect genetic effects. — DT_ige","text":"format :  chr \"DT_ige\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_ige.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data to fit indirect genetic effects. — DT_ige","text":"data masked shared study.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_ige.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Data to fit indirect genetic effects. — DT_ige","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_ige.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data to fit indirect genetic effects. — DT_ige","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================#### ####=========================================#### #### EXAMPLES #### Different models with sommer ####=========================================####  data(DT_ige) DT <- DT_ige # # Indirect genetic effects model without covariance between DGE and IGE # modIGE <- mmec(trait ~ block, dateWarning = FALSE, #                random = ~ focal + neighbour, #                rcov = ~ units, nIters=100, #               data = DT) # summary(modIGE)$varcomp # pmonitor(modIGE) #  # # Indirect genetic effects model with covariance between DGE and IGE using relationship matrices # modIGE <- mmec(trait ~ block, dateWarning = FALSE, #                random = ~ covc( vsc(isc(focal)), vsc(isc(neighbour)) ), #                rcov = ~ units, nIters=100, #               data = DT) # summary(modIGE)$varcomp # pmonitor(modIGE) #  # # form relationship matrix # Ai <- as( solve(A_ige + diag(1e-5, nrow(A_ige),nrow(A_ige) )), Class=\"dgCMatrix\") # # Indirect genetic effects model with covariance between DGE and IGE using relationship matrices # modIGE <- mmec(trait ~ block, dateWarning = FALSE, #                random = ~ covc( vsc(isc(focal), Gu=Ai), vsc(isc(neighbour), Gu=Ai) ), #                rcov = ~ units, nIters=100, #               data = DT) # summary(modIGE)$varcomp # pmonitor(modIGE)"},{"path":"https://github.com/covaruber/sommer/reference/DT_legendre.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated data for random regression — DT_legendre","title":"Simulated data for random regression — DT_legendre","text":"data frame 4 columns; SUBJECT, X, Xf Y show use Legendre polynomials mmer function using numeric variable X response variable Y.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_legendre.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated data for random regression — DT_legendre","text":"","code":"data(\"DT_legendre\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_legendre.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated data for random regression — DT_legendre","text":"format :  chr \"DT_legendre\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_legendre.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Simulated data for random regression — DT_legendre","text":"data simulated fruit breeding applications.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_legendre.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulated data for random regression — DT_legendre","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_legendre.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulated data for random regression — DT_legendre","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples using #### command + shift + C |OR| control + shift + C ####=========================================#### # you need to install the orthopolynom library to do random regression models # library(orthopolynom) # data(DT_legendre) # DT <- DT_legendre # mRR2<-mmer(Y~ 1 + Xf #            , random=~ vsr(usr(leg(X,1)),SUBJECT) #            , rcov=~vsr(units) #            , data=DT) # summary(mRR2)$varcomp #  # mRR2b<-mmec(Y~ 1 + Xf #            , random=~ vsc(usc(leg(X,1)),isc(SUBJECT)) #            , rcov=~vsc(isc(units)) #            , data=DT) # summary(mRR2b)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/DT_mohring.html","id":null,"dir":"Reference","previous_headings":"","what":"Full diallel data for corn hybrids — DT_mohring","title":"Full diallel data for corn hybrids — DT_mohring","text":"dataset contains phenotpic data 36 winter bean hybrids, coming full diallel design evaluated 9 traits. column male female origin columns included well.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_mohring.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Full diallel data for corn hybrids — DT_mohring","text":"","code":"data(\"DT_mohring\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_mohring.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Full diallel data for corn hybrids — DT_mohring","text":"format :  chr \"DT_mohring\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_mohring.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Full diallel data for corn hybrids — DT_mohring","text":"data generated winter bean study originally included agridat package.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_mohring.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Full diallel data for corn hybrids — DT_mohring","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_mohring.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Full diallel data for corn hybrids — DT_mohring","text":"","code":"# ####=========================================#### # #### For CRAN time limitations most lines in the # #### examples are silenced with one '#' mark, # #### remove them and run the examples # ####=========================================#### # data(DT_mohring) # DT <- DT_mohring # head(DT) # DT2 <- add.diallel.vars(DT,par1=\"Par1\", par2=\"Par2\") # head(DT2) # # is.cross denotes a hybrid (1) # # is.self denotes an inbred (1) # # cross.type denotes one way (-1, e.g. AxB) and reciprocal (1, e.g., BxA) and no cross (0) # # cross.id denotes the name of the cross (same name for direct & reciprocal) # # # GRIFFING MODEL 2 with reciprocal effects ########################### # mod1h <- mmer(Ftime ~ 1, data=DT2, #               random = ~ Block #               # GCA male & female overlayed #               + overlay(Par1, Par2) #               # SCA effects (includes cross and selfs) #               + cross.id #               # SCAR reciprocal effects (remaining variance in crosses;  #               # if zero there's no reciprocal effects) #               + cross.id:cross.type) # summary(mod1h)$varcomp # # mod1hb <- mmec(Ftime ~ 1, data=DT2, #                random = ~ Block #                # GCA male & female overlayed #                + vsc(isc(overlay(Par1, Par2))) #                # SCA effects (includes cross and selfs) #                + cross.id #                # SCAR reciprocal effects (remaining variance in crosses;  #                # if zero there's no reciprocal effects) #                + vsc(dsc(cross.type), isc(cross.id)) ) # summary(mod1hb)$varcomp # # ##                                    VarComp VarCompSE   Zratio # ## Block.Ftime-Ftime                  0.00000   9.32181 0.000000 # ## overlay(Par1, Par2).Ftime-Ftime 1276.73089 750.17269 1.701916 # ## cross.id.Ftime-Ftime            1110.99090 330.16921 3.364914 # ## cross.id:cross.type.Ftime-Ftime   66.02295  49.26876 1.340057 # ## units.Ftime-Ftime                418.47949  74.56442 5.612321 # ## # # GRIFFING MODEL 2, no reciprocal effects ############################## # mod1h <- mmer(Ftime ~ Block + is.cross, data=DT2, #               random = ~ #                # GCA effect for all (hybrids and inbreds) #                 overlay(Par1, Par2) #               # GCA effect (calculated only in hybrids; remaining variance) #               + overlay(Par1, Par2):is.cross #               # SCA effect (calculated in hybrids only) #               + cross.id:is.cross) # summary(mod1h)$varcomp # # mod1h <- mmec(Ftime ~ Block + is.cross, data=DT2, nIters = 50, #               random = ~ #                 # GCA effects for all (hybrids and inbreds) #                 vsc(isc(overlay(Par1, Par2))) #               # GCA effect (calculated only in hybrids; remaining variance) #               + vsc(isc(is.cross),isc(overlay(Par1, Par2))) #               # SCA effect (calculated in hybrids only) #               + vsc(isc(is.cross), isc(cross.id)) #               ) # summary(mod1h)$varcomp # # ##                                           VarComp  VarCompSE   Zratio # ## overlay(Par1, Par2).Ftime-Ftime          2304.1781 1261.63193 1.826347 # ## overlay(Par1, Par2):is.cross.Ftime-Ftime  613.6040  402.74347 1.523560 # ## cross.id:is.cross.Ftime-Ftime             340.7030  148.56225 2.293335 # ## units.Ftime-Ftime                         501.6275   74.36075 6.745864 # ## # # GRIFFING MODEL 3, no reciprocal effects ############################### # mod1h <- mmer(Ftime ~ Block + is.cross, data=DT2, #               random = ~ #                 # GCAC (only for hybrids) #                 overlay(Par1, Par2):is.cross #               # male GCA (only for inbreds) #               + Par1:is.self #               # SCA (for hybrids only) #               + cross.id:is.cross) # summary(mod1h)$varcomp # # mod1h <- mmec(Ftime ~ Block + is.cross, data=DT2, nIters = 100, #               random = ~ #                 # GCAC (only for hybrids) #                 vsc(isc(is.cross),isc(overlay(Par1, Par2))) #               # male GCA (only for inbreds) #               + vsc(isc(is.self),isc(Par1)) #               # SCA (for hybrids only) #               + vsc(isc(is.cross), isc(cross.id)) #               ) # summary(mod1h)$varcomp # ##                                           VarComp  VarCompSE   Zratio # ## overlay(Par1, Par2):is.cross.Ftime-Ftime  927.7895  537.91218 1.724797 # ## Par1:is.self.Ftime-Ftime                 9960.9247 5456.58188 1.825488 # ## cross.id:is.cross.Ftime-Ftime             341.4567  148.53667 2.298804 # ## units.Ftime-Ftime                         498.5974   73.92066 6.745035 # ## # # GRIFFING MODEL 2, with reciprocal effects ############################# # # In Mohring: mixed model 3 reduced # mod1h <- mmer(Ftime ~ Block + is.cross, data=DT2, #               random = ~ #                 # GCAC (for hybrids only) #                 overlay(Par1, Par2):is.cross #               # male GCA (for selfs only) #               + Par1:is.self #               # SCA (for hybrids only) #               + cross.id:is.cross #               # SCAR reciprocal effects (remaning SCA variance) #               + cross.id:cross.type) # summary(mod1h)$varcomp # # mod1h <- mmec(Ftime ~ Block + is.cross, data=DT2, nIters = 100, #               random = ~ #                 # GCAC (for hybrids only) #                 vsc(isc(is.cross),isc(overlay(Par1, Par2))) #               # male GCA (for selfs only) #               + vsc(isc(is.self),isc(Par1)) #               # SCA (for hybrids only) #               + vsc(isc(is.cross), isc(cross.id)) #               # SCAR reciprocal effects (remaning SCA variance) #               + vsc(isc(cross.type), isc(cross.id)) #               ) # summary(mod1h)$varcomp # # ##                                             VarComp  VarCompSE   Zratio # ## overlay(Par1, Par2):is.cross.Ftime-Ftime   927.78742  537.89981 1.724833 # ## Par1:is.self.Ftime-Ftime                 10001.78854 5456.47578 1.833013 # ## cross.id:is.cross.Ftime-Ftime              361.89712  148.54264 2.436318 # ## cross.id:cross.type.Ftime-Ftime             66.43695   49.24492 1.349113 # ## units.Ftime-Ftime                          416.82960   74.27202 5.612203 # ## # # GRIFFING MODEL 3, with RGCA + RSCA #################################### # # In Mohring: mixed model 3 # mod1h <- mmer(Ftime ~ Block + is.cross, data=DT2, #               random = ~ #                 # GCAC (for hybrids only) #                 overlay(Par1,Par2):is.cross #               # RGCA: exclude selfs (to identify reciprocal GCA effects) #               + overlay(Par1,Par2):cross.type #               # male GCA (for selfs only) #               + Par1:is.self #               # SCA (for hybrids only) #               + cross.id:is.cross #               # SCAR: exclude selfs (if zero there's no reciprocal SCA effects) #               + cross.id:cross.type) # summary(mod1h)$varcomp # # mod1h <- mmec(Ftime ~ Block + is.cross, data=DT2,nIters = 100, #               random = ~ #                 # GCAC (for hybrids only) #                 vsc(isc(is.cross),isc(overlay(Par1, Par2))) #               # RGCA: exclude selfs (to identify reciprocal GCA effects) #               + vsc(isc(cross.type),isc(overlay(Par1, Par2))) #               # male GCA (for selfs only) #               + vsc(isc(is.self),isc(Par1)) #               # SCA (for hybrids only) #               + vsc(isc(is.cross), isc(cross.id)) #               # SCAR: exclude selfs (if zero there's no reciprocal SCA effects) #               + vsc(isc(cross.type), isc(cross.id)) #               ) # summary(mod1h)$varcomp # # ##                                            VarComp  VarCompSE    Zratio # ## overlay(Par1, Par2):is.cross.Ftime-Ftime   927.7843  537.88164 1.7248857 # ## Par1:is.self.Ftime-Ftime                 10001.7570 5456.30125 1.8330654 # ## cross.id:is.cross.Ftime-Ftime              361.8958  148.53670 2.4364068 # ## overlay(Par1, Par2):cross.type.Ftime-Ftime  17.9799   19.92428 0.9024114 # ## cross.id:cross.type.Ftime-Ftime             30.9519   46.43908 0.6665054 # ## units.Ftime-Ftime                         416.09922  447.2101 0.93043333"},{"path":"https://github.com/covaruber/sommer/reference/DT_polyploid.html","id":null,"dir":"Reference","previous_headings":"","what":"Genotypic and Phenotypic data for a potato polyploid population — DT_polyploid","title":"Genotypic and Phenotypic data for a potato polyploid population — DT_polyploid","text":"dataset contains phenotpic data 18 traits measured 187 individuals potato diversity panel. addition contains genotypic data 221 individuals genotyped 3522 SNP markers. Please using data research make sure cite Rosyara's (2015) publication (see References).","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_polyploid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Genotypic and Phenotypic data for a potato polyploid population — DT_polyploid","text":"","code":"data(\"DT_polyploid\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_polyploid.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Genotypic and Phenotypic data for a potato polyploid population — DT_polyploid","text":"format :  chr \"DT_polyploid\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_polyploid.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Genotypic and Phenotypic data for a potato polyploid population — DT_polyploid","text":"data extracted Rosyara (2016).","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_polyploid.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Genotypic and Phenotypic data for a potato polyploid population — DT_polyploid","text":"using data research please cite: Rosyara Umesh R., Walter S. De Jong, David S. Douches, Jeffrey B. Endelman. Software genome-wide association studies autopolyploids application potato. Plant Genome 2015. Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_polyploid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genotypic and Phenotypic data for a potato polyploid population — DT_polyploid","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples using #### command + shift + C |OR| control + shift + C ####=========================================####  data(DT_polyploid) # DT <- DT_polyploid # GT <- GT_polyploid # MP <- MP_polyploid # ####=========================================#### # ####### convert markers to numeric format # ####=========================================#### # numo <- atcg1234(data=GT, ploidy=4); # numo$M[1:5,1:5]; # numo$ref.allele[,1:5] #  # ###=========================================#### # ###### plants with both genotypes and phenotypes # ###=========================================#### # common <- intersect(DT$Name,rownames(numo$M)) #  # ###=========================================#### # ### get the markers and phenotypes for such inds # ###=========================================#### # marks <- numo$M[common,]; marks[1:5,1:5] # DT2 <- DT[match(common,DT$Name),]; # DT2 <- as.data.frame(DT2) # DT2[1:5,] #  # ###=========================================#### # ###### Additive relationship matrix, specify ploidy # ###=========================================#### # A <- A.mat(marks) # D <- D.mat(marks) # ###=========================================#### # ### run as mixed model # ###=========================================#### # ans <- mmer(tuber_shape~1, #             random=~vsr(Name, Gu=A), #             data=DT2) # summary(ans)$varcomp #  # Ai <- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class=\"dgCMatrix\") # ansb <- mmec(tuber_shape~1, #             random=~vsc(isc(Name), Gu=Ai), #             data=DT2) # summary(ansb)$varcomp #"},{"path":"https://github.com/covaruber/sommer/reference/DT_rice.html","id":null,"dir":"Reference","previous_headings":"","what":"Rice lines dataset — DT_rice","title":"Rice lines dataset — DT_rice","text":"Information collection 413 rice lines.  DT_rice data set Rice Diversity Org. Program. lines genotyped 36,901 SNP markers phenotyped 30 traits. data set included package play . using research make sure cite original publication Zhao et al.(2011).","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_rice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rice lines dataset — DT_rice","text":"","code":"data(DT_rice)"},{"path":"https://github.com/covaruber/sommer/reference/DT_rice.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rice lines dataset — DT_rice","text":"RicePheno contains phenotypes  RiceGeno contains genotypes letter code  RiceGenoN contains genotypes numerical code using atcg1234 converter function","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_rice.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rice lines dataset — DT_rice","text":"Rice Diversity Organization   http://www.ricediversity.org/data/index.cfm.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_rice.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rice lines dataset — DT_rice","text":"Keyan Zhao, Chih-Wei Tung, Georgia C. Eizenga, Mark H. Wright, M. Liakat Ali, Adam H. Price, Gareth J. Norton, M. Rafiqul Islam, Andy Reynolds, Jason Mezey, Anna M. McClung, Carlos D. Bustamante & Susan R. McCouch (2011). Genome-wide association mapping reveals rich genetic architecture complex traits Oryza sativa. Nat Comm 2:467 DOI: 10.1038/ncomms1467, Published Online 13 Sep 2011.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_rice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rice lines dataset — DT_rice","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples using #### command + shift + C |OR| control + shift + C ####=========================================#### data(DT_rice) # DT <- DT_rice # GT <- GT_rice # GTn <- GTn_rice # head(DT) # M <- atcg1234(GT) # A <- A.mat(M$M) # mix <- mmer(Protein.content~1, #             random = ~vsr(geno, Gu=A) + geno, #             rcov=~units, #             data=DT) # summary(mix)$varcomp #  # Ai <- as(solve(A + diag(1e-6,ncol(A),ncol(A))), Class=\"dgCMatrix\") # mixb <- mmec(Protein.content~1, #             random = ~vsc(isc(geno), Gu=Ai) + geno, #             rcov=~units, #             data=DT) # summary(mixb)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/DT_sleepstudy.html","id":null,"dir":"Reference","previous_headings":"","what":"Reaction times in a sleep deprivation study — DT_sleepstudy","title":"Reaction times in a sleep deprivation study — DT_sleepstudy","text":"average reaction time per day subjects sleep deprivation study. day 0 subjects normal amount sleep. Starting night restricted 3 hours sleep per night. observations represent average reaction time series tests given day subject. Data sleepstudy see lme4 models can translated sommer.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_sleepstudy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reaction times in a sleep deprivation study — DT_sleepstudy","text":"","code":"data(\"DT_sleepstudy\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_sleepstudy.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Reaction times in a sleep deprivation study — DT_sleepstudy","text":"format :  chr \"DT_sleepstudy\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_sleepstudy.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Reaction times in a sleep deprivation study — DT_sleepstudy","text":"data study described Belenky et al. (2003), sleep deprived group first 10 days study, recovery period.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_sleepstudy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Reaction times in a sleep deprivation study — DT_sleepstudy","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Gregory Belenky et al. (2003) Patterns performance degradation restoration sleep restrictions subsequent recovery: sleep dose-response study. Journal Sleep Research 12, 1-12.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_sleepstudy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reaction times in a sleep deprivation study — DT_sleepstudy","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the #### examples are silenced with one '#' mark, #### remove them and run the examples ####=========================================#### # library(lme4) data(DT_sleepstudy) DT <- DT_sleepstudy head(DT) #>   Reaction Days Subject Subjectf Daysf #> 1 249.5600    0     308      308     0 #> 2 258.7047    1     308      308     1 #> 3 250.8006    2     308      308     2 #> 4 321.4398    3     308      308     3 #> 5 356.8519    4     308      308     4 #> 6 414.6901    5     308      308     5 ################################## ## lme4 # fm1 <- lmer(Reaction ~ Days + (1 | Subject), data=DT) # vc <- VarCorr(fm1); print(vc,comp=c(\"Variance\")) ## sommer fm2 <- mmer(Reaction ~ Days,             random= ~ Subject,              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp #>                             VarComp VarCompSE   Zratio Constraint #> Subject.Reaction-Reaction 1377.9758  505.0776 2.728246   Positive #> units.Reaction-Reaction    960.4705  107.0638 8.971013   Positive  ################################## ## lme4 # fm1 <- lmer(Reaction ~ Days + (Days || Subject), data=DT) # vc <- VarCorr(fm1); print(vc,comp=c(\"Variance\")) ## sommer fm2 <- mmer(Reaction ~ Days,             random= ~ Subject + vsr(Days, Subject),              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp #>                                  VarComp VarCompSE   Zratio Constraint #> Subject.Reaction-Reaction      627.54087 283.52939 2.213319   Positive #> Days:Subject.Reaction-Reaction  35.86008  14.53187 2.467686   Positive #> units.Reaction-Reaction        653.58305  76.72711 8.518281   Positive  ################################## ## lme4 # fm1 <- lmer(Reaction ~ Days + (Days | Subject), data=DT) # vc <- VarCorr(fm1); print(vc,comp=c(\"Variance\")) ## sommer ## no equivalence in sommer to find the correlation between the 2 vc ## this is the most similar which is equivalent to (intercept || slope) fm2 <- mmer(Reaction ~ Days,             random= ~ Subject + vsr(Days, Subject),              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp #>                                  VarComp VarCompSE   Zratio Constraint #> Subject.Reaction-Reaction      627.54087 283.52939 2.213319   Positive #> Days:Subject.Reaction-Reaction  35.86008  14.53187 2.467686   Positive #> units.Reaction-Reaction        653.58305  76.72711 8.518281   Positive  ################################## ## lme4 # fm1 <- lmer(Reaction ~ Days + (0 + Days | Subject), data=DT) # vc <- VarCorr(fm1); print(vc,comp=c(\"Variance\")) ## sommer fm2 <- mmer(Reaction ~ Days,             random= ~ vsr(Days, Subject),              data=DT, tolParInv = 1e-6, verbose = FALSE) summary(fm2)$varcomp #>                                  VarComp VarCompSE   Zratio Constraint #> Days:Subject.Reaction-Reaction  52.70946  19.09984 2.759681   Positive #> units.Reaction-Reaction        842.02736  93.84640 8.972399   Positive"},{"path":"https://github.com/covaruber/sommer/reference/DT_technow.html","id":null,"dir":"Reference","previous_headings":"","what":"Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014) — DT_technow","title":"Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014) — DT_technow","text":"dataset contains phenotpic data 2 traits measured 1254 single cross hybrids coming cross Flint x Dent heterotic groups. addition contains genotipic data (35,478 markers) 123 Dent lines 86 Flint lines. purpose data demosntrate prediction unrealized crosses (9324 unrealized crosses, 1254 evaluated, total 10578 single crosses). added additive relationship matrix () can easily obtained using .mat function marker data. Please using data research cite Technow et al. (2014) publication (see References).","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_technow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014) — DT_technow","text":"","code":"data(\"DT_technow\")"},{"path":"https://github.com/covaruber/sommer/reference/DT_technow.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014) — DT_technow","text":"format :  chr \"DT_technow\"","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_technow.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014) — DT_technow","text":"data extracted Technow et al. (2014).","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_technow.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014) — DT_technow","text":"using data research please cite: Technow et al. 2014. Genome properties prospects genomic predictions hybrid performance Breeding program maize. Genetics 197:1343-1355. Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_technow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014) — DT_technow","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples using #### command + shift + C |OR| control + shift + C ####=========================================#### data(DT_technow) DT <- DT_technow Md <- Md_technow Mf <- Mf_technow # Md <- (Md*2) - 1 # Mf <- (Mf*2) - 1 # Ad <- A.mat(Md) # Af <- A.mat(Mf) # ###=========================================#### # ###=========================================#### # ans2 <- mmer(GY~1, #              random=~vsr(dent,Gu=Ad) + vsr(flint,Gu=Af), #              rcov=~units, #              data=DT) # summary(ans2)$varcomp #  # Adi <- as(solve(Ad + diag(1e-4,ncol(Ad),ncol(Ad))), Class=\"dgCMatrix\") # Afi <- as(solve(Af + diag(1e-4,ncol(Af),ncol(Af))), Class=\"dgCMatrix\") # ans2b <- mmec(GY~1, #              random=~vsc(isc(dent),Gu=Adi) + vsc(isc(flint),Gu=Afi), #              rcov=~units, #              data=DT) # summary(ans2b)$varcomp # ####=========================================#### # #### multivariate overlayed model # ####=========================================#### # M <- rbind(Md,Mf) # A <- A.mat(M) # ans3 <- mmer(cbind(GY,GM)~1, #              random=~vsr(overlay(dent,flint),Gu=A), #              rcov=~vsr(units,Gtc=diag(2)), #              data=DT) # summary(ans2) # cov2cor(ans3$sigma[[1]])"},{"path":"https://github.com/covaruber/sommer/reference/DT_wheat.html","id":null,"dir":"Reference","previous_headings":"","what":"wheat lines dataset — DT_wheat","title":"wheat lines dataset — DT_wheat","text":"Information collection 599 historical CIMMYT wheat lines.  wheat data set CIMMYT's Global Wheat Program. Historically, program conducted numerous international trials across wide variety wheat-producing environments. environments represented trials grouped four basic target sets environments comprising four main agroclimatic regions previously defined widely used CIMMYT's Global Wheat Breeding Program. phenotypic trait considered average grain yield (GY) 599 wheat lines evaluated four mega-environments. pedigree tracing back many generations available, Browse application International Crop Information System (ICIS), described  (McLaren et al. 2000, 2005) used deriving relationship matrix among 599 lines; accounts selection inbreeding. Wheat lines recently genotyped using 1447 Diversity Array Technology (DArT) generated Triticarte Pty. Ltd. (Canberra, Australia; http://www.triticarte.com.au). DArT markers may take two values, denoted presence absence. Markers minor allele frequency lower 0.05 removed, missing genotypes imputed samples marginal distribution marker genotypes, , \\(x_{ij}=Bernoulli(\\hat p_j)\\),  \\(\\hat p_j\\) estimated allele frequency computed non-missing genotypes. number DArT MMs edition 1279.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_wheat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"wheat lines dataset — DT_wheat","text":"","code":"data(DT_wheat)"},{"path":"https://github.com/covaruber/sommer/reference/DT_wheat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"wheat lines dataset — DT_wheat","text":"Matrix Y contains average grain yield, column 1: Grain yield environment 1 .","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_wheat.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"wheat lines dataset — DT_wheat","text":"International Maize Wheat Improvement Center (CIMMYT), Mexico.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_wheat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"wheat lines dataset — DT_wheat","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 McLaren, C. G., L. Ramos, C. Lopez, W. Eusebio. 2000. “Applications geneaology manegment system.” International Crop Information System. Technical  Development Manual, version VI, edited McLaren, C. G., J.W. White P.N. Fox. pp. 5.8-5.13. CIMMyT, Mexico: CIMMyT IRRI. McLaren, C. G., R. Bruskiewich, .M. Portugal, .B. Cosico. 2005. International Rice Information System. platform meta-analysis rice crop data. Plant Physiology 139: 637-642.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/DT_wheat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"wheat lines dataset — DT_wheat","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples using #### command + shift + C |OR| control + shift + C ####=========================================#### # data(DT_wheat) # DT <- DT_wheat # GT <- GT_wheat # DTlong <- data.frame(pheno=as.vector(DT),  #                      env=sort(rep(1:4,nrow(DT))),  #                      id=rep(rownames(DT),4)) # DT <- as.data.frame(DT);colnames(DT) <- paste0(\"x\",1:4);DT$line <- rownames(DT); # rownames(GT) <- DT$line # K <- A.mat(GT) # additive relationship matrix # K[1:4,1:4] # ###=========================================#### # ###=========================================#### # ### using formula based 'mmer' # ###=========================================#### # ###=========================================#### # head(DT) # #### univariate # mix0 <- mmer(x1~1, #              random = ~vsr(line,Gu=K), #              rcov=~units, #              data=DT) # summary(mix0)$varcomp #  # Ki <- as(solve(K + diag(1e-4,ncol(K),ncol(K))), Class=\"dgCMatrix\") # mix0b <- mmec(x1~1, #              random = ~vsc(isc(line),Gu=Ki), #              rcov=~units, #              data=DT) # summary(mix0b)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/DT_yatesoats.html","id":null,"dir":"Reference","previous_headings":"","what":"Yield of oats in a split-block experiment — DT_yatesoats","title":"Yield of oats in a split-block experiment — DT_yatesoats","text":"yield oats split-plot field trial using three varieties   four levels manurial treatment. experiment laid   6 blocks 3 main plots, split 4 sub-plots. varieties   applied main plots manurial (nitrogen) treatments   sub-plots.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_yatesoats.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Yield of oats in a split-block experiment — DT_yatesoats","text":"block block factor 6 levels nitro nitrogen treatment hundredweight per acre Variety genotype factor, 3 levels yield yield 1/4 lbs per sub-plot, 1/80 acre. row row location column column location","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_yatesoats.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Yield of oats in a split-block experiment — DT_yatesoats","text":"Yates, Frank (1935) Complex experiments,   Journal Royal Statistical Society Suppl. 2, 181–247.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_yatesoats.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Yield of oats in a split-block experiment — DT_yatesoats","text":"Venables, W. N. Ripley, B. D. (2002)   Modern Applied Statistics S. Fourth edition. Springer.","code":""},{"path":"https://github.com/covaruber/sommer/reference/DT_yatesoats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Yield of oats in a split-block experiment — DT_yatesoats","text":"","code":"### ========================== ### ### ========================== ### data(DT_yatesoats) DT <- DT_yatesoats head(DT) #>   row col   Y   N          V  B         MP #> 1   1   1  91 0.2    Victory B2    Victory #> 2   2   1  61   0    Victory B2    Victory #> 3   3   1 121 0.4 Marvellous B2 Marvellous #> 4   4   1 144 0.6 Marvellous B2 Marvellous #> 5   5   1 149 0.6 GoldenRain B2 GoldenRain #> 6   6   1 108 0.2 GoldenRain B2 GoldenRain # m3 <- mmer(fixed=Y ~ V + N + V:N, #            random = ~ B + B:MP, #            rcov=~units, #            data = DT) # summary(m3)$varcomp #  # m3b <- mmec(fixed=Y ~ V + N + V:N, #            random = ~ B + B:MP, #            rcov=~units, #            data = DT) # summary(m3b)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/E.mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Epistatic relationship matrix — E.mat","title":"Epistatic relationship matrix — E.mat","text":"Calculates realized epistatic relationship matrix second order (additive x additive, additive x dominance, dominance x dominance) using hadamard products C++ Armadillo library.","code":""},{"path":"https://github.com/covaruber/sommer/reference/E.mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Epistatic relationship matrix — E.mat","text":"","code":"E.mat(X,nishio=TRUE,type=\"A#A\",min.MAF=0.02)"},{"path":"https://github.com/covaruber/sommer/reference/E.mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Epistatic relationship matrix — E.mat","text":"X Matrix (\\(n \\times m\\)) unphased genotypes \\(n\\) lines \\(m\\) biallelic markers, coded {-1,0,1}. Fractional (imputed) missing values (NA) allowed. nishio TRUE Nishio ans Satoh. (2014), otherwise Su et al. (2012) (see Details D.mat help page). type argument specifying type epistatic relationship matrix desired. default second order epistasis (additive x additive) type=\"#\". options additive x dominant (type=\"#D\"), dominant dominant (type=\"D#D\"). min.MAF Minimum minor allele frequency. matrix sensitive rare alleles, default monomorphic markers removed.","code":""},{"path":"https://github.com/covaruber/sommer/reference/E.mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Epistatic relationship matrix — E.mat","text":"computed Hadamard product epistatic relationship matrix; E=#, E=#D, E=D#D.","code":""},{"path":"https://github.com/covaruber/sommer/reference/E.mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Epistatic relationship matrix — E.mat","text":"epistatic relationship matrix returned.","code":""},{"path":"https://github.com/covaruber/sommer/reference/E.mat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Epistatic relationship matrix — E.mat","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Endelman, J.B., J.-L. Jannink. 2012. Shrinkage estimation realized relationship matrix. G3:Genes, Genomes, Genetics. 2:1405-1413. doi: 10.1534/g3.112.004259 Nishio M Satoh M. 2014. Including Dominance Effects Genomic BLUP Method Genomic Evaluation. Plos One 9(1), doi:10.1371/journal.pone.0085792 Su G, Christensen , Ostersen T, Henryon M, Lund MS. 2012. Estimating Additive Non-Additive Genetic Variances Predicting Genetic Merits Using Genome-Wide Dense Single Nucleotide Polymorphism Markers. PLoS ONE 7(9): e45293. doi:10.1371/journal.pone.0045293","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/E.mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Epistatic relationship matrix — E.mat","text":"","code":"####=========================================#### ####random population of 200 lines with 1000 markers ####=========================================#### X <- matrix(rep(0,200*1000),200,1000) for (i in 1:200) {   X[i,] <- sample(c(-1,0,0,1), size=1000, replace=TRUE) }  E <- E.mat(X, type=\"A#A\")  # if heterozygote markers are present can be used \"A#D\" or \"D#D\""},{"path":"https://github.com/covaruber/sommer/reference/EM.html","id":null,"dir":"Reference","previous_headings":"","what":"Expectation Maximization Algorithm — EM","title":"Expectation Maximization Algorithm — EM","text":"Univariate version expectation maximization (EM) algorithm.","code":""},{"path":"https://github.com/covaruber/sommer/reference/EM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expectation Maximization Algorithm — EM","text":"","code":"EM(y,X=NULL,ZETA=NULL,R=NULL,iters=30,draw=TRUE,silent=FALSE,     constraint=TRUE, init=NULL, forced=NULL, tolpar = 1e-04,     tolparinv = 1e-06)"},{"path":"https://github.com/covaruber/sommer/reference/EM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expectation Maximization Algorithm — EM","text":"y numeric vector response variable X incidence matrix fixed effects. ZETA incidence matrix random effects. can one random effects. NEEDS PROVIDED LIST STRUCTURE. example Z=list(list(Z=Z1, K=K1), list(Z=Z2, K=K2), list(Z=Z3, K=K3)) makes 2 level list 3 random effects. general idea random effect without variance-covariance structure list, .e. list(Z=Z1, K=K1) Z incidence matrix K var-cov matrix. moving one random effect need make several lists need inside another list. call 2-level list, .e. list(Z=Z1, K=K1) list(Z=Z2, K=K2) need put form; list(list(Z=Z1, K=K1),list(Z=Z1, K=K1)), can seen, list lists (2-level list). R list matrices residuals, .e. longitudinal data. passed assumed identity matrix. draw TRUE/FALSE value indicating plot updated values variance components likelihood drawn . default TRUE. COMPUTATION TIME SMALLER PLOT SETTING draw=FALSE silent TRUE/FALSE value indicating function draw progress bar iterations performed working displayed. iters scalar value indicating many iterations performed EM performed. rule tumb number iterations. default value 100 iterations EM steps. constraint TRUE/FALSE value indicating program use boundary constraint one variance component close zero boundary. default TRUE needs used carefully. works ideally variance components close boundary many variance components close zero highly recommend setting parameter FALSE since likely get right value variance components way. init vector initial values variance components. default NULL variance components estimated method selected, case user want provide initial values argument functional. forced vector numeric values variance components including error user wants force values variance components. meantime works forcing subset . default NULL, meaning variance components estimated REML/ML. tolpar tolerance parameter convergence models. tolparinv tolerance parameter matrix inversion models.","code":""},{"path":"https://github.com/covaruber/sommer/reference/EM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expectation Maximization Algorithm — EM","text":"algorithm based Searle (1993) Bernanrdo (2010). handles models form: y = Xb + Zu + e b ~ N[b.hat, 0]  ............zero variance fixed term u ~ N[0, K*sigma(u)]  .......: K*sigma(u) = G e ~ N[0, *sigma(e)]  .......: *sigma(e) = R y ~ N[Xb, var(Zu+e)]   ......; var(y) = var(Zu+e) = ZGZ+R = V phenotypic variance . function allows user specify incidence matrices respective variance-covariance matrix 2 level list structure. example imagine mixed model following design: . fixed = intercept....................................b ~ N[b.hat, 0] random = GCA1 + GCA2 + SCA.................u ~ N[0, G] . G : . |K*sigma(gca1).....................0..........................0.........| |.............0.............S*sigma(gca2).....................0.........| = G |.............0....................0......................W*sigma(sca)..| . function based useing initial values variance components, .e.: . var(e) <- 100 var(u1) <- 100      incidence matrix Z1 var(u2) <- 100      incidence matrix Z2 var(u3) <- 100      incidence matrix Z3 . estimates lambda(vx) values mixed model equations (MME) developed Henderson (1975), .e. consider 3 random effects stated , MME : . |...............X'*R*X...............X'*R*Z1.............X'*R*Z2...................X'*R*Z3 ..............|   |...X'Ry...| |.............Z1'*R*X.........Z1'*R*Z1+K1*v1.....Z1'*R*Z2..................Z1'*R*Z3.............|   |...Z1'Ry...| |.............Z2'*R*X.............Z2'*R*Z1.............Z2'*R*Z2+K2*v2......Z2'*R*Z3.............|   |...Z2'Ry...| |.............Z3'*R*X.............Z3'*R*Z1.............Z3'*R*Z2.............Z3'*R*Z3+K3*v3......|   |...Z3'Ry...| . ..............................................................C.inv...................................................................RHS . \"*\"\" matrix product, R inverse var-cov matrix errors, Z1, Z2, Z3 incidence matrices random effects, X incidence matrix fixed effects, K1,K2, K3 var-cov matrices random effects v1,v2,v3 estimates variance components. . algorithm can summarized next steps: . 1) provide initial values variance components 2) estimate coefficient matrix MME known \"C\" 3) solve mixed equations theta = RHS * C.inv 4) obtain new estimates fixed (b's) random effects (u's) called theta 5) update values variance components according formulas 6) steps repeated number iterations specified user, ideally enough variations estimates found, several problems take thousands iterations, whereas 10 iterations enough.","code":""},{"path":"https://github.com/covaruber/sommer/reference/EM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expectation Maximization Algorithm — EM","text":"parameters correctly indicated program return list following information: $var.com vector values variance components estimated $V.inv matrix inverse phenotypic variance V = ZGZ+R, V^-1 $u.hat vector BLUPs random effects $Var.u.hat vector variances BLUPs $PEV.u.hat vector predicted error variance BLUPs $beta.hat vector BLUEs fixed effects $Var.beta.hat vector variances BLUEs $X incidence matrix fixed effects $Z incidence matrix random effects, passed assumed diagonal matrix $K var-cov matrix random effect fitted Z","code":""},{"path":"https://github.com/covaruber/sommer/reference/EM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Expectation Maximization Algorithm — EM","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Bernardo Rex. 2010. Breeding quantitative traits plants. Second edition. Stemma Press. 390 pp. Searle. 1993. Applying EM algorithm calculating ML REML estimates variance components. Paper invited 1993 American Statistical Association Meeting, San Francisco.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/EM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expectation Maximization Algorithm — EM","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================####  # ## Import phenotypic data on inbred performance # ## Full data # data(\"DT_cornhybrids\") # hybrid2 <- DT_cornhybrids # extract cross data # A <- GT_cornhybrids # extract the var-cov K # ############################################ # ############################################ # ## breeding values with 3 variance components # ############################################ # ############################################ # y <- hybrid2$Yield # X1 <- model.matrix(~ Location, data = hybrid2);dim(X1) # Z1 <- model.matrix(~ GCA1 -1, data = hybrid2);dim(Z1) # Z2 <- model.matrix(~ GCA2 -1, data = hybrid2);dim(Z2) # Z3 <- model.matrix(~ SCA -1, data = hybrid2);dim(Z3) #  # K1 <- A[levels(hybrid2$GCA1), levels(hybrid2$GCA1)]; dim(K1) # ## Realized IBS relationships for set of parents 1 # K2 <- A[levels(hybrid2$GCA2), levels(hybrid2$GCA2)]; dim(K2) # ## Realized IBS relationships for set of parents 2 # S <- kronecker(K1, K2) ; dim(S) # ## Realized IBS relationships for cross (as the Kronecker product of K1 and K2) # rownames(S) <- colnames(S) <- levels(hybrid2$SCA) #  # ETA <- list(list(Z=Z1, K=K1), list(Z=Z2, K=K2))#, list(Z=Z3, K=S)) # ans <- EM(y=y, ZETA=ETA, iters=50) # ans$var.comp #  # # compare with NR method # mix1 <- mmer(Yield~1, random=~vs(GCA1,Gu=K1)+vs(GCA2,Gu=K2), data=hybrid2) # summary(mix1)$varcomp #"},{"path":"https://github.com/covaruber/sommer/reference/EMMA.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Efficient Mixed Model Association Algorithm — MEMMA","title":"Multivariate Efficient Mixed Model Association Algorithm — MEMMA","text":"function used internally function mmer multiple responses selected single variance component error. uses efficient mixed model association (MEMMA) algorithm.","code":""},{"path":"https://github.com/covaruber/sommer/reference/EMMA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Efficient Mixed Model Association Algorithm — MEMMA","text":"","code":"MEMMA(Y, X=NULL, ZETA=NULL, tolpar = 1e-06, tolparinv = 1e-06, check.model=TRUE,       silent=TRUE)"},{"path":"https://github.com/covaruber/sommer/reference/EMMA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Efficient Mixed Model Association Algorithm — MEMMA","text":"Y numeric vector response variable X incidence matrix fixed effects. ZETA incidence matrix random effects. can one random effects. NEEDS PROVIDED LIST STRUCTURE. example Z=list(list(Z=Z1, K=K1), list(Z=Z2, K=K2), list(Z=Z3, K=K3)) makes 2 level list 3 random effects. general idea random effect without variance-covariance structure list, .e. list(Z=Z1, K=K1) Z incidence matrix K var-cov matrix. moving one random effect need make several lists need inside another list. call 2-level list, .e. list(Z=Z1, K=K1) list(Z=Z2, K=K2) need put form; list(list(Z=Z1, K=K1),list(Z=Z1, K=K1)), can seen, list lists (2-level list). tolpar tolerance parameter convergence tolparinv tolerance parameter matrix inverse check.model TRUE/FALSE value indicating list structure provided user correct fix . default TRUE turned FALSE within mmer function imply double check. silent TRUE/FALSE value indicating function draw progress bar iterations performed working displayed.","code":""},{"path":"https://github.com/covaruber/sommer/reference/EMMA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multivariate Efficient Mixed Model Association Algorithm — MEMMA","text":". likelihood function optimized algorithm : . logL = (n - p) * log(sum(eta^2/(lambda + delta)) + sum(log(lambda + delta)) . : (n-p)  refers degrees freedom lambda eigenvalues mentioned Kang et al.(2008) delta REML estimator ridge parameter . algorithm can summarized next steps: . 1) provide initial value ridge parameter 2) estimate S = - X(X'X)-X' 3) obtain phenotypic variance V = ZKZ' + delta.prov*4) perform eigen decomposition SVS 5) create \"lambda\"\" eigenvalues SVS \"U\"\" eigenvectors 6) estimate eta=U'y 7) optimize likelihood shown providing \"eta\", \"lambdas\" optimize respect \"delta\" ridge parameter contains Ve/Vu","code":""},{"path":"https://github.com/covaruber/sommer/reference/EMMA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Efficient Mixed Model Association Algorithm — MEMMA","text":"parameters correctly indicated program return list following information: $Vu scalar value variance component estimated $Ve scalar value error variance estimated $V.inv matrix inverse phenotypic variance V = ZGZ+R, V^-1 $u.hat vector BLUPs random effects $Var.u.hat vector variances BLUPs $PEV.u.hat vector predicted error variance BLUPs $beta.hat vector BLUEs fixed effects $Var.beta.hat vector variances BLUEs $X incidence matrix fixed effects, passed assumed include intercept $Z incidence matrix random effects, passed assumed diagonal matrix $K var-cov matrix random effect fitted Z $ll log-likelihood value obtained optimizing likelihood function using ML REML","code":""},{"path":"https://github.com/covaruber/sommer/reference/EMMA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multivariate Efficient Mixed Model Association Algorithm — MEMMA","text":"Kang et al. 2008. Efficient control population structure model organism association mapping. Genetics 178:1709-1723. Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/EMMA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multivariate Efficient Mixed Model Association Algorithm — MEMMA","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================#### # data(CPdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # ### look at the data # head(DT) # GT[1:5,1:5] # ## fit a model including additive and dominance effects # Y <- DT[,c(\"color\",\"Yield\")] # Za <- diag(dim(Y)[1]) # A <- A.mat(GT) # additive relationship matrix # ####================#### # #### ADDITIVE MODEL #### # ####================#### # ETA.A <- list(add=list(Z=Za,K=A)) # #ans.A <- MEMMA(Y=Y, ZETA=ETA.A) # #ans.A$var.comp"},{"path":"https://github.com/covaruber/sommer/reference/GWAS.html","id":null,"dir":"Reference","previous_headings":"","what":"Genome wide association study analysis — GWAS","title":"Genome wide association study analysis — GWAS","text":"Fits multivariate/univariate linear mixed model GWAS likelihood methods (REML), see Details section . uses mmer function core coded C++ using Armadillo library optimize dense matrix operations common derect-inversion algorithms. model fit extracts inverse phenotypic variance matrix perform association test \"p\" markers. Please check Details section (Model enabled) issue making function run. package also provides functions estimate additive (.mat), dominance (D.mat), epistatic (E.mat) single step (H.mat) relationship matrices model known covariances among genotypes typical plant animal breeding problems. functions build known covariance structures among levels random effects autoregresive (AR1), compound symmetry (CS) autoregressive moving average (ARMA) user needs fix correlation value models (different estimating unknown covariance structures). Additionally, overlayed models can implemented well (overlay function). Spatial modeling can done two dimensional splines (spl2Da spl2Db). Random regression models can also fitted (leg) function (orthopolynom package installation needed using leg function). sommer package updated CRAN every 3-months due CRAN policies can find latest source https://github.com/covaruber/sommer . can easily installed typing following R console: library(devtools) install_github(\"covaruber/sommer\") recommended since bugs fixes immediately available GitHub source. tutorials perform different analysis sommer please look vignettes typing terminal: vignette(\"v1.sommer.quick.start\") vignette(\"v2.sommer.changes..faqs\") vignette(\"v3.sommer.qg\") vignette(\"v4.sommer.gxe\") visit https://covaruber.github.io","code":""},{"path":"https://github.com/covaruber/sommer/reference/GWAS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Genome wide association study analysis — GWAS","text":"","code":"GWAS(fixed, random, rcov, data, weights, W,     nIters=20, tolParConvLL = 1e-03, tolParInv = 1e-06,      init=NULL, constraints=NULL,method=\"NR\",      getPEV=TRUE,naMethodX=\"exclude\",     naMethodY=\"exclude\",returnParam=FALSE,      dateWarning=TRUE,date.warning=TRUE,verbose=FALSE,     stepWeight=NULL, emWeight=NULL,     M=NULL, gTerm=NULL, n.PC = 0, min.MAF = 0.05,      P3D = TRUE)"},{"path":"https://github.com/covaruber/sommer/reference/GWAS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Genome wide association study analysis — GWAS","text":"fixed formula specifying response variable(s) fixed effects, .e: response ~ covariate univariate models cbind(response.,response.j) ~ covariate multivariate models fcm() function can used constrain fixed effects multi-response models.  random formula specifying name random effects, .e. random= ~ genotype + year. Useful functions can used fit heterogeneous variances special models (see 'Special Functions' Details section information): vsr(...,Gu,Gt,Gtc) main function specify variance models special structures random effects. ... argument provide unknown variance-covariance structures (.e. usr,dsr,,csr) random effect covariance structure used (random effect interest). Gu used provide known covariance matrices among levels random effect, Gt initial values Gtc constraints. Auxiliar functions building variance models : ** dsr(x), usr(x), csr(x) atr(x,levs) can used specify unknown diagonal, unstructured customized unstructured diagonal covariance structures estimated REML. ** unsm(x), fixm(x) diag(x) can used build easily matrices specify constraints Gtc argument vsr() function. ** overlay(), spl2Da(), spl2Db(), leg() functions can used specify overlayed design matrices random effects, two dimensional spline random regression models within vsr() function.  rcov formula specifying name error term, .e. rcov= ~ units. functions can used fit heterogeneous residual variances used random term random effect always \"units\", .e. rcov=~vsr(dsr(Location),units)  data data frame containing variables specified formulas response, fixed, random effects. weights name covariate weights. used product R = Wsi*R*Wsi, * matrix product, Wsi square root inverse W R residual matrix. W Alternatively, instead providing vector weights user can specify entire W matrix (e.g., covariances exist). used first produce Wis = solve(chol(W)), calculate R = Wsi*R*Wsi.t(), * matrix product, R residual matrix. one arguments weights W used. indicated W given preference. nIters Maximum number iterations allowed.  Default value 15. tolParConvLL Convergence criteria. tolParInv tolerance parameter matrix inverse used singularities encountered. init initial values variance components. default NULL variance components estimated method selected, case user want provide initial values var-cov components argument functional. provided list array, list element one variance component multitrait model pursued element list matrix variance covariance components among traits. Initial values can also provided Gt argument vsr function.highly encouraged use Gt Gtc arguments vsr function instead argument constraints initial values provided accompanied constraints. See vsr function details constraints. highly encouraged use Gt Gtc arguments vsr function instead argument. method refers method algorithm used estimating variance components. Direct-inversion Newton-Raphson NR Average Information AI (Tunnicliffe 1989; Gilmour et al. 1995; Lee et al. 2015). getPEV TRUE/FALSE value indicating program return predicted error variance variance random effects. option provided since can take long time certain models p > n big extent. naMethodX one two possible values; \"include\" \"exclude\". \"include\" selected function impute X matrices fixed effects median value. \"exclude\" selected get rid rows missing values X (fixed) covariates. default \"exclude\". \"include\" option used carefully. naMethodY one three possible values; \"include\", \"include2\" \"exclude\". \"include\" selected function impute response variables median value. difference \"include\" \"include2\" available multitrait models imputation can happen entire matrix responses complete cases (\"include2\"). \"exclude\" selected get rid rows responses missing values present estimation variance components. default \"exclude\". returnParam TRUE/FALSE value indicate program return parameters used modeling without fitting model. dateWarning TRUE/FALSE value indicate program warn time update sommer package. date.warning TRUE/FALSE value indicate program warn time update sommer package. verbose TRUE/FALSE value indicate program return progress iterative algorithm. stepWeight vector values (length equal number iterations) indicating weight used multiply update (delta) variance components iteration. NULL 1st iteration multiplied 0.5, 2nd 0.7, rest 0.9. argument can help avoid variance components go outside parameter space initial iterations happen often NR method can detected looking behavior likelihood. case may want give smaller weight initial 8-10 iterations. emWeight vector values (length equal number iterations) indicating values 0 1 weight assigned EM information matrix. values 1 - emWeight applied NR/AI information matrix produce joint information matrix. NULL weights EM information matrix zero 1 NR/AI information matrix. M marker matrix containing marker scores level random effect selected gTerm argument, coded numeric based number reference alleles genotype call, e.g. (-1,0,1) = (aa,Aa,AA), levels diploid individuals. Individuals rows markers columns. additional columns provided, purely numerical matrix. Similar logic applies polyploid individuals, e.g. (-3,-2,-1,0,1,2,3) = (aaaa,aaaA,aaAA,Aaaa,AAaa,AAAa,AAAA). gTerm character vector indicating random effect linked marker matrix M (.e. genetic term) model. random effect selected number levels number rows M. fitting random effect without special covariance structure (e.g., dsr, usr, etc.) need add call 'u:' name random effect given behavior naming rules solver simple random effect without covariance structure. n.PC Number principal components include fixed effects. Default 0 (equals K model). min.MAF Specifies minimum minor allele frequency (MAF). marker MAF less min.MAF, assigned zero score. P3D P3D=TRUE, variance components estimated REML , without markers model loop hypothesis testing performed. P3D=FALSE, variance components estimated REML marker separately. latter can quite time consuming. many models run number marker.","code":""},{"path":"https://github.com/covaruber/sommer/reference/GWAS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Genome wide association study analysis — GWAS","text":"Citation Type citation(\"sommer\") know cite sommer package publications. Models Enabled details models enabled information covariance structures please check help page package (sommer). general GWAS model implemented sommer obtain marker effect generalized linear model form: b = (X'V-X)X'V-y X = ZMi : b marker effect (dimensions 1 x mt) y response variable (univariate multivariate) (dimensions 1 x nt) V- inverse phenotypic variance matrix (dimensions nt x nt) Z incidence matrix random effect selected (gTerm argument) perform GWAS (dimensions nt x ut) Mi ith column marker matrix (M argument) (dimensions u x m) t traits, n observations, m markers u levels random effect. Depending P3D TRUE FALSE V- matrix calculated used marker tests (P3D=TRUE) estimated REML marker (P3D=FALSE). Special Functions vsr(atr(x,levels),y) can used specify heterogeneous variance \"y\"\" factor covariate specific levels factor covariate \"x\", .e. random=~vsr((Location,c(\"\",\"B\")),ID) fits variance component ID levels B factor covariate Location. vsr(dsr(x),y) can used specify diagonal covariance structure \"y\"\" covariate levels factor covariate \"x\", .e. random=~vsr(dsr(Location,ID)  fits variance component ID levels factor covariate Location. vsr(usr(x),y) can used specify unstructured covariance structure \"y\"\" covariate levels factor covariate \"x\", .e. random=~vsr(usr(Location),ID)  fits variance covariance components ID levels factor covariate Location. vsr(overlay(...,rlist=NULL,prefix=NULL)) can used specify overlay design matrices consecutive random effects specified, .e. random=~overlay(male,female) overlays (overlaps) incidence matrices male female random effects obtain single variance component effects. `rlist` argument list element numeric value multiplies incidence matrix overlayed. See overlay details.Can combined vsr(). spl2Da(x.coord, y.coord, .var, .levels)) can used fit 2-dimensional spline (.e. spatial modeling) using coordinates x.coord y.coord (numeric class) assuming single variance component. 2D spline can fitted specific levels using .levels arguments. example random=~spl2Da(x.coord=Row,y.coord=Range,.var=FIELD). spl2Db(x.coord, y.coord, .var, .levels)) can used fit 2-dimensional spline (.e. spatial modeling) using coordinates x.coord y.coord (numeric class) assuming multiple variance components. 2D spline can fitted specific levels using .levels arguments. example random=~spl2Db(x.coord=Row,y.coord=Range,.var=FIELD). short tutorial use special functions can look vignettes typing terminal: vignette('sommer.start') Bug report contact technical questions suggestions please post https://stackoverflow.com https://stats.stackexchange.com. bug report please go https://github.com/covaruber/sommer send email address asap. Example Datasets package equiped several datasets learn use sommer package: * DT_halfdiallel DT_fulldiallel datasets examples fit half full diallel designs. * DT_h2 calculate heritability * DT_cornhybrids DT_technow datasets perform genomic prediction hybrid single crosses * DT_wheat dataset genomic prediction single crosses species displaying additive effects. * DT_cpdata dataset fit genomic prediction models within biparental population coming 2 highly heterozygous parents including additive, dominance epistatic effects. * DT_polyploid fit genomic prediction GWAS analysis polyploids. * DT_gryphon data contains example animal model including pedigree information. * DT_btdata dataset contains animal (birds) model. Additional Functions functions summary, fitted, randef (notice randef ranef), anova, residuals, coef plot applicable typical linear models can also applied models fitted using GWAS-type functions. Additional functions genetic analysis included build genotypic hybrid marker matrix (build.HMM), plot genetic maps (map.plot), creation manhattan plots (manhattan). need use pedigree need convert pedigree relationship matrix (.e. use getA function pedigreemm package). Useful functions analyzing field trials included spl2Da spl2Db.","code":""},{"path":"https://github.com/covaruber/sommer/reference/GWAS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Genome wide association study analysis — GWAS","text":"parameters correctly indicated program return list following information: Vi inverse phenotypic variance matrix V^- = (ZGZ+R)^-1 sigma list values variance-covariance components one list element random effect. sigma_scaled list values scaled variance-covariance components one list element random effect. sigmaSE Hessian matrix containing variance-covariance variance components. SE's can obtained taking square root diagonal values Hessian. Beta data frame trait BLUEs (fixed effects). VarBeta variance-covariance matrix trait BLUEs U list (one element random effect) data frame trait BLUPs. VarU list (one element random effect) variance-covariance matrix trait BLUPs. PevU list (one element random effect) predicted error variance matrix trait BLUPs. fitted Fitted values y.hat=XB residuals Residual values e = Y - XB AIC Akaike information criterion BIC Bayesian information criterion convergence TRUE/FALSE statement indicating model converged. monitor values log-likelihood variance-covariance components across iterations REML estimation. scores marker scores (-log_(10)p) traits method method extimation variance components specified user. constraints contraints used mixed models random effects.","code":""},{"path":"https://github.com/covaruber/sommer/reference/GWAS.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Genome wide association study analysis — GWAS","text":"Covarrubias-Pazaran G. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 2016, 11(6): doi:10.1371/journal.pone.0156744 Covarrubias-Pazaran G. 2018. Software update: Moving R package sommer multivariate mixed models genome-assisted prediction. doi: https://doi.org/10.1101/354639 Bernardo Rex. 2010. Breeding quantitative traits plants. Second edition. Stemma Press. 390 pp. Gilmour et al. 1995. Average Information REML: efficient algorithm variance parameter estimation linear mixed models. Biometrics 51(4):1440-1450. Kang et al. 2008. Efficient control population structure model organism association mapping. Genetics 178:1709-1723. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Lee et al. 2015. MTG2: efficient algorithm multivariate linear mixed model analysis based genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201. Maier et al. 2015. Joint analysis psychiatric disorders increases accuracy risk prediction schizophrenia, bipolar disorder, major depressive disorder. J Hum Genet; 96(2):283-294. Rodriguez-Alvarez, Maria Xose, et al. Correcting spatial heterogeneity plant breeding experiments P-splines. Spatial Statistics 23 (2018): 52-71. Searle. 1993. Applying EM algorithm calculating ML REML estimates variance components. Paper invited 1993 American Statistical Association Meeting, San Francisco. Yu et al. 2006. unified mixed-model method association mapping accounts multiple levels relatedness. Genetics 38:203-208. Tunnicliffe W. 1989. use marginal likelihood time series model estimation. JRSS 51(1):15-27. Zhang et al. 2010. Mixed linear model approach adapted genome-wide association studies. Nat. Genet. 42:355-360.","code":""},{"path":"https://github.com/covaruber/sommer/reference/GWAS.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Genome wide association study analysis — GWAS","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":"https://github.com/covaruber/sommer/reference/GWAS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genome wide association study analysis — GWAS","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples using #### command + shift + C |OR| control + shift + C ####=========================================#### #####========================================#### ##### potato example #####========================================#### #  # data(DT_polyploid) # DT <- DT_polyploid # GT <- GT_polyploid # MP <- MP_polyploid # ####=========================================#### # ####### convert markers to numeric format # ####=========================================#### # numo <- atcg1234(data=GT, ploidy=4); # numo$M[1:5,1:5]; # numo$ref.allele[,1:5] #  # ###=========================================#### # ###### plants with both genotypes and phenotypes # ###=========================================#### # common <- intersect(DT$Name,rownames(numo$M)) #  # ###=========================================#### # ### get the markers and phenotypes for such inds # ###=========================================#### # marks <- numo$M[common,]; marks[1:5,1:5] # DT2 <- DT[match(common,DT$Name),]; # DT2 <- as.data.frame(DT2) # DT2[1:5,] #  # ###=========================================#### # ###### Additive relationship matrix, specify ploidy # ###=========================================#### # A <- A.mat(marks) # ###=========================================#### # ### run it as GWAS model # ###=========================================#### # ans2 <- GWAS(tuber_shape~1, #              random=~vsr(Name,Gu=A), #              rcov=~units, #              gTerm = \"u:Name\", #              M=marks, data=DT2) # plot(ans2$scores[,1])"},{"path":"https://github.com/covaruber/sommer/reference/H.html","id":null,"dir":"Reference","previous_headings":"","what":"Two-way id by features table — H","title":"Two-way id by features table — H","text":"H creates two way id features table can used H argument rrc function extracts latent covariates.","code":""},{"path":"https://github.com/covaruber/sommer/reference/H.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Two-way id by features table — H","text":"","code":"H(timevar=NULL, idvar=NULL, response=NULL, Gu=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/H.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Two-way id by features table — H","text":"timevar vector dataset containing variable used form columns wide table. idvar vector dataset containing variable used form rows wide table. response vector dataset containing response variable used fill cells wide table. Gu optional covariance matrix (inverse) levels idvar case sparse (unbalanced) design timevar idvar exist.","code":""},{"path":"https://github.com/covaruber/sommer/reference/H.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Two-way id by features table — H","text":"just aggregate, reshape imputation long format table wide format table.","code":""},{"path":"https://github.com/covaruber/sommer/reference/H.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Two-way id by features table — H","text":"$H two way table id features effects.","code":""},{"path":"https://github.com/covaruber/sommer/reference/H.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Two-way id by features table — H","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/H.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Two-way id by features table — H","text":"","code":"# data(DT_h2) # DT <- DT_h2 # DT=DT[with(DT, order(Env)), ] # H0 <- with(DT, H(Env, Name, y) ) # Z <- with(DT, rrc(Env, H0, 2))"},{"path":"https://github.com/covaruber/sommer/reference/H.mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Combined relationship matrix H — H.mat","title":"Combined relationship matrix H — H.mat","text":"Given matrix matrix G returns H matrix C++ Armadillo library.","code":""},{"path":"https://github.com/covaruber/sommer/reference/H.mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combined relationship matrix H — H.mat","text":"","code":"H.mat(A, G, tau = 1, omega = 1, tolparinv=1e-6)"},{"path":"https://github.com/covaruber/sommer/reference/H.mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combined relationship matrix H — H.mat","text":"Additive relationship matrix based pedigree. G Additive relationship matrix based marker data. tau described Martini et al. (2018). omega described Martini et al. (2018). tolparinv Tolerance parameter matrix inverse used singularities encountered estimation procedure.","code":""},{"path":"https://github.com/covaruber/sommer/reference/H.mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combined relationship matrix H — H.mat","text":"See references","code":""},{"path":"https://github.com/covaruber/sommer/reference/H.mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combined relationship matrix H — H.mat","text":"H Matrix relationship individuals based pedigree corrected molecular information","code":""},{"path":"https://github.com/covaruber/sommer/reference/H.mat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Combined relationship matrix H — H.mat","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Martini, J. W., Schrauf, M. F., Garcia-Baccino, C. ., Pimentel, E. C., Munilla, S., Rogberg-Munoz, ., ... & Simianer, H. (2018). effect H-1 scaling factors tau omega structure H single-step procedure. Genetics Selection Evolution, 50(1), 16.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/H.mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combined relationship matrix H — H.mat","text":"","code":"####=========================================#### ####random population of 200 lines with 1000 markers ####=========================================#### M <- matrix(rep(0,200*1000),200,1000) for (i in 1:200) {   M[i,] <- sample(c(-1,0,0,1), size=1000, replace=TRUE) } rownames(M) <- 1:nrow(M) v <- sample(1:nrow(M),100) M2 <- M[v,]  A <- A.mat(M) # assume this is a pedigree-based matrix for the sake of example G <- A.mat(M2)  H <- H.mat(A,G) # colfunc <- colorRampPalette(c(\"steelblue4\",\"springgreen\",\"yellow\")) # hv <- heatmap(H[1:15,1:15], col = colfunc(100),Colv = \"Rowv\")"},{"path":"https://github.com/covaruber/sommer/reference/LD.decay.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculation of linkage disequilibrium decay — LD.decay","title":"Calculation of linkage disequilibrium decay — LD.decay","text":"function calculates LD decay based marker matrix map distances markers cM base pairs.","code":""},{"path":"https://github.com/covaruber/sommer/reference/LD.decay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculation of linkage disequilibrium decay — LD.decay","text":"","code":"LD.decay(markers,map,silent=FALSE,unlinked=FALSE,gamma=0.95)"},{"path":"https://github.com/covaruber/sommer/reference/LD.decay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculation of linkage disequilibrium decay — LD.decay","text":"markers numeric matrix markers (columns) individuals (rows) -1, 0, 1 format. map data frame 3 columns \"Locus\" (name markers), \"LG\" (linkage group chromosome), \"Position\" (cM base pairs). silent TRUE/FALSE value statement indicating program display progress bar. silent=TRUE means displayed. unlinked TRUE/FALSE value statement indicating program calculate alpha(see next argument) percentile interchromosomal LD. gamma percentile value LD breakage used calculation interchromosomal LD extent.","code":""},{"path":"https://github.com/covaruber/sommer/reference/LD.decay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculation of linkage disequilibrium decay — LD.decay","text":"$resp list 3 elements; \".LG\", \".LG\", \"LDM\". first element (.LG) list many elements chromosomes contains matrix 3 columns, distance, r2 value, p-value associated chi-square test disequilibrium. second element (.LG) big matrix distance, r2 values p-values, point chromosomes single data.frame. third element (LDM) matrix linkage disequilibrium pairs markers. unlinked selected program return gamma percentile interchromosomal LD (r2) chromosome average.","code":""},{"path":"https://github.com/covaruber/sommer/reference/LD.decay.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculation of linkage disequilibrium decay — LD.decay","text":"Laido, Giovanni, et al. Linkage disequilibrium genome-wide association mapping tetraploid wheat (Triticum turgidum L.). PloS one 9.4 (2014): e95211.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/LD.decay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculation of linkage disequilibrium decay — LD.decay","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples using  #### command + shift + C |OR| control + shift + C ####=========================================#### data(DT_cpdata) #### get the marker matrix CPgeno <- GT_cpdata; CPgeno[1:5,1:5] #>      scaffold_50439_2381 scaffold_39344_153 uneak_3436043 uneak_2632033 #> P003                   0                  0             0             1 #> P004                   0                  0             0             1 #> P005                   0                 -1             0             1 #> P006                  -1                 -1            -1             0 #> P007                   0                  0             0             1 #>      scaffold_4354_5518 #> P003                  1 #> P004                  1 #> P005                  1 #> P006                  0 #> P007                  1 #### get the map mapCP <- MP_cpdata; head(mapCP) #>                  Locus Position Chrom #> 1   scaffold_77830_839        0     1 #> 2   scaffold_39187_895        0     1 #> 3  scaffold_50439_2379        0     1 #> 4  scaffold_4354_55182        0     1 #> 5  scaffold_4354_55181        0     1 #> 6 scaffold_50439_23772        0     1 names(mapCP) <- c(\"Locus\",\"Position\",\"LG\") #### with example purposes we only do 3 chromosomes mapCP <- mapCP[which(mapCP$LG <= 3),] #### run the function # res <- LD.decay(CPgeno, mapCP) # names(res) #### subset only markers with significant LD # res$all.LG <- res$all.LG[which(res$all.LG$p < .001),] #### plot the LD decay # with(res$all.LG, plot(r2~d,col=transp(\"cadetblue\"), #                     xlim=c(0,55), ylim=c(0,1),  #                     pch=20,cex=0.5,yaxt=\"n\", #                     xaxt=\"n\",ylab=expression(r^2), #                     xlab=\"Distance in cM\") #                     ) # axis(1, at=seq(0,55,5), labels=seq(0,55,5)) # axis(2,at=seq(0,1,.1), labels=seq(0,1,.1), las=1)  #### if you want to add the loess regression lines #### this could take a long time!!! # mod <- loess(r2 ~ d, data=res$all.LG) # par(new=T) # lilo <- predict(mod,data.frame(d=1:55)) # plot(lilo, bty=\"n\", xaxt=\"n\", yaxt=\"n\", col=\"green\",  #      type=\"l\", ylim=c(0,1),ylab=\"\",xlab=\"\",lwd=2) # res3 <- LD.decay(markers=CPgeno, map=mapCP,  #                 unlinked = TRUE,gamma = .95) # abline(h=res3$all.LG, col=\"red\")"},{"path":"https://github.com/covaruber/sommer/reference/add.diallel.vars.html","id":null,"dir":"Reference","previous_headings":"","what":"add.diallel.vars — add.diallel.vars","title":"add.diallel.vars — add.diallel.vars","text":"`add.diallel.vars` adds 4 columns provided diallel dataset. Specifically, user provides dataset indicator variables male female parent function returns dataset 4 new dummy variables allow model fit diallel models.","code":""},{"path":"https://github.com/covaruber/sommer/reference/add.diallel.vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"add.diallel.vars — add.diallel.vars","text":"","code":"add.diallel.vars(df, par1=\"Par1\", par2=\"Par2\",sep.cross=\"-\")"},{"path":"https://github.com/covaruber/sommer/reference/add.diallel.vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"add.diallel.vars — add.diallel.vars","text":"df dataset two indicator variables male female parent. par1 name column indicating first parent (e.g. male). par2 name column indicating second parent (e.g. female). sep.cross character used creating column cross.id. simple paste columns par1 par2.","code":""},{"path":"https://github.com/covaruber/sommer/reference/add.diallel.vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"add.diallel.vars — add.diallel.vars","text":".cross returns 0 self 1 cross. .self returns 0 cross 1 self. cross.type returns -1 direct cross, 0 self 1 reciprocal cross. cross.id returns column psting par1 par2 columns.","code":""},{"path":"https://github.com/covaruber/sommer/reference/add.diallel.vars.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"add.diallel.vars — add.diallel.vars","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/add.diallel.vars.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"add.diallel.vars — add.diallel.vars","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/add.diallel.vars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"add.diallel.vars — add.diallel.vars","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the #### examples are silenced with one '#' mark, #### remove them and run the examples ####=========================================#### data(DT_mohring) DT <- DT_mohring head(DT) #>   Block Par1 Par2 Ftime #> 1     1    1    1   276 #> 2     1    1    2   156 #> 3     1    1    3   322 #> 4     1    1    4   250 #> 5     1    1    5   162 #> 6     1    1    6   193 DT2 <- add.diallel.vars(DT,par1=\"Par1\", par2=\"Par2\") head(DT2) #>   Block Par1 Par2 Ftime is.cross is.self cross.type cross.id #> 1     1    1    1   276        0       1          0      1-1 #> 2     1    1    2   156        1       0         -1      1-2 #> 3     1    1    3   322        1       0         -1      1-3 #> 4     1    1    4   250        1       0         -1      1-4 #> 5     1    1    5   162        1       0         -1      1-5 #> 6     1    1    6   193        1       0         -1      1-6 ## see ?DT_mohring for an example on how to use the data to fit diallel models."},{"path":"https://github.com/covaruber/sommer/reference/adiag1.html","id":null,"dir":"Reference","previous_headings":"","what":"Binds arrays corner-to-corner — adiag1","title":"Binds arrays corner-to-corner — adiag1","text":"Array generalization blockdiag()","code":""},{"path":"https://github.com/covaruber/sommer/reference/adiag1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binds arrays corner-to-corner — adiag1","text":"","code":"adiag1(... , pad=as.integer(0), do.dimnames=TRUE)"},{"path":"https://github.com/covaruber/sommer/reference/adiag1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binds arrays corner-to-corner — adiag1","text":"... Arrays binded together pad Value pad array ; note default keeps integer status     arrays .dimnames Boolean, default TRUE meaning return     dimnames possible.  Set FALSE performance     issue","code":""},{"path":"https://github.com/covaruber/sommer/reference/adiag1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Binds arrays corner-to-corner — adiag1","text":"Binds number arrays together, corner--corner.  function associative provided pad length 1, page discusses two array case. x=adiag1(,b) dim()=c(a_1,...,a_d), dim(b)=c(b_1,...,b_d); (dim(x)==dim()+dim(b)) x[1:a_1,...,1:a_d]=x[(a_1+1):(a_1+b_1),...,(a_d+1):(a_d+b_d)]=b. Dimnames preserved, arrays non-null dimnames, .dimnames TRUE. Argument pad usually length-one vector, vector acceptable; standard recycling used.  aware output array (dimension dim()+dim(b)) filled (copies ) pad b copied.  can confusing.","code":""},{"path":"https://github.com/covaruber/sommer/reference/adiag1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binds arrays corner-to-corner — adiag1","text":"Returns array dimensions dim()+dim(b) described .","code":""},{"path":"https://github.com/covaruber/sommer/reference/adiag1.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Binds arrays corner-to-corner — adiag1","text":"Peter Wolf additions Robin Hankin","code":""},{"path":"https://github.com/covaruber/sommer/reference/adiag1.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Binds arrays corner-to-corner — adiag1","text":"adiag1(,b), length-one vector, coerced array dimensions rep(1,length(dim(b))); likewise b.  b length-one vectors, return diag(c(,b)). b arrays, function adiag1() requires length(dim())==length(dim(b)) (function guess dimensions dropped; see examples section).  particular, note vectors coerced except length one. adiag1() used padding magic hypercubes context evaluating subarray sums.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/adiag1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binds arrays corner-to-corner — adiag1","text":"","code":"a <- array( 1,c(2,2))  b <- array(-1,c(2,2))  adiag1(a,b) #>      [,1] [,2] [,3] [,4] #> [1,]    1    1    0    0 #> [2,]    1    1    0    0 #> [3,]    0    0   -1   -1 #> [4,]    0    0   -1   -1   ## dropped dimensions can count:   b2 <- b1 <- b  dim(a) <- c(2,1,2)  dim(b1) <- c(2,2,1)  dim(b2) <- c(1,2,2)   dim(adiag1(a,b1)) #> [1] 4 3 3  dim(adiag1(a,b2)) #> [1] 3 3 4  ## dimnames are preserved if not null:  a <- matrix(1,2,2,dimnames=list(col=c(\"red\",\"blue\"),size=c(\"big\",\"small\")))  b <- 8 dim(b) <- c(1,1) dimnames(b) <- list(col=c(\"green\"),size=c(\"tiny\")) adiag1(a,b)   #dimnames preserved #>        size #> col     big small tiny #>   red     1     1    0 #>   blue    1     1    0 #>   green   0     0    8 adiag1(a,8)   #dimnames lost because second argument has none. #>      [,1] [,2] [,3] #> [1,]    1    1    0 #> [2,]    1    1    0 #> [3,]    0    0    8  ## non scalar values for pad can be confusing: q <- matrix(0,3,3) adiag1(q,q,pad=1:4) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    0    0    0    3    1    3 #> [2,]    0    0    0    4    2    4 #> [3,]    0    0    0    1    3    1 #> [4,]    4    2    4    0    0    0 #> [5,]    1    3    1    0    0    0 #> [6,]    2    4    2    0    0    0  ## following example should make the pattern clear: adiag1(q,q,pad=1:36) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    0    0    0   19   25   31 #> [2,]    0    0    0   20   26   32 #> [3,]    0    0    0   21   27   33 #> [4,]    4   10   16    0    0    0 #> [5,]    5   11   17    0    0    0 #> [6,]    6   12   18    0    0    0   # Now, a use for arrays with dimensions of zero extent: z <- array(dim=c(0,3)) colnames(z) <- c(\"foo\",\"bar\",\"baz\")  adiag1(a,z)        # Observe how this has #>       size #> col    big small foo bar baz #>   red    1     1   0   0   0 #>   blue   1     1   0   0   0                   # added no (ie zero) rows to \"a\" but                   # three extra columns filled with the pad value  adiag1(a,t(z)) #>       size #> col    big small #>   red    1     1 #>   blue   1     1 #>   foo    0     0 #>   bar    0     0 #>   baz    0     0 adiag1(z,t(z))     # just the pad value #>     foo bar baz #> foo   0   0   0 #> bar   0   0   0 #> baz   0   0   0"},{"path":"https://github.com/covaruber/sommer/reference/anova_mmec.html","id":null,"dir":"Reference","previous_headings":"","what":"anova form a GLMM fitted with mmec — anova.mmec","title":"anova form a GLMM fitted with mmec — anova.mmec","text":"anova method class \"mmec\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/anova_mmec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"anova form a GLMM fitted with mmec — anova.mmec","text":"","code":"# S3 method for class 'mmec' anova(object, object2=NULL, ...)"},{"path":"https://github.com/covaruber/sommer/reference/anova_mmec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"anova form a GLMM fitted with mmec — anova.mmec","text":"object object class \"mmec\" object2 object class \"mmec\", NULL program provide regular sum squares results. ... arguments passed","code":""},{"path":"https://github.com/covaruber/sommer/reference/anova_mmec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"anova form a GLMM fitted with mmec — anova.mmec","text":"vector anova","code":""},{"path":"https://github.com/covaruber/sommer/reference/anova_mmec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"anova form a GLMM fitted with mmec — anova.mmec","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/anova_mmer.html","id":null,"dir":"Reference","previous_headings":"","what":"anova form a GLMM fitted with mmer — anova.mmer","title":"anova form a GLMM fitted with mmer — anova.mmer","text":"anova method class \"mmer\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/anova_mmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"anova form a GLMM fitted with mmer — anova.mmer","text":"","code":"# S3 method for class 'mmer' anova(object, object2=NULL, type=1, ...)"},{"path":"https://github.com/covaruber/sommer/reference/anova_mmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"anova form a GLMM fitted with mmer — anova.mmer","text":"object object class \"mmer\" object2 object class \"mmer\", NULL program provide regular sum squares results. type anova type, II ... arguments passed","code":""},{"path":"https://github.com/covaruber/sommer/reference/anova_mmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"anova form a GLMM fitted with mmer — anova.mmer","text":"vector anova","code":""},{"path":"https://github.com/covaruber/sommer/reference/anova_mmer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"anova form a GLMM fitted with mmer — anova.mmer","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/atc.html","id":null,"dir":"Reference","previous_headings":"","what":"atc covariance structure — atc","title":"atc covariance structure — atc","text":"atc creates diagonal covariance structure specific levels random effect used mmec solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"atc covariance structure — atc","text":"","code":"atc(x, levs, thetaC, theta)"},{"path":"https://github.com/covaruber/sommer/reference/atc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"atc covariance structure — atc","text":"x vector observations random effect. levs levels random effect use building incidence matrices. thetaC optional symmetric matrix constraints variance-covariance components. symmetric matrix many rows columns number levels factor 'x'. values matrix define variance-covariance components estimated: 0: component estimated 1: component estimated constrained positive 2: component estimated unconstrained 3: component fixed value provided theta argument  theta optional symmetric matrix initial values variance-covariance components. symmetric matrix many rows columns number levels factor 'x'. values matrix define initial values variance-covariance components subject constraints provided thetaC. provided, initial values calculated : theta* = diag(ncol(mm))*.05 + matrix(.1,ncol(mm),ncol(mm)) mm incidence matrix factor 'x'. values provided scaled variance response variable. theta = theta*/var(y)","code":""},{"path":"https://github.com/covaruber/sommer/reference/atc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"atc covariance structure — atc","text":"$res list provided vector variance covariance structure expected.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"atc covariance structure — atc","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/atc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"atc covariance structure — atc","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/atc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"atc covariance structure — atc","text":"","code":"x <- as.factor(c(1:5,1:5,1:5));x #>  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 #> Levels: 1 2 3 4 5 atc(x, c(\"1\",\"2\")) #> $Z #> 15 x 2 sparse Matrix of class \"dgCMatrix\" #>    1 2 #> 1  1 . #> 2  . 1 #> 3  . . #> 4  . . #> 5  . . #> 6  1 . #> 7  . 1 #> 8  . . #> 9  . . #> 10 . . #> 11 1 . #> 12 . 1 #> 13 . . #> 14 . . #> 15 . . #>  #> $thetaC #>   1 2 #> 1 1 0 #> 2 0 1 #>  #> $theta #>      1    2 #> 1 0.15 0.00 #> 2 0.00 0.15 #>  ## how to use the theta and thetaC arguments: # data(DT_example) # DT <- DT_example # theta <- diag(2)*2; theta # initial VCs # thetaC <- diag(2)*3; thetaC # fixed VCs # ans1 <- mmec(Yield~Env, #              random= ~ vsc( atc(Env, levs=c(\"CA.2013\", \"CA.2011\"), #                             theta = theta,thetaC = thetaC),isc(Name) ), #              rcov= ~ units, nIters = 1, #              data=DT) # summary(ans1)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/atcg1234.html","id":null,"dir":"Reference","previous_headings":"","what":"Letter to number converter — atcg1234","title":"Letter to number converter — atcg1234","text":"function designed help users transform data letter format numeric format. Details format complex, just dataframe markers columns individuals rows. markers, extra columns plant names etc (names plants can stored rownames). function expects matrix polymorphic markers, please make sure clean data using function. apply function can help identify separate monomorphic polymorphic markers.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atcg1234.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Letter to number converter — atcg1234","text":"","code":"atcg1234(data, ploidy=2, format=\"ATCG\", maf=0, multi=TRUE,          silent=FALSE, by.allele=FALSE, imp=TRUE, ref.alleles=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/atcg1234.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Letter to number converter — atcg1234","text":"data dataframe markers columns individuals rows. Preferable rownames ID plants lose track . ploidy numeric value indicating ploidy level specie. default 2 means diploid. format one two possible values allowed program \"ATCG\", means calls base-pair-letter code, .e. \"\" diploid call, \"AATT\" tetraploid etc (just example). Therefore possible codes can \"\", \"T\", \"C\", \"G\", \"-\" (deletion), \"+\" (insertion). Alternatively \"AB\" format can used well. Commonly depends genotyping technologies used, GBS microarrays. addition, enabled also use single-letter code used Cornell, .e. =AA, C=CC, T=TT, G=GG, R=AG, Y=CT, S=CG, W=, K=GT, M=AC. case GBS code please make sure set N codes regular NAs handled R. \"ATCG\" format also works bi-allelic marker codes join map \"lm\", \"ll\",\"nn\", \"np\",\"hh\",\"hk\",\"kk\" maf minor allele frequency used filter SNP markers, default zero means markers returned numeric format. multi TRUE/FALSE statement indicating function get rid markers 2 alleles. FALSE, indicates markers multiple alleles found, alternate reference alleles first 2 alleles found. risky since alleles masked, .e. AA AG take G reference alternate alleles, converting numeric format 2 1 1, giving effect AG wrong assumption. default TRUE, removes markers two alleles. silent TRUE/FALSE value indicating progress bar drawn step conversion. default silent=FALSE, means want progress bar drawn. .allele TRUE/FALSE value indicating program transform data zero/one matrix presence/absense per allele. example, marker 3 alleles ,T,C diploid organism yield 6 possible configurations; AA, , AC, TT, TC, CC. Therefore, program create 3 columns marker indicating presence/absence allele genotype. imp TRUE/FALSE value indicating function impute missing data using median marker. FALSE, program impute. ref.alleles matrix reference alleles used conversion. matrix many columns markers reference alleles 2 rows, first row alternate allele (Alt) second row reference allele (Ref). Rownames \"Alt\" \"Ref\" respectively. provided program decide reference allele.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atcg1234.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Letter to number converter — atcg1234","text":"$data new dataframe markers numeric format markers columns individuals rows.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atcg1234.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Letter to number converter — atcg1234","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/atcg1234.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Letter to number converter — atcg1234","text":"","code":"data(DT_polyploid) genotypes <- GT_polyploid genotypes[1:5,1:5] # look the original format #>             c2_41437 c2_24258 c2_21332 c2_21320 c2_21318 #> A96104-2        AAAG     AAGG     TTCC     TTTT     CCCC #> A97066-42       AAGG     AGGG     TTCC     TTTT     TCCC #> ACBrador        AAGG     GGGG     TTCC     TTTT     <NA> #> ACLPI175395     AAAA     GGGG     CCCC     TTTT     <NA> #> ADGPI195204     AAAA     GGGG     CCCC     TTTT     <NA>  ####=================================================#### #### convert markers to numeric format polyploid potatoes ####=================================================#### # numo <- atcg1234(data=genotypes, ploidy=4) # numo$M[1:5,1:5]  ####=================================================#### #### convert markers to numeric format diploid rice lines #### single letter code for inbred lines from GBS pipeline #### A=AA, T=TT, C=CC, G=GG  ####=================================================#### # data(DT_rice) # X <- GT_rice; X[1:5,1:5]; dim(X) # numo2 <- atcg1234(data=X, ploidy=2) # numo2$M[1:5,1:5]"},{"path":"https://github.com/covaruber/sommer/reference/atcg1234BackTransform.html","id":null,"dir":"Reference","previous_headings":"","what":"Letter to number converter — atcg1234BackTransform","title":"Letter to number converter — atcg1234BackTransform","text":"function designed help users back transform numeric marker matrices function atcg1234 letters.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atcg1234BackTransform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Letter to number converter — atcg1234BackTransform","text":"","code":"atcg1234BackTransform(marks, refs)"},{"path":"https://github.com/covaruber/sommer/reference/atcg1234BackTransform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Letter to number converter — atcg1234BackTransform","text":"marks centered marker matrix coming atcg1234. refs 2 x m matrix m markers (columns) 2 rows reference alternate alleles marker indicated.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atcg1234BackTransform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Letter to number converter — atcg1234BackTransform","text":"markers new marker matrix leter coded according reference allele matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atcg1234BackTransform.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Letter to number converter — atcg1234BackTransform","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/atcg1234BackTransform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Letter to number converter — atcg1234BackTransform","text":"","code":"data(DT_polyploid) genotypes <- GT_polyploid genotypes[1:5,1:5] # look the original format #>             c2_41437 c2_24258 c2_21332 c2_21320 c2_21318 #> A96104-2        AAAG     AAGG     TTCC     TTTT     CCCC #> A97066-42       AAGG     AGGG     TTCC     TTTT     TCCC #> ACBrador        AAGG     GGGG     TTCC     TTTT     <NA> #> ACLPI175395     AAAA     GGGG     CCCC     TTTT     <NA> #> ADGPI195204     AAAA     GGGG     CCCC     TTTT     <NA>  # ####=================================================#### # #### convert markers to numeric format polyploid potatoes # ####=================================================#### # numo <- atcg1234(data=genotypes, ploidy=4) # numo$M[1:5,1:5] # numob <- atcg1234BackTransform(marks =  numo$M, refs =  numo$ref.alleles) # numob[1:4,1:4] #  # ####=================================================#### # #### convert markers to numeric format diploid rice lines # #### single letter code for inbred lines from GBS pipeline # #### A=AA, T=TT, C=CC, G=GG # ####=================================================#### # data(DT_rice) # X <- GT_rice; X[1:5,1:5]; dim(X) # numo2 <- atcg1234(data=X, ploidy=2) # numo2$M[1:5,1:5] # Xb <- atcg1234BackTransform(marks= numo2$M, refs= numo2$ref.alleles) # Xb[1:4,1:4]"},{"path":"https://github.com/covaruber/sommer/reference/atr.html","id":null,"dir":"Reference","previous_headings":"","what":"atr covariance structure — atr","title":"atr covariance structure — atr","text":"atr creates diagonal covariance structure specific levels random effect used mmer solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"atr covariance structure — atr","text":"","code":"atr(x, levs)"},{"path":"https://github.com/covaruber/sommer/reference/atr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"atr covariance structure — atr","text":"x vector observations random effect. levs levels random effect use building incidence matrices.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"atr covariance structure — atr","text":"$res list provided vector variance covariance structure expected.","code":""},{"path":"https://github.com/covaruber/sommer/reference/atr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"atr covariance structure — atr","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/atr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"atr covariance structure — atr","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/atr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"atr covariance structure — atr","text":"","code":"x <- as.factor(c(1:5,1:5,1:5));x #>  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 #> Levels: 1 2 3 4 5 atr(x) #> $Z #>    1 2 3 4 5 #> 1  1 0 0 0 0 #> 2  0 1 0 0 0 #> 3  0 0 1 0 0 #> 4  0 0 0 1 0 #> 5  0 0 0 0 1 #> 6  1 0 0 0 0 #> 7  0 1 0 0 0 #> 8  0 0 1 0 0 #> 9  0 0 0 1 0 #> 10 0 0 0 0 1 #> 11 1 0 0 0 0 #> 12 0 1 0 0 0 #> 13 0 0 1 0 0 #> 14 0 0 0 1 0 #> 15 0 0 0 0 1 #> attr(,\"assign\") #> [1] 1 1 1 1 1 #> attr(,\"contrasts\") #> attr(,\"contrasts\")$dummy #> [1] \"contr.treatment\" #>  #>  #> $thetaC #>   1 2 3 4 5 #> 1 1 0 0 0 0 #> 2 0 1 0 0 0 #> 3 0 0 1 0 0 #> 4 0 0 0 1 0 #> 5 0 0 0 0 1 #>  atr(x, c(\"1\",\"2\")) #> $Z #>    1 2 3 4 5 #> 1  1 0 0 0 0 #> 2  0 1 0 0 0 #> 3  0 0 1 0 0 #> 4  0 0 0 1 0 #> 5  0 0 0 0 1 #> 6  1 0 0 0 0 #> 7  0 1 0 0 0 #> 8  0 0 1 0 0 #> 9  0 0 0 1 0 #> 10 0 0 0 0 1 #> 11 1 0 0 0 0 #> 12 0 1 0 0 0 #> 13 0 0 1 0 0 #> 14 0 0 0 1 0 #> 15 0 0 0 0 1 #> attr(,\"assign\") #> [1] 1 1 1 1 1 #> attr(,\"contrasts\") #> attr(,\"contrasts\")$dummy #> [1] \"contr.treatment\" #>  #>  #> $thetaC #>   1 2 3 4 5 #> 1 1 0 0 0 0 #> 2 0 1 0 0 0 #> 3 0 0 0 0 0 #> 4 0 0 0 0 0 #> 5 0 0 0 0 0 #>"},{"path":"https://github.com/covaruber/sommer/reference/bathy.colors.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a sequence of colors for plotting bathymetric data. — bathy.colors","title":"Generate a sequence of colors for plotting bathymetric data. — bathy.colors","text":"bathy.colors(n) generates sequence \\(n\\)   colors along linear scale light grey pure blue.","code":""},{"path":"https://github.com/covaruber/sommer/reference/bathy.colors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a sequence of colors for plotting bathymetric data. — bathy.colors","text":"","code":"bathy.colors(n, alpha = 1)"},{"path":"https://github.com/covaruber/sommer/reference/bathy.colors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a sequence of colors for plotting bathymetric data. — bathy.colors","text":"n number colors return. alpha Alpha values passed rgb().","code":""},{"path":"https://github.com/covaruber/sommer/reference/bathy.colors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a sequence of colors for plotting bathymetric data. — bathy.colors","text":"vector blue scale colors.","code":""},{"path":"https://github.com/covaruber/sommer/reference/bathy.colors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a sequence of colors for plotting bathymetric data. — bathy.colors","text":"","code":"{ # Plot a colorbar using bathy.colors image(matrix(seq(100), 100), col=bathy.colors(100)) }"},{"path":"https://github.com/covaruber/sommer/reference/bivariateRun.html","id":null,"dir":"Reference","previous_headings":"","what":"bivariateRun functionality — bivariateRun","title":"bivariateRun functionality — bivariateRun","text":"Sometimes multi-trait models can present many singularities making model hard estimate many traits. One effective strategies estimate possible variance covariances splitting multiple bivariate models. function takes model t traits splits model many bivariate models needed estimate variance covariances provide initial values model traits.","code":""},{"path":"https://github.com/covaruber/sommer/reference/bivariateRun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"bivariateRun functionality — bivariateRun","text":"","code":"bivariateRun(model, n.core)"},{"path":"https://github.com/covaruber/sommer/reference/bivariateRun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"bivariateRun functionality — bivariateRun","text":"model model fitted mmer function argument return.param=TRUE. n.core number cores use mclapply function parallelize models run avoid increase computational time. Please keep mind available Linux macOS systems. Please check details mclapply documentation parallel package.","code":""},{"path":"https://github.com/covaruber/sommer/reference/bivariateRun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"bivariateRun functionality — bivariateRun","text":"$sigmas list variance covariance parameters traits together. $sigmascor list correlation variance components traits together. $model results bivariate models.","code":""},{"path":"https://github.com/covaruber/sommer/reference/bivariateRun.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"bivariateRun functionality — bivariateRun","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/bivariateRun.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"bivariateRun functionality — bivariateRun","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/bivariateRun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"bivariateRun functionality — bivariateRun","text":"","code":"# ####=========================================#### # ####=========================================#### # #### EXAMPLE 1 # #### simple example with univariate models # ####=========================================#### # ####=========================================#### # data(\"DT_cpdata\") # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # #### create the variance-covariance matrix # A <- A.mat(GT) # #### look at the data and fit the model # head(DT) # ans.m <- mmer(cbind(Yield,color,FruitAver, Firmness)~1, #                random=~ vsr(id, Gu=A, Gtc=unsm(4)) #                + vsr(Rowf,Gtc=diag(4)) #                + vsr(Colf,Gtc=diag(4)), na.method.Y=\"include\", #                rcov=~ vsr(units,Gtc=unsm(4)), return.param = TRUE, #                data=DT) #  # # define the number of cores (number of bivariate models) as (nt*(nt-1))/2  # nt=4 # (nt*(nt-1))/2 # res <- bivariateRun(ans.m,n.core = 6) # # now use the variance componets to fit a join model # mm <- transformConstraints(ans.m[[8]],3) #  # ans.m.final <- mmer(cbind(Yield,color,FruitAver, Firmness)~1, #               random=~ vsr(id, Gu=A, Gtc=unsm(4)) #               + vsr(Rowf,Gtc=diag(4)) #               + vsr(Colf,Gtc=diag(4)), na.method.Y=\"include\", #               rcov=~ vsr(units,Gtc=unsm(4)),  #               init = res$sigmas_scaled, constraints = mm, #               data=DT, iters=1) #  # summary(ans.m.final)"},{"path":"https://github.com/covaruber/sommer/reference/build.HMM.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a hybrid marker matrix using parental genotypes from inbred individuals — build.HMM","title":"Build a hybrid marker matrix using parental genotypes from inbred individuals — build.HMM","text":"Uses 2 marker matrices sets inbred partially inbred parents creates possible combinations unless user specifies hybrid genotypes build (custom.hyb argument). returns additive dominance marker matrices (-1,0,1; homo,het,homo additive 0,1,0; homo,het,homo dominance).","code":""},{"path":"https://github.com/covaruber/sommer/reference/build.HMM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a hybrid marker matrix using parental genotypes from inbred individuals — build.HMM","text":"","code":"build.HMM(M1,M2, custom.hyb=NULL, return.combos.only=FALSE,separator=\":\")"},{"path":"https://github.com/covaruber/sommer/reference/build.HMM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a hybrid marker matrix using parental genotypes from inbred individuals — build.HMM","text":"M1 Matrix (\\(n \\times m\\)) unphased genotypes \\(n\\) inbreds \\(m\\) biallelic markers, coded {-1,0,1}. Fractional (imputed) missing values (NA) allowed. M2 Matrix (\\(n \\times m\\)) unphased genotypes \\(n\\) inbreds \\(m\\) biallelic markers, coded {-1,0,1}. Fractional (imputed) missing values (NA) allowed. custom.hyb data frame columns 'Var1' 'Var2', 'hybrid' specifies hybrids built using M1 M2 matrices provided. return.combos.TRUE/FALSE statement inicating function skip building geotype matrix hybrids return data frame possible combinations build. case user wants subset hybrids building marker matrix. separator desired character used pasting male female columns assign name hybrids.","code":""},{"path":"https://github.com/covaruber/sommer/reference/build.HMM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build a hybrid marker matrix using parental genotypes from inbred individuals — build.HMM","text":"returns marker matrix hybrids coded additive (-1,0,1; homo,het,homo) dominance (0,1,0; homo,het,homo). function deviced building marker matrices hybrids coming inbreds. parents close inbred >F5 can try deleting heterozygote calls (0's) imputing cells common genotype (1 -1). expectation mostly inbred individuals may change drastically result make results interpretable. non-inbred parents (F1 F3) cross F1 x F1 many possibilities intention function build genotypes heterzygote x heterozygote crosses.","code":""},{"path":"https://github.com/covaruber/sommer/reference/build.HMM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a hybrid marker matrix using parental genotypes from inbred individuals — build.HMM","text":"returns marker matrix hybrids coded additive (-1,0,1; homo,het,homo) dominance (0,1,0; homo,het,homo). $HMM.add marker matrix hybrids coded additive (-1,0,1; homo,het,homo) $HMM.dom marker matrix hybrids coded dominance (0,1,0; homo,het,homo) $data.used data frame used build hybrid genotypes","code":""},{"path":"https://github.com/covaruber/sommer/reference/build.HMM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Build a hybrid marker matrix using parental genotypes from inbred individuals — build.HMM","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Nishio M Satoh M. 2014. Including Dominance Effects Genomic BLUP Method Genomic Evaluation. Plos One 9(1), doi:10.1371/journal.pone.0085792 Su G, Christensen , Ostersen T, Henryon M, Lund MS. 2012. Estimating Additive Non-Additive Genetic Variances Predicting Genetic Merits Using Genome-Wide Dense Single Nucleotide Polymorphism Markers. PLoS ONE 7(9): e45293. doi:10.1371/journal.pone.0045293","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/build.HMM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build a hybrid marker matrix using parental genotypes from inbred individuals — build.HMM","text":"","code":"####=========================================#### #### use Technow data as example ####=========================================#### data(DT_technow) DT <- DT_technow Md <- (Md_technow * 2) - 1 Mf <- (Mf_technow * 2) - 1   ## first get all possible hybrids res1 <- build.HMM(Md, Mf,                    return.combos.only = TRUE) head(res1$data.used) #>   Var1 Var2  hybrid #> 1  513  316 513:316 #> 2  518  316 518:316 #> 3  536  316 536:316 #> 4  545  316 545:316 #> 5  546  316 546:316 #> 6  548  316 548:316  ## build the marker matrix for the first 50 hybrids res2 <- build.HMM(Md, Mf,                  custom.hyb = res1$data.used[1:50,]                  ) #> Building hybrid marker matrix for 50 hybrids #> Extracting M1 contribution #> Extracting M2 contribution #> Done!! res2$HMM.add[1:5,1:5] #>         SYN79 PZE.101000088 PZE.101000108 PZE.101000169 PZE.101000209 #> 513:316     1             1             1             0             1 #> 518:316     1             1             1             0             1 #> 536:316     1             1             1             0             1 #> 545:316     1             1             1             0             1 #> 546:316     1             1             1             0             1 res2$HMM.dom[1:5,1:5] #>         SYN79 PZE.101000088 PZE.101000108 PZE.101000169 PZE.101000209 #> 513:316     0             0             0             1             0 #> 518:316     0             0             0             1             0 #> 536:316     0             0             0             1             0 #> 545:316     0             0             0             1             0 #> 546:316     0             0             0             1             0  ## now you can use the A.mat(), D.mat() and E.mat() functions # M <- res2$HMM.add # A <- A.mat(M) # D <- D.mat(M)"},{"path":"https://github.com/covaruber/sommer/reference/coef_mmec.html","id":null,"dir":"Reference","previous_headings":"","what":"coef form a GLMM fitted with mmec — coef.mmec","title":"coef form a GLMM fitted with mmec — coef.mmec","text":"coef method class \"mmec\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/coef_mmec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"coef form a GLMM fitted with mmec — coef.mmec","text":"","code":"# S3 method for class 'mmec' coef(object, ...)"},{"path":"https://github.com/covaruber/sommer/reference/coef_mmec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"coef form a GLMM fitted with mmec — coef.mmec","text":"object object class \"mmec\" ... arguments passed","code":""},{"path":"https://github.com/covaruber/sommer/reference/coef_mmec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"coef form a GLMM fitted with mmec — coef.mmec","text":"vector coef","code":""},{"path":"https://github.com/covaruber/sommer/reference/coef_mmec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"coef form a GLMM fitted with mmec — coef.mmec","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/coef_mmer.html","id":null,"dir":"Reference","previous_headings":"","what":"coef form a GLMM fitted with mmer — coef.mmer","title":"coef form a GLMM fitted with mmer — coef.mmer","text":"coef method class \"mmer\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/coef_mmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"coef form a GLMM fitted with mmer — coef.mmer","text":"","code":"# S3 method for class 'mmer' coef(object, ...)"},{"path":"https://github.com/covaruber/sommer/reference/coef_mmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"coef form a GLMM fitted with mmer — coef.mmer","text":"object object class \"mmer\" ... arguments passed","code":""},{"path":"https://github.com/covaruber/sommer/reference/coef_mmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"coef form a GLMM fitted with mmer — coef.mmer","text":"vector coef","code":""},{"path":"https://github.com/covaruber/sommer/reference/coef_mmer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"coef form a GLMM fitted with mmer — coef.mmer","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/corImputation.html","id":null,"dir":"Reference","previous_headings":"","what":"Imputing a matrix using correlations — corImputation","title":"Imputing a matrix using correlations — corImputation","text":"corImputation imputes missing data based correlation exists row levels.","code":""},{"path":"https://github.com/covaruber/sommer/reference/corImputation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imputing a matrix using correlations — corImputation","text":"","code":"corImputation(wide, Gu=NULL, nearest=10, roundR=FALSE)"},{"path":"https://github.com/covaruber/sommer/reference/corImputation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imputing a matrix using correlations — corImputation","text":"wide numeric matrix individuals rows time variable columns (e.g., environments, genetic markers, etc.). Gu optional correlation matrix individuals row levels. NULL computed correlation t(wide). nearest integer value describing many nearest neighbours (ones showing highest correlation) used average return imputed value. roundR TRUE/FALSE statement describing average result rounded . may specifically useful categorical data form numbers (e.g., -1,0,1).","code":""},{"path":"https://github.com/covaruber/sommer/reference/corImputation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Imputing a matrix using correlations — corImputation","text":"$res list imputed matrix original matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/corImputation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Imputing a matrix using correlations — corImputation","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/corImputation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Imputing a matrix using correlations — corImputation","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/corImputation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Imputing a matrix using correlations — corImputation","text":"","code":"#################################### ### imputing genotype data example #################################### # data(DT_cpdata) # X <- GT_cpdata # # add missing data # v <- sample(1:length(X), 500) # Xna <- X # Xna[v]<- NA # ## impute (can take some time) # Y <- corImputation(wide=Xna, Gu=NULL, nearest=20, roundR=TRUE)  # cm <- table(Y$imputed[v],X[v]) # ## calculate accuracy # sum(diag(cm))/length(v) #################################### ### imputing phenotypic data example #################################### # data(DT_h2) # X <- reshape(DT_h2[,c(\"Name\",\"Env\",\"y\")], direction = \"wide\", idvar = \"Name\", #                 timevar = \"Env\", v.names = \"y\", sep= \"_\") # rownames(X) <- X$Name # X <- as.matrix(X[,-1]) # head(X) # # add missing data # v <- sample(1:length(X), 50) # Xna <- X # Xna[v]<- NA # ## impute # Y <- corImputation(wide=Xna, Gu=NULL, nearest=20, roundR=TRUE) # plot(y=Y$imputed[v],x=X[v], xlab=\"true\",ylab=\"predicted\") # cor(Y$imputed[v],X[v], use = \"complete.obs\")"},{"path":"https://github.com/covaruber/sommer/reference/covc.html","id":null,"dir":"Reference","previous_headings":"","what":"covariance between random effects — covc","title":"covariance between random effects — covc","text":"covc merges incidence matrices covariance matrices two random effects fit unstructured model 2 different random effects fitted mmec solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/covc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"covariance between random effects — covc","text":"","code":"covc(ran1, ran2, thetaC=NULL, theta=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/covc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"covariance between random effects — covc","text":"ran1 random call first random effect. ran2 random call first random effect. thetaC optional matrix constraints variance components. theta optional symmetric matrix initial values variance-covariance components. providing customized values, values scaled respect original variance. example, provide initial value 1 given variance component, theta built : theta = matrix( 1 / var(response) ) symmetric matrix many rows columns number levels factor 'x'. values matrix define initial values variance-covariance components subject constraints provided thetaC. provided, initial values calculated : theta = diag(ncol(mm))*.05 + matrix(.1,ncol(mm),ncol(mm)) mm incidence matrix factor 'x'.","code":""},{"path":"https://github.com/covaruber/sommer/reference/covc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"covariance between random effects — covc","text":"implementation aims fit models covariance random variables expected exist. example, indirect genetic effects.","code":""},{"path":"https://github.com/covaruber/sommer/reference/covc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"covariance between random effects — covc","text":"$Z incidence matrix Z* = Z Gamma original incidence matrix timevar multiplied loadings.","code":""},{"path":"https://github.com/covaruber/sommer/reference/covc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"covariance between random effects — covc","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Bijma, P. (2014). quantitative genetics indirect genetic effects: selective review modelling issues. Heredity, 112(1), 61-69.","code":""},{"path":"https://github.com/covaruber/sommer/reference/covc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"covariance between random effects — covc","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/covc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"covariance between random effects — covc","text":"","code":"data(DT_ige) DT <- DT_ige covRes <- with(DT, covc( vsc(isc(focal)) , vsc(isc(neighbour)) ) ) str(covRes) #> List of 7 #>  $ Z          :List of 2 #>   ..$ :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. .. ..@ i       : int [1:1000] 305 313 542 567 605 619 626 717 953 131 ... #>   .. .. ..@ p       : int [1:99] 0 9 14 20 22 25 28 32 86 91 ... #>   .. .. ..@ Dim     : int [1:2] 1000 98 #>   .. .. ..@ Dimnames:List of 2 #>   .. .. .. ..$ : chr [1:1000] \"1\" \"2\" \"3\" \"4\" ... #>   .. .. .. ..$ : chr [1:98] \"id_1019\" \"id_1101\" \"id_1137\" \"id_1268\" ... #>   .. .. ..@ x       : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... #>   .. .. ..@ factors : list() #>   ..$ :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. .. ..@ i       : int [1:1000] 350 567 591 593 595 717 755 859 105 200 ... #>   .. .. ..@ p       : int [1:99] 0 8 14 21 24 28 30 32 84 88 ... #>   .. .. ..@ Dim     : int [1:2] 1000 98 #>   .. .. ..@ Dimnames:List of 2 #>   .. .. .. ..$ : chr [1:1000] \"1\" \"2\" \"3\" \"4\" ... #>   .. .. .. ..$ : chr [1:98] \"id_1019\" \"id_1101\" \"id_1137\" \"id_1268\" ... #>   .. .. ..@ x       : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... #>   .. .. ..@ factors : list() #>  $ Gu         :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. ..@ i       : int [1:98] 0 1 2 3 4 5 6 7 8 9 ... #>   .. ..@ p       : int [1:99] 0 1 2 3 4 5 6 7 8 9 ... #>   .. ..@ Dim     : int [1:2] 98 98 #>   .. ..@ Dimnames:List of 2 #>   .. .. ..$ : chr [1:98] \"id_1019\" \"id_1101\" \"id_1137\" \"id_1268\" ... #>   .. .. ..$ : chr [1:98] \"id_1019\" \"id_1101\" \"id_1137\" \"id_1268\" ... #>   .. ..@ x       : num [1:98] 1 1 1 1 1 1 1 1 1 1 ... #>   .. ..@ factors : list() #>  $ theta      : num [1:2, 1:2] 0.165 0.015 0.015 0.165 #>  $ thetaC     : num [1:2, 1:2] 1 0 2 1 #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:2] \"ran1\" \"ran2\" #>   .. ..$ : chr [1:2] \"ran1\" \"ran2\" #>  $ thetaF     : num[0 , 0 ]  #>  $ partitionsR: list() #>  $ sp         : num(0)  # look at DT_ige help page to see how to fit an actual model"},{"path":"https://github.com/covaruber/sommer/reference/csc.html","id":null,"dir":"Reference","previous_headings":"","what":"customized covariance structure — csc","title":"customized covariance structure — csc","text":"csc creates customized covariance structure specific levels random effect used mmec solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/csc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"customized covariance structure — csc","text":"","code":"csc(x, mm, thetaC, theta)"},{"path":"https://github.com/covaruber/sommer/reference/csc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"customized covariance structure — csc","text":"x vector observations random effect. mm customized variance-covariance structure levels random effect. thetaC optional symmetric matrix constraints variance-covariance components. symmetric matrix many rows columns number levels factor 'x'. values matrix define variance-covariance components estimated: 0: component estimated 1: component estimated constrained positive 2: component estimated unconstrained 3: component fixed value provided theta argument  theta optional symmetric matrix initial values variance-covariance components. providing customized values, values scaled respect original variance. example, provide initial value 1 given variance component, theta built : theta = matrix( 1 / var(response) ) symmetric matrix many rows columns number levels factor 'x'. values matrix define initial values variance-covariance components subject constraints provided thetaC. provided, initial values calculated : theta = diag(ncol(mm))*.05 + matrix(.1,ncol(mm),ncol(mm)) mm incidence matrix factor 'x'.","code":""},{"path":"https://github.com/covaruber/sommer/reference/csc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"customized covariance structure — csc","text":"$res list provided vector variance covariance structure expected levels random effect.","code":""},{"path":"https://github.com/covaruber/sommer/reference/csc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"customized covariance structure — csc","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/csc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"customized covariance structure — csc","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/csc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"customized covariance structure — csc","text":"","code":"x <- as.factor(c(1:5,1:5,1:5));x #>  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 #> Levels: 1 2 3 4 5 csc(x,matrix(1,5,5)) #> $Z #> 15 x 5 sparse Matrix of class \"dgCMatrix\" #>    1 2 3 4 5 #> 1  1 . . . . #> 2  . 1 . . . #> 3  . . 1 . . #> 4  . . . 1 . #> 5  . . . . 1 #> 6  1 . . . . #> 7  . 1 . . . #> 8  . . 1 . . #> 9  . . . 1 . #> 10 . . . . 1 #> 11 1 . . . . #> 12 . 1 . . . #> 13 . . 1 . . #> 14 . . . 1 . #> 15 . . . . 1 #>  #> $thetaC #>   1 2 3 4 5 #> 1 1 1 1 1 1 #> 2 0 1 1 1 1 #> 3 0 0 1 1 1 #> 4 0 0 0 1 1 #> 5 0 0 0 0 1 #>  #> $theta #>      1     2     3     4     5 #> 1 0.15 0.075 0.075 0.075 0.075 #> 2 0.15 0.150 0.075 0.075 0.075 #> 3 0.15 0.150 0.150 0.075 0.075 #> 4 0.15 0.150 0.150 0.150 0.075 #> 5 0.15 0.150 0.150 0.150 0.150 #>"},{"path":"https://github.com/covaruber/sommer/reference/csr.html","id":null,"dir":"Reference","previous_headings":"","what":"customized covariance structure — csr","title":"customized covariance structure — csr","text":"csr creates customized covariance structure specific levels random effect used mmer solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/csr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"customized covariance structure — csr","text":"","code":"csr(x, mm)"},{"path":"https://github.com/covaruber/sommer/reference/csr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"customized covariance structure — csr","text":"x vector observations random effect. mm customized variance-covariance structure levels random effect.","code":""},{"path":"https://github.com/covaruber/sommer/reference/csr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"customized covariance structure — csr","text":"$res list provided vector variance covariance structure expected levels random effect.","code":""},{"path":"https://github.com/covaruber/sommer/reference/csr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"customized covariance structure — csr","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/csr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"customized covariance structure — csr","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/csr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"customized covariance structure — csr","text":"","code":"x <- as.factor(c(1:5,1:5,1:5));x #>  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 #> Levels: 1 2 3 4 5 csr(x,matrix(1,5,5)) #> $Z #>    1 2 3 4 5 #> 1  1 0 0 0 0 #> 2  0 1 0 0 0 #> 3  0 0 1 0 0 #> 4  0 0 0 1 0 #> 5  0 0 0 0 1 #> 6  1 0 0 0 0 #> 7  0 1 0 0 0 #> 8  0 0 1 0 0 #> 9  0 0 0 1 0 #> 10 0 0 0 0 1 #> 11 1 0 0 0 0 #> 12 0 1 0 0 0 #> 13 0 0 1 0 0 #> 14 0 0 0 1 0 #> 15 0 0 0 0 1 #> attr(,\"assign\") #> [1] 1 1 1 1 1 #> attr(,\"contrasts\") #> attr(,\"contrasts\")$dummy #> [1] \"contr.treatment\" #>  #>  #> $thetaC #>   1 2 3 4 5 #> 1 1 1 1 1 1 #> 2 1 1 1 1 1 #> 3 1 1 1 1 1 #> 4 1 1 1 1 1 #> 5 1 1 1 1 1 #>"},{"path":"https://github.com/covaruber/sommer/reference/dfToMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"data frame to matrix — dfToMatrix","title":"data frame to matrix — dfToMatrix","text":"function takes matrix data frame format transforms matrix. packages allows obtain additive relationship matrix pedigree `pedigreemm` package.","code":""},{"path":"https://github.com/covaruber/sommer/reference/dfToMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"data frame to matrix — dfToMatrix","text":"","code":"dfToMatrix(x, row=\"Row\",column=\"Column\",              value=\"Ainverse\", returnInverse=FALSE,               bend=1e-6)"},{"path":"https://github.com/covaruber/sommer/reference/dfToMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"data frame to matrix — dfToMatrix","text":"x ginv element, output Ainverse function. row name column x indicates row original relationship matrix. column name column x indicates column original relationship matrix. value name column x indicates value given row column original relationship matrix. returnInverse TRUE/FALSE value indicating inverse x matrix computed data frame x converted matrix. bend numeric value add diagonal matrix case matrix singular inversion.","code":""},{"path":"https://github.com/covaruber/sommer/reference/dfToMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"data frame to matrix — dfToMatrix","text":"K pedigree transformed relationship matrix. Kinv inverse pedigree transformed relationship matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/dfToMatrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"data frame to matrix — dfToMatrix","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/dfToMatrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"data frame to matrix — dfToMatrix","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/dfToMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"data frame to matrix — dfToMatrix","text":"","code":"library(Matrix) m <- matrix(1:9,3,3) m <- tcrossprod(m)  mdf <- as.data.frame(as.table(m)) mdf #>   Var1 Var2 Freq #> 1    A    A   66 #> 2    B    A   78 #> 3    C    A   90 #> 4    A    B   78 #> 5    B    B   93 #> 6    C    B  108 #> 7    A    C   90 #> 8    B    C  108 #> 9    C    C  126  dfToMatrix(mdf, row = \"Var1\", column = \"Var2\",              value = \"Freq\",returnInverse=FALSE ) #> $K #> 3 x 3 sparse Matrix of class \"dgCMatrix\" #>                 #> [1,] 66  78  90 #> [2,] 78  93 108 #> [3,] 90 108 126 #>  #> $Kinv #> NULL #>"},{"path":"https://github.com/covaruber/sommer/reference/dsc.html","id":null,"dir":"Reference","previous_headings":"","what":"diagonal covariance structure — dsc","title":"diagonal covariance structure — dsc","text":"dsc creates diagonal covariance structure levels random effect  used mmec solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/dsc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"diagonal covariance structure — dsc","text":"","code":"dsc(x, thetaC=NULL, theta=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/dsc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"diagonal covariance structure — dsc","text":"x vector observations random effect. thetaC optional symmetric matrix constraints variance-covariance components. symmetric matrix many rows columns number levels factor 'x'. values matrix define variance-covariance components estimated: 0: component estimated 1: component estimated constrained positive 2: component estimated unconstrained 3: component fixed value provided theta argument  theta optional symmetric matrix initial values variance-covariance components. providing customized values, values scaled respect original variance. example, provide initial value 1 given variance component, theta built : theta = matrix( 1 / var(response) ) symmetric matrix many rows columns number levels factor 'x'. values matrix define initial values variance-covariance components subject constraints provided thetaC. provided, initial values calculated : diag(ncol(mm))*.05 + matrix(.1,ncol(mm),ncol(mm)) mm incidence matrix factor 'x'.","code":""},{"path":"https://github.com/covaruber/sommer/reference/dsc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"diagonal covariance structure — dsc","text":"$res list provided vector variance covariance structure expected levels random effect.","code":""},{"path":"https://github.com/covaruber/sommer/reference/dsc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"diagonal covariance structure — dsc","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/dsc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"diagonal covariance structure — dsc","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/dsc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"diagonal covariance structure — dsc","text":"","code":"x <- as.factor(c(1:5,1:5,1:5));x #>  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 #> Levels: 1 2 3 4 5 dsc(x) #> $Z #> 15 x 5 sparse Matrix of class \"dgCMatrix\" #>    1 2 3 4 5 #> 1  1 . . . . #> 2  . 1 . . . #> 3  . . 1 . . #> 4  . . . 1 . #> 5  . . . . 1 #> 6  1 . . . . #> 7  . 1 . . . #> 8  . . 1 . . #> 9  . . . 1 . #> 10 . . . . 1 #> 11 1 . . . . #> 12 . 1 . . . #> 13 . . 1 . . #> 14 . . . 1 . #> 15 . . . . 1 #>  #> $thetaC #>   1 2 3 4 5 #> 1 1 0 0 0 0 #> 2 0 1 0 0 0 #> 3 0 0 1 0 0 #> 4 0 0 0 1 0 #> 5 0 0 0 0 1 #>  #> $theta #>      1    2    3    4    5 #> 1 0.15 0.00 0.00 0.00 0.00 #> 2 0.00 0.15 0.00 0.00 0.00 #> 3 0.00 0.00 0.15 0.00 0.00 #> 4 0.00 0.00 0.00 0.15 0.00 #> 5 0.00 0.00 0.00 0.00 0.15 #>  ## how to use the theta and thetaC arguments: # data(DT_example) # DT <- DT_example # theta <- diag(3)*2; theta # initial VCs # thetaC <- diag(3)*3; thetaC # fixed VCs # ans1 <- mmec(Yield~Env, #              random= ~ vsc( dsc(Env,theta = theta,thetaC = thetaC),isc(Name) ), #              rcov= ~ units, #              data=DT) # summary(ans1)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/dsr.html","id":null,"dir":"Reference","previous_headings":"","what":"diagonal covariance structure — dsr","title":"diagonal covariance structure — dsr","text":"dsr creates diagonal covariance structure levels random effect  used mmer solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/dsr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"diagonal covariance structure — dsr","text":"","code":"dsr(x)"},{"path":"https://github.com/covaruber/sommer/reference/dsr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"diagonal covariance structure — dsr","text":"x vector observations random effect.","code":""},{"path":"https://github.com/covaruber/sommer/reference/dsr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"diagonal covariance structure — dsr","text":"$res list provided vector variance covariance structure expected levels random effect.","code":""},{"path":"https://github.com/covaruber/sommer/reference/dsr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"diagonal covariance structure — dsr","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/dsr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"diagonal covariance structure — dsr","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/dsr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"diagonal covariance structure — dsr","text":"","code":"x <- as.factor(c(1:5,1:5,1:5));x #>  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 #> Levels: 1 2 3 4 5 dsr(x) #> $Z #>    1 2 3 4 5 #> 1  1 0 0 0 0 #> 2  0 1 0 0 0 #> 3  0 0 1 0 0 #> 4  0 0 0 1 0 #> 5  0 0 0 0 1 #> 6  1 0 0 0 0 #> 7  0 1 0 0 0 #> 8  0 0 1 0 0 #> 9  0 0 0 1 0 #> 10 0 0 0 0 1 #> 11 1 0 0 0 0 #> 12 0 1 0 0 0 #> 13 0 0 1 0 0 #> 14 0 0 0 1 0 #> 15 0 0 0 0 1 #> attr(,\"assign\") #> [1] 1 1 1 1 1 #> attr(,\"contrasts\") #> attr(,\"contrasts\")$dummy #> [1] \"contr.treatment\" #>  #>  #> $thetaC #>   1 2 3 4 5 #> 1 1 0 0 0 0 #> 2 0 1 0 0 0 #> 3 0 0 1 0 0 #> 4 0 0 0 1 0 #> 5 0 0 0 0 1 #>"},{"path":"https://github.com/covaruber/sommer/reference/fcm.html","id":null,"dir":"Reference","previous_headings":"","what":"fixed effect constraint indication matrix — fcm","title":"fixed effect constraint indication matrix — fcm","text":"fcm creates matrix correct number columns specify constraint fixed effects using Gtc argument vsr function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/fcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fixed effect constraint indication matrix — fcm","text":"","code":"fcm(x, reps=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/fcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fixed effect constraint indication matrix — fcm","text":"x vector 1's 0's corresponding traits fixed effect fitted. example, trivariate model fixed effect \"x\" wants fitted trait 1 2 3rd trait use fcm(c(1,1,0)) Gtc argument vsr() function. reps integer specifying number times matrix repeated list format provide easily constraints complex models use ds(), us() cs() structures.","code":""},{"path":"https://github.com/covaruber/sommer/reference/fcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"fixed effect constraint indication matrix — fcm","text":"$res matrix list matrices constraints provided Gtc argument vsr function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/fcm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"fixed effect constraint indication matrix — fcm","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/fcm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"fixed effect constraint indication matrix — fcm","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/fcm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"fixed effect constraint indication matrix — fcm","text":"","code":"fcm(c(1,1,0)) #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #> [3,]    0    0 fcm(c(0,1,1)) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    1    0 #> [3,]    0    1 fcm(c(1,1,1)) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1  fcm(c(1,1,1),2) #> [[1]] #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1 #>  #> [[2]] #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1 #>   # ## model with Env estimated for both traits # data(DT_example) # DT <- DT_example # A <- A_example # ans4 <- mmer(cbind(Yield, Weight) ~ Env, #               random= ~ vsr(Name) + vsr(Env:Name), #               rcov= ~ vsr(units), #               data=DT) # summary(ans4)$betas # ## model with Env only estimated for Yield # ans4b <- mmer(cbind(Yield, Weight) ~ vsr(Env, Gtc=fcm(c(1,0))), #              random= ~ vsr(Name) + vsr(Env:Name), #              rcov= ~ vsr(units), #              data=DT) # summary(ans4b)$betas"},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmec.html","id":null,"dir":"Reference","previous_headings":"","what":"fitted form a LMM fitted with mmec — fitted.mmec","title":"fitted form a LMM fitted with mmec — fitted.mmec","text":"fitted method class \"mmec\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fitted form a LMM fitted with mmec — fitted.mmec","text":"","code":"# S3 method for class 'mmec' fitted(object, ...)"},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fitted form a LMM fitted with mmec — fitted.mmec","text":"object object class \"mmec\" ... arguments passed mmec function","code":""},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"fitted form a LMM fitted with mmec — fitted.mmec","text":"vector fitted values form y.hat = Xb + Zu including terms model.","code":""},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"fitted form a LMM fitted with mmec — fitted.mmec","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"fitted form a LMM fitted with mmec — fitted.mmec","text":"","code":"# data(DT_cpdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # #### create the variance-covariance matrix # A <- A.mat(GT) # additive relationship matrix # #### look at the data and fit the model # head(DT) # mix1 <- mmer(Yield~1, #               random=~vsr(id,Gu=A) #                       + Rowf + Colf + spl2Da(Row,Col), #               rcov=~units, #               data=DT) #  # ff=fitted(mix1) #  # colfunc <- colorRampPalette(c(\"steelblue4\",\"springgreen\",\"yellow\")) # lattice::wireframe(`u:Row.fitted`~Row*Col, data=ff$dataWithFitted,   #           aspect=c(61/87,0.4), drape=TRUE,# col.regions = colfunc, #           light.source=c(10,0,10)) # lattice::levelplot(`u:Row.fitted`~Row*Col, data=ff$dataWithFitted, col.regions = colfunc)"},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmer.html","id":null,"dir":"Reference","previous_headings":"","what":"fitted form a LMM fitted with mmer — fitted.mmer","title":"fitted form a LMM fitted with mmer — fitted.mmer","text":"fitted method class \"mmer\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fitted form a LMM fitted with mmer — fitted.mmer","text":"","code":"# S3 method for class 'mmer' fitted(object, ...)"},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fitted form a LMM fitted with mmer — fitted.mmer","text":"object object class \"mmer\" ... arguments passed mmer function","code":""},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"fitted form a LMM fitted with mmer — fitted.mmer","text":"vector fitted values form y.hat = Xb + Zu including terms model.","code":""},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"fitted form a LMM fitted with mmer — fitted.mmer","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/fitted_mmer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"fitted form a LMM fitted with mmer — fitted.mmer","text":"","code":"# data(DT_cpdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # #### create the variance-covariance matrix # A <- A.mat(GT) # additive relationship matrix # #### look at the data and fit the model # head(DT) # mix1 <- mmer(Yield~1, #               random=~vsr(id,Gu=A) #                       + Rowf + Colf + spl2Da(Row,Col), #               rcov=~units, #               data=DT) #  # ff=fitted(mix1) #  # colfunc <- colorRampPalette(c(\"steelblue4\",\"springgreen\",\"yellow\")) # lattice::wireframe(`u:Row.fitted`~Row*Col, data=ff$dataWithFitted,   #           aspect=c(61/87,0.4), drape=TRUE,# col.regions = colfunc, #           light.source=c(10,0,10)) # lattice::levelplot(`u:Row.fitted`~Row*Col, data=ff$dataWithFitted, col.regions = colfunc)"},{"path":"https://github.com/covaruber/sommer/reference/fixm.html","id":null,"dir":"Reference","previous_headings":"","what":"fixed indication matrix — fixm","title":"fixed indication matrix — fixm","text":"fixm creates square matrix 3's diagnals -diagonals quickly specify fixed constraint Gtc argument vsr function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/fixm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fixed indication matrix — fixm","text":"","code":"fixm(x, reps=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/fixm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fixed indication matrix — fixm","text":"x integer specifying number traits fitted given random effect. reps integer specifying number times matrix repeated list format provide easily constraints complex models use ds(), us() cs() structures.","code":""},{"path":"https://github.com/covaruber/sommer/reference/fixm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"fixed indication matrix — fixm","text":"$res matrix list matrices constraints provided Gtc argument vsr function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/fixm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"fixed indication matrix — fixm","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/fixm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"fixed indication matrix — fixm","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/fixm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"fixed indication matrix — fixm","text":"","code":"fixm(4) #>      [,1] [,2] [,3] [,4] #> [1,]    3    3    3    3 #> [2,]    3    3    3    3 #> [3,]    3    3    3    3 #> [4,]    3    3    3    3 fixm(4,2) #> [[1]] #>      [,1] [,2] [,3] [,4] #> [1,]    3    3    3    3 #> [2,]    3    3    3    3 #> [3,]    3    3    3    3 #> [4,]    3    3    3    3 #>  #> [[2]] #>      [,1] [,2] [,3] [,4] #> [1,]    3    3    3    3 #> [2,]    3    3    3    3 #> [3,]    3    3    3    3 #> [4,]    3    3    3    3 #>"},{"path":"https://github.com/covaruber/sommer/reference/gvsr.html","id":null,"dir":"Reference","previous_headings":"","what":"general variance structure specification — gvsr","title":"general variance structure specification — gvsr","text":"gvsr function build general variance-covariance structures combination random effects fitted mmer solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/gvsr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"general variance structure specification — gvsr","text":"","code":"gvsr(..., Gu=NULL, Guc=NULL, Gti=NULL, Gtc=NULL, form=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/gvsr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"general variance structure specification — gvsr","text":"... names random effects (variables dataset) used create general variance structure. example, 2 random effects (variables); mom progeny, model specified : gvsr(mom, progeny) create variance structure form: | sigma2.m   sigma.pm | | sigma.pm   sigma2.p | variance components random effect estimated also covariance component 2 random effects estimated. user can also provide numeric vector matrix considered design matrix ith random effect. two random effects can provided.  Gu list matrices known variance-covariance values levels different random effects provided \"...\" argument (.e. relationship matrix among individuals known covariance matrix). NULL, identity matrix assumed. example, model 2 random effects covariance structure provided : gvsr(mom, progeny, Gu=list(,Ap)) Ap relationship matrices random effects mom progeny respectively.  Guc matrix constraints u random effects. used specify variance covariance parameters 1 1 combinations random effects estimated. example, 2 random effects expected variance-covariance matrix expected estimated (default Guc=NULL) unstructured model: | sigma2.m   sigma.pm | | sigma.pm   sigma2.p | user can constrain parameters estimated. Providing: Guc=diag(2)     fit: | sigma2.m  ...0... | | ...0...  sigma2.p |  Gti matrix dimensions t x t (t equal number traits) initial values variance-covariance components random effect specified .... argument. value NULL program provide initial values. Gtc matrix dimensions t x t (t equal number traits) constraints variance-covariance components random effect specified ... argument according following rules: 0: estimated 1: estimated constrained positive (.e. variance component) 2: estimated unconstrained (can negative positive, .e. covariance component) 3: estimated fixed (value provided Gti argument) multi-response scenario user specify argument default build unstructured matrix (using unsm() function). argument needs used wisely since covariance among responses may make sense. Useful functions specify constraints ; diag(), unsm(), fixm(). form additional structure specify kronecker product top general covariance structure defined ... argument.","code":""},{"path":"https://github.com/covaruber/sommer/reference/gvsr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"general variance structure specification — gvsr","text":"$res list neccesary elements (incidence matrices, known var-cov structures, unknown covariance structures estimated constraints) used mmer solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/gvsr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"general variance structure specification — gvsr","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Covarrubias-Pazaran G (2018) Software update: Moving R package sommer   multivariate mixed models genome-assisted prediction. doi:   https://doi.org/10.1101/354639","code":""},{"path":"https://github.com/covaruber/sommer/reference/gvsr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"general variance structure specification — gvsr","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/gvsr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"general variance structure specification — gvsr","text":"","code":"data(DT_ige) DT <- DT_ige Af <- A_ige An <- A_ige ### Direct genetic effects model # modDGE <- mmer(trait ~ block, #                random = ~ focal, #                rcov = ~ units,  #                data = DT) # summary(modDGE)$varcomp #  ### Indirect genetic effects model without covariance between DGE and IGE # modDGE <- mmer(trait ~ block, #                random = ~focal + neighbour, #                rcov = ~ units,  #                data = DT) # summary(modDGE)$varcomp #  ### Indirect genetic effects model with covariance between DGE and IGE # modIGE <- mmer(trait ~ block, #               random = ~ gvsr(focal, neighbour), #               rcov = ~ units, iters=4,  #               data = DT) # summary(modIGE)$varcomp # ### Indirect genetic effects model with covariance between DGE and IGE using relatioship matrices # modIGEb <- mmer(trait ~ block, #                random = ~ gvsr(focal, neighbour, Gu=list(Af,An)), #                rcov = ~ units,  #                data = DT) # summary(modIGEb)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/impute.html","id":null,"dir":"Reference","previous_headings":"","what":"Imputing a numeric or character vector — imputev","title":"Imputing a numeric or character vector — imputev","text":"function simple function impute numeric character vector mean median value vector.","code":""},{"path":"https://github.com/covaruber/sommer/reference/impute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imputing a numeric or character vector — imputev","text":"","code":"imputev(x, method=\"median\")"},{"path":"https://github.com/covaruber/sommer/reference/impute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imputing a numeric or character vector — imputev","text":"x numeric character vector. method method choose mean median.","code":""},{"path":"https://github.com/covaruber/sommer/reference/impute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Imputing a numeric or character vector — imputev","text":"$x numeric character vector imputed method selected.","code":""},{"path":"https://github.com/covaruber/sommer/reference/impute.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Imputing a numeric or character vector — imputev","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/impute.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Imputing a numeric or character vector — imputev","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/impute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Imputing a numeric or character vector — imputev","text":"","code":"####=========================================#### #### generate your mickey mouse -log10(p-values) ####=========================================#### set.seed(1253) x <- rnorm(100) x[sample(1:100,10)] <- NA imputev(x) #>   [1]  1.577855068  0.240143762 -1.331277824  1.025186918 -0.928600204 #>   [6]  0.694531876 -0.744847948  1.655195579  0.044981432  0.784703034 #>  [11] -1.020295637  1.174174050  0.044981432  0.457794841  1.257489611 #>  [16] -0.412769854  0.635808774  0.545925718  0.163391748  0.297052560 #>  [21]  0.564450938 -0.316481020 -0.555029207  1.004811343  0.044981432 #>  [26] -1.924113615 -0.927344504  0.995348447  1.048837095 -0.155236834 #>  [31]  0.950410434  1.160607126  0.044981432  0.195792188  1.112691701 #>  [36]  1.204521218 -2.910366676  0.748453777 -0.694321858  0.044981432 #>  [41]  1.685779213 -0.074461704  0.152088508  0.540014238 -0.677144037 #>  [46]  0.209193559 -0.055097378  2.218282071 -1.991467171 -2.367082599 #>  [51] -0.520100402 -0.188628144 -1.212232668 -0.051738747  1.359198689 #>  [56]  0.044981432  1.028300535  0.038970031 -0.053774901 -0.287839774 #>  [61]  0.044981432 -0.320252863  0.715899389 -1.804831676  2.133901448 #>  [66] -0.219905932  0.054745279 -0.369139043 -0.437421760 -0.493611343 #>  [71] -0.641825613 -1.033010954 -0.561891136  1.472184031  0.356134347 #>  [76]  0.050992833 -0.575716084 -0.836216728  1.455376860  0.714424589 #>  [81]  0.705273802  0.044981432 -1.787915833 -0.278508709  0.103233527 #>  [86] -1.255143163  1.832895750 -0.367893289 -1.560032985 -0.752854983 #>  [91]  0.003281394  0.044981432 -1.147504621  0.186033348  0.044981432 #>  [96]  0.526298279  0.428082812  0.175179502 -0.211427533 -0.129934458"},{"path":"https://github.com/covaruber/sommer/reference/isc.html","id":null,"dir":"Reference","previous_headings":"","what":"identity covariance structure — isc","title":"identity covariance structure — isc","text":"isc creates identity covariance structure levels random effect  used mmec solver. random effect special covariance structure end isc() structure.","code":""},{"path":"https://github.com/covaruber/sommer/reference/isc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"identity covariance structure — isc","text":"","code":"isc(x, thetaC=NULL, theta=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/isc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"identity covariance structure — isc","text":"x vector observations random effect. thetaC optional 1 x 1 matrix constraints variance-covariance components. values matrix define variance-covariance components estimated: 0: component estimated 1: component estimated constrained positive (default) 2: component estimated unconstrained 3: component fixed value provided theta argument  theta optional 1 x 1 matrix initial values variance-covariance component. providing customized values, values scaled respect original variance. example, provide initial value 1 given variance component, theta built : theta = matrix( 1 / var(response) ) values matrix define initial values variance-covariance components subject constraints provided thetaC. provided, initial values (theta) 0.15","code":""},{"path":"https://github.com/covaruber/sommer/reference/isc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"identity covariance structure — isc","text":"$res list provided vector variance covariance structure expected levels random effect.","code":""},{"path":"https://github.com/covaruber/sommer/reference/isc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"identity covariance structure — isc","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/isc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"identity covariance structure — isc","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/isc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"identity covariance structure — isc","text":"","code":"x <- as.factor(c(1:5,1:5,1:5));x #>  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 #> Levels: 1 2 3 4 5 isc(x) #> $Z #> 15 x 5 sparse Matrix of class \"dgCMatrix\" #>    1 2 3 4 5 #> 1  1 . . . . #> 2  . 1 . . . #> 3  . . 1 . . #> 4  . . . 1 . #> 5  . . . . 1 #> 6  1 . . . . #> 7  . 1 . . . #> 8  . . 1 . . #> 9  . . . 1 . #> 10 . . . . 1 #> 11 1 . . . . #> 12 . 1 . . . #> 13 . . 1 . . #> 14 . . . 1 . #> 15 . . . . 1 #>  #> $thetaC #>     isc #> isc   1 #>  #> $theta #>      isc #> isc 0.15 #>   # data(DT_example) # ans1 <- mmec(Yield~Env, #              random= ~ vsc( isc( Name ) ), #              data=DT_example) # summary(ans1)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/jet.colors.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a sequence of colors alog the jet colormap. — jet.colors","title":"Generate a sequence of colors alog the jet colormap. — jet.colors","text":"jet.colors(n) generates sequence \\(n\\)   colors dark blue cyan yellow dark red.   similar default color schemes Python's   matplotlib MATLAB.","code":""},{"path":"https://github.com/covaruber/sommer/reference/jet.colors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a sequence of colors alog the jet colormap. — jet.colors","text":"","code":"jet.colors(n, alpha = 1)"},{"path":"https://github.com/covaruber/sommer/reference/jet.colors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a sequence of colors alog the jet colormap. — jet.colors","text":"n number colors return. alpha transparency value colors. See   ?rgb details.","code":""},{"path":"https://github.com/covaruber/sommer/reference/jet.colors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a sequence of colors alog the jet colormap. — jet.colors","text":"vector colors along jet colorramp.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/jet.colors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a sequence of colors alog the jet colormap. — jet.colors","text":"","code":"{ # Plot a colorbar with jet.colors image(matrix(seq(100), 100), col=jet.colors(100)) }"},{"path":"https://github.com/covaruber/sommer/reference/leg.html","id":null,"dir":"Reference","previous_headings":"","what":"Legendre polynomial matrix — leg","title":"Legendre polynomial matrix — leg","text":"Legendre polynomials order 'n' created given vector 'x' normalized lay values u v.","code":""},{"path":"https://github.com/covaruber/sommer/reference/leg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Legendre polynomial matrix — leg","text":"","code":"leg(x,n=1,u=-1,v=1, intercept=TRUE, intercept1=FALSE)"},{"path":"https://github.com/covaruber/sommer/reference/leg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Legendre polynomial matrix — leg","text":"x numeric vector used polynomial. n order Legendre polynomials. u lower bound polynomial. v upper bound polynomial. intercept TRUE/FALSE value indicating intercept included. intercept1 TRUE/FALSE value indicating intercept value 1 (multiplied sqrt(2)).","code":""},{"path":"https://github.com/covaruber/sommer/reference/leg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Legendre polynomial matrix — leg","text":"$S3 Legendre polynomial matrix order n.","code":""},{"path":"https://github.com/covaruber/sommer/reference/leg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Legendre polynomial matrix — leg","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/leg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Legendre polynomial matrix — leg","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/leg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Legendre polynomial matrix — leg","text":"","code":"x <- sort(rep(1:3,100)) # you need to install the orthopolynom library # leg(x, n=1) # leg(x, n=2)  # see dataset data(DT_legendre) for a random regression modeling example"},{"path":"https://github.com/covaruber/sommer/reference/list2usmat.html","id":null,"dir":"Reference","previous_headings":"","what":"list or vector to unstructured matrix — list2usmat","title":"list or vector to unstructured matrix — list2usmat","text":"list2usmat creates unstructured square matrix taking vector list fill diagonal upper triangular values provided.","code":""},{"path":"https://github.com/covaruber/sommer/reference/list2usmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"list or vector to unstructured matrix — list2usmat","text":"","code":"list2usmat(sigmaL)"},{"path":"https://github.com/covaruber/sommer/reference/list2usmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"list or vector to unstructured matrix — list2usmat","text":"sigmaL vector list values put matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/list2usmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"list or vector to unstructured matrix — list2usmat","text":"$res matrix values provided.","code":""},{"path":"https://github.com/covaruber/sommer/reference/list2usmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"list or vector to unstructured matrix — list2usmat","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/list2usmat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"list or vector to unstructured matrix — list2usmat","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/list2usmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"list or vector to unstructured matrix — list2usmat","text":"","code":"list2usmat(as.list(1:3)) #>      [,1] [,2] #> [1,]    1    2 #> [2,]    2    3 list2usmat(as.list(1:10)) #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    4    7 #> [2,]    2    3    5    8 #> [3,]    4    7    6    9 #> [4,]    5    8    9   10"},{"path":"https://github.com/covaruber/sommer/reference/logspace.html","id":null,"dir":"Reference","previous_headings":"","what":"Decreasing logarithmic trend — logspace","title":"Decreasing logarithmic trend — logspace","text":"logspace creates vector decreasing logaritmic trend.","code":""},{"path":"https://github.com/covaruber/sommer/reference/logspace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decreasing logarithmic trend — logspace","text":"","code":"logspace(n, start, end)"},{"path":"https://github.com/covaruber/sommer/reference/logspace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decreasing logarithmic trend — logspace","text":"n number values generate. start initial value. end last value.","code":""},{"path":"https://github.com/covaruber/sommer/reference/logspace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Decreasing logarithmic trend — logspace","text":"$res vector length n logarithmic decrease trend.","code":""},{"path":"https://github.com/covaruber/sommer/reference/logspace.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Decreasing logarithmic trend — logspace","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/logspace.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Decreasing logarithmic trend — logspace","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/logspace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Decreasing logarithmic trend — logspace","text":"","code":"logspace(5, 1, .05) #> [1] 1.0000000 0.4728708 0.2236068 0.1057371 0.0500000"},{"path":"https://github.com/covaruber/sommer/reference/manhattan.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating a manhattan plot — manhattan","title":"Creating a manhattan plot — manhattan","text":"function designed create manhattan plot using data frame columns \"Chrom\" (Chromosome),  \"Position\" \"p.val\" (significance test).","code":""},{"path":"https://github.com/covaruber/sommer/reference/manhattan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating a manhattan plot — manhattan","text":"","code":"manhattan(map, col=NULL, fdr.level=0.05, show.fdr=TRUE, PVCN=NULL, ylim=NULL, ...)"},{"path":"https://github.com/covaruber/sommer/reference/manhattan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating a manhattan plot — manhattan","text":"map data frame 3 columns names; \"Chrom\" (Chromosome),  \"Position\" \"p.val\" (significance test). col colors prefered user used manhattan plot. default NULL use red-blue palette. fdr.level false discovery rate drawn plot. show.fdr TRUE/FALSE value indicating FDR value shown manhattan plot . default TRUE meaning displayed. PVCN case user wants provide name column treated \"p.val\" column expected program 'map' argument. ylim y axis limits manhattan plot user wants customize . default plot reflect minimum maximum values found. ... additional arguments passed plot function pch, cex, etc.","code":""},{"path":"https://github.com/covaruber/sommer/reference/manhattan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating a manhattan plot — manhattan","text":"parameters correctly indicated program return: $plot.data manhattan plot","code":""},{"path":"https://github.com/covaruber/sommer/reference/manhattan.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Creating a manhattan plot — manhattan","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/manhattan.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Creating a manhattan plot — manhattan","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/manhattan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating a manhattan plot — manhattan","text":"","code":"#random population of 200 lines with 1000 markers M <- matrix(rep(0,200*1000),1000,200) for (i in 1:200) {   M[,i] <- ifelse(runif(1000)<0.5,-1,1) } colnames(M) <- 1:200 set.seed(1234) pp <- abs(rnorm(500,0,3));pp[23:34] <- abs(rnorm(12,0,20)) geno <- data.frame(Locus=paste(\"m\",1:500, sep=\".\"),Chrom=sort(rep(c(1:5),100)),                    Position=rep(seq(1,100,1),5),                    p.val=pp, check.names=FALSE) geno$Locus <- as.character(geno$Locus) ## look at the data, 5LGs, 100 markers in each ## -log(p.val) value for simulated trait head(geno) #>   Locus Chrom Position     p.val #> 1   m.1     1        1 3.6211972 #> 2   m.2     1        2 0.8322877 #> 3   m.3     1        3 3.2533235 #> 4   m.4     1        4 7.0370931 #> 5   m.5     1        5 1.2873741 #> 6   m.6     1        6 1.5181677 tail(geno) #>     Locus Chrom Position     p.val #> 495 m.495     5       95 3.3390483 #> 496 m.496     5       96 0.1294212 #> 497 m.497     5       97 6.6767607 #> 498 m.498     5       98 1.5189498 #> 499 m.499     5       99 2.1911882 #> 500 m.500     5      100 5.1842328 manhattan(geno)"},{"path":"https://github.com/covaruber/sommer/reference/map.plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating a genetic map plot — map.plot","title":"Creating a genetic map plot — map.plot","text":"function designed create genetic map plot using data frame indicating Linkage Group (LG), Position marker names (Locus).","code":""},{"path":"https://github.com/covaruber/sommer/reference/map.plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating a genetic map plot — map.plot","text":"","code":"map.plot(data, trait = NULL, trait.scale = \"same\",          col.chr = NULL, col.trait = NULL, type = \"hist\", cex = 0.4,         lwd = 1, cex.axis = 0.4, cex.trait=0.8, jump = 5)"},{"path":"https://github.com/covaruber/sommer/reference/map.plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating a genetic map plot — map.plot","text":"data data frame 3 columns names; Locus, LG Position trait something wants plotted next linkage groups user must indicate name column containing values ploted, .e. p-values, LOD scores, X2 segregation distortion values, etc. trait.scale trait NULL, character value indicating y axis limits trait plotted next chromosomes different linkage group. default value \"\", means y axis limit conserved across linkage groups. giving individual y axis limit linkage group write \"diff\". col.chr vector color names chromosomes. NULL drawn gray-black scale. col.trait vector color names dots, lines histogram trait plotted next LG's type character value indicating trait plotted scatterplot `dot`, histogram `hist`, line `line` next chromosomes. cex cex value determining size cM position labels LGs lwd width lines plot cex.axis cex value sizing labels LGs traits plotted (top labels) cex.trait cex value sizing dots lines trait plotted jump scalar value indicating often drawn number next LG indicating position. default 5 means every 5 cM label drawn, .e. 0,5,10,15,... cM.","code":""},{"path":"https://github.com/covaruber/sommer/reference/map.plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating a genetic map plot — map.plot","text":"parameters correctly indicated program return: $plot.data plot LGs information used create plot","code":""},{"path":"https://github.com/covaruber/sommer/reference/map.plot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Creating a genetic map plot — map.plot","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/map.plot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Creating a genetic map plot — map.plot","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/map.plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating a genetic map plot — map.plot","text":"","code":"#random population of 200 lines with 1000 markers M <- matrix(rep(0,200*1000),1000,200) for (i in 1:200) {   M[,i] <- ifelse(runif(1000)<0.5,-1,1) } colnames(M) <- 1:200 set.seed(1234) geno <- data.frame(Locus=paste(\"m\",1:500, sep=\".\"),LG=sort(rep(c(1:5),100)),                    Position=rep(seq(1,100,1),5),                    X2=rnorm(500,10,4), check.names=FALSE) geno$Locus <- as.character(geno$Locus) ## look at the data, 5LGs, 100 markers in each ## X2 value for segregation distortion simulated head(geno) #>   Locus LG Position         X2 #> 1   m.1  1        1  5.1717370 #> 2   m.2  1        2 11.1097170 #> 3   m.3  1        3 14.3377647 #> 4   m.4  1        4  0.6172092 #> 5   m.5  1        5 11.7164988 #> 6   m.6  1        6 12.0242236 tail(geno) #>     Locus LG Position        X2 #> 495 m.495  5       95  5.547936 #> 496 m.496  5       96  9.827438 #> 497 m.497  5       97 18.902348 #> 498 m.498  5       98 12.025266 #> 499 m.499  5       99 12.921584 #> 500 m.500  5      100 16.912310 table(geno$LG) # 5 LGs, 100 marks #>  #>   1   2   3   4   5  #> 100 100 100 100 100  map.plot(geno, trait=\"X2\", type=\"line\")  map.plot(geno, trait=\"X2\", type=\"hist\")  map.plot(geno, trait=\"X2\", type=\"dot\")   # data(\"DT_cpdata\") # MP <- MP_cpdata # colnames(MP)[3] <- c(\"LG\") # head(MP) # map.plot(MP, type=\"line\", cex=0.6)"},{"path":"https://github.com/covaruber/sommer/reference/mmec.html","id":null,"dir":"Reference","previous_headings":"","what":"mixed model equations for c coefficients — mmec","title":"mixed model equations for c coefficients — mmec","text":"mmec function uses Henderson mixed model equations Average Information algorithm coded C++ using Armadillo library optimize matrix operations common problems sparse data (e.g., genotype environment models). algorithm intended used problems type r > c (records data coefficients estimate). problems type c > r (coefficients estimate records available), direct inversion algorithms faster recommend shift use mmer function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mixed model equations for c coefficients — mmec","text":"","code":"mmec(fixed, random, rcov, data, W, nIters=25, tolParConvLL = 1e-03,      tolParConvNorm = 1e-04, tolParInv = 1e-06, naMethodX=\"exclude\",      naMethodY=\"exclude\", returnParam=FALSE, dateWarning=TRUE,      verbose=TRUE,addScaleParam=NULL, stepWeight=NULL, emWeight=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/mmec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mixed model equations for c coefficients — mmec","text":"fixed formula specifying response variable(s) fixed effects, .e: response ~ covariate  random formula specifying name random effects, e.g., random= ~ genotype + year. Useful functions can used fit heterogeneous variances special models (see 'Special Functions' Details section information): vsc(...,Gu) main function specify variance models special structures random effects. ... argument provide unknown variance-covariance structures (e.g., usc,dsc,,csc) random effect covariance structure used (random effect interest). Gu used provide known covariance matrices among levels random effect. Auxiliar functions building variance models : ** dsc(x), usc(x), rrc(x,y,z) , isc(x),csc(x), atc(x,levs) can used specify unknown diagonal, unstructured, reduced-rank, identity, customized unstructured diagonal covariance structures respectively estimated REML. ** unsm(x), fixm(x) diag(x) can used build easily matrices specify constraints Gtc argument vsc() function. ** overlay(), spl2Dc(), leg(), redmm() functions can used specify overlayed design matrices random effects, two dimensional spline, random regression, dimensionality-reduction models within vsc() function.  rcov formula specifying name error term, e.g., rcov= ~ units. Special heterogeneous special variance models constraints residual part used random term name random effect always \"units\" can thought column many levels rows data, e.g., rcov=~vsc(dsc(covariate),isc(units)) fitting structures level residuals please make sure data sorted based factors defining structure. example, rcov= ~ vsc(dsc(xx), isc(units)) sort datatset variable xx.  data data frame containing variables specified formulas response, fixed, random effects. W Weights matrix (e.g., covariance among plots exist). Internally W squared inverted Wsi = solve(chol(W)), residual matrix calculated R = Wsi*O*Wsi.t(), * matrix product, O original residual matrix. nIters Maximum number iterations allowed. tolParConvLL Convergence criteria based change log-likelihood iteration -1. tolParConvNorm Convergence criteria based norm proposed Jensen, Madsen Thompson (1997): e1 = || InfMatInv.diag()/sqrt(N) * dLu || InfMatInv.diag() diagonal inverse information matrix, N total number variance components, dLu vector first derivatives.  tolParInv Tolerance parameter matrix inverse used singularities encountered estimation procedure. naMethodX One two possible values; \"include\" \"exclude\". \"include\" selected function impute X matrices fixed effects median value. \"exclude\" selected get rid rows missing values X (fixed) covariates. default \"exclude\". \"include\" option used carefully. naMethodY One three possible values; \"include\", \"include2\" \"exclude\" (default) treat observations response variable used estimation variance components. first option \"include\" impute response variables rows median value, whereas \"include2\" imputes responses rows observation(s) least one responses (available multi-response models). \"exclude\" selected (default) get rid rows response(s) missing values present least one responses. returnParam TRUE/FALSE value indicate program return parameters used fitting model instead fitting model. dateWarning TRUE/FALSE value indicate program warn time update sommer package. verbose TRUE/FALSE value indicate program return progress iterative algorithm. addScaleParam additional scale parameters thetaF matrix. stepWeight vector values (length equal number iterations) indicating weight used multiply update (delta) variance components iteration. NULL 1st iteration multiplied 0.5, 2nd 0.7, rest 0.9. argument can help avoid variance components go outside parameter space initial iterations happens often AI method can detected looking behavior likelihood. case may want give smaller weight. emWeight vector values (length equal number iterations) indicating values 0 1 weight assigned EM information matrix. values 1 - emWeight applied AI information matrix produce joint information matrix. default function gives weight EM algorithm logarithmic decrease rate using following code logspace(nIters,1,0.05).","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"mixed model equations for c coefficients — mmec","text":"use function requires good understanding mixed models. Please review 'sommer.quick.start' vignette pay attention details like format random fixed variables (e.g. character factor variables different properties returning BLUEs BLUPs, please see 'sommer.changes..faqs' vignette). tutorials perform different analysis sommer please look vignettes typing terminal: vignette(\"v1.sommer.quick.start\") vignette(\"v2.sommer.changes..faqs\") vignette(\"v3.sommer.qg\") vignette(\"v4.sommer.gxe\") Citation Type citation(\"sommer\") know cite sommer package publications. Special variance structures vsc(atc(x,levels),isc(y)) can used specify heterogeneous variance \"y\" covariate specific levels covariate \"x\", e.g., random=~vsc((Location,c(\"\",\"B\")),isc(ID)) fits variance component ID levels B covariate Location. vsc(dsc(x),isc(y)) can used specify diagonal covariance structure \"y\" covariate levels covariate \"x\", e.g., random=~vsc(dsc(Location),isc(ID))  fits variance component ID levels covariate Location. vsc(usc(x),isc(y)) can used specify unstructured covariance structure \"y\" covariate levels  covariate \"x\", e.g., random=~vsc(usc(Location),isc(ID))  fits variance covariance components ID levels covariate Location. vsc(usc(rrc(x,y,z,nPC)),isc(y)) can used specify unstructured covariance structure \"y\" effect levels  covariate \"x\", response variable \"z\", e.g., random=~vsc(rrc(Location,ID,response, nPC=2),isc(ID))  fits reduced-rank factor analytic covariance ID 2 principal components covariate Location. vsc(isc(overlay(...,rlist=NULL,prefix=NULL))) can used specify overlay design matrices consecutive random effects specified, e.g., random=~vsc(isc(overlay(male,female))) overlays (overlaps) incidence matrices male female random effects obtain single variance component effects. `rlist` argument list element numeric value multiplies incidence matrix overlayed. See overlay details.Can combined vsc(). vsc(isc(redmm(x,M,nPC))) can used create reduced model matrix effect (x) assumed linear function feature matrix (M), e.g., random=~vsc(isc(redmm(x,M))) creates incidence matrix large set features (M) belong levels x create reduced model matrix. See redmm details.Can combined vsc(). vsc(leg(x,n),isc(y)) can used fit random regression model using numerical variable x marks trayectory random effect y. leg function can combined special functions dsc, usc csc. example random=~vsc(leg(x,1),isc(y)) random=~vsc(usc(leg(x,1)),isc(y)). spl2Dc(x.coord, y.coord, .var, .levels)) can used fit 2-dimensional spline (e.g., spatial modeling) using coordinates x.coord y.coord (numeric class) assuming multiple variance components. 2D spline can fitted specific levels using .var .levels arguments. example random=~spl2Dc(x.coord=Row,y.coord=Range,.var=FIELD). Covariance random effects covc( vsc(isc(ran1)), vsc(isc(ran2)) ) can used specify covariance two different random effects, e.g., random=~covc( vsc(isc(x1)), vsc(isc(x2)) ) two random effects vsc() structure encapsulated. applies simple random effects. S3 methods S3 methods available parameter extraction fitted.mmec, residuals.mmec, summary.mmec, randef, coef.mmec, anova.mmec, plot.mmec, predict.mmec obtain adjusted means. addition, vpredict function (replacement pin function) can used estimate standard errors linear combinations variance components (e.g., ratios like h2). r2 function calculates reliability. Additional Functions Additional functions genetic analysis included relationship matrix building (.mat, D.mat, E.mat, H.mat),  build genotypic hybrid marker matrix (build.HMM), plot genetic maps (map.plot), manhattan plots (manhattan). need build pedigree-based relationship matrix use getA function pedigreemm package. Bug report contact technical questions suggestions please post https://stackoverflow.com https://stats.stackexchange.com bug report please go https://github.com/covaruber/sommer send email address asap, just make sure read vignettes carefully sending question. Example Datasets package equiped several datasets learn use sommer package: * DT_halfdiallel, DT_fulldiallel DT_mohring datasets examples fit half full diallel designs. * DT_h2 calculate heritability * DT_cornhybrids DT_technow datasets perform genomic prediction hybrid single crosses * DT_wheat dataset genomic prediction single crosses species displaying additive effects. * DT_cpdata dataset fit genomic prediction models within biparental population coming 2 highly heterozygous parents including additive, dominance epistatic effects. * DT_polyploid fit genomic prediction GWAS analysis polyploids. * DT_gryphon data contains example animal model including pedigree information. * DT_btdata dataset contains animal (birds) model. * DT_legendre simulated dataset random regression model. * DT_sleepstudy dataset know translate lme4 models sommer models. * DT_ige dataset show fit indirect genetic effect models. Models Enabled details models enabled information covariance structures please check help page package (sommer).","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mixed model equations for c coefficients — mmec","text":"parameters correctly indicated program return list following information: llik vector log-likelihoods across iterations M coeficient matrix extended response vector y] W column binded matrix W = [X Z y] b vector fixed effect. u vector random effect. bu vector fixed random effects together. Ci inverse coefficient matrix. avInf matrix second derivatives likelihood respect .j th variance-covariance component. monitor values variance-covariance components across iterations REML estimation. constraints vector constraints. AIC Akaike information criterion BIC Bayesian information criterion convergence TRUE/FALSE statement indicating model converged. partitions list element contains matrix indicating random effect starts ends. percDelta matrix percentage change deltas (see tolParConvNorm argument). normMonitor matrix three norms calculated (see tolParConvNorm argument). toBoundary matrix variance components forced boundary across iterations. Cchol Cholesky decomposition coefficient matrix. theta list estimated variance covariance matrices. element list corresponds different random residual components sigma vector form variance-covariance parameters. data dataset used model fitting. y response vector. partitionsX list element contains matrix indicating fixed effect starts ends. uList list containing BLUPs data frame format rows levels random effects column different factors random effect fitted. specially useful diagonal unstructured models. uPevList list containing BLUPs data frame format rows levels random effects column different factors random effect fitted. specially useful diagonal unstructured models. Dtable table used predict function help program recognize factors available. args fixed, random residual formulas mmec model.","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"mixed model equations for c coefficients — mmec","text":"Jensen, J., Mantysaari, E. ., Madsen, P., Thompson, R. (1997). Residual maximum likelihood estimation (co) variance components multivariate mixed linear models using average information. Journal Indian Society Agricultural Statistics, 49, 215-236. Covarrubias-Pazaran G. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 2016, 11(6): doi:10.1371/journal.pone.0156744 Gilmour et al. 1995. Average Information REML: efficient algorithm variance parameter estimation linear mixed models. Biometrics 51(4):1440-1450.","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mixed model equations for c coefficients — mmec","text":"Coded Christelle Fernandez Camacho & Giovanny Covarrubias-Pazaran","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"mixed model equations for c coefficients — mmec","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the #### examples are silenced with one '#' mark, #### remove them and run the examples ####=========================================####  ####=========================================#### #### EXAMPLES #### Different models with sommer ####=========================================####  data(DT_example) DT <- DT_example head(DT) #>                   Name     Env Loc Year     Block Yield    Weight #> 33  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.1     4 -1.904711 #> 65          CO02024-9W CA.2013  CA 2013 CA.2013.1     5 -1.446958 #> 66  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.2     5 -1.516271 #> 67            MSL007-B CA.2011  CA 2011 CA.2011.2     5 -1.435510 #> 68           MSR169-8Y CA.2013  CA 2013 CA.2013.1     5 -1.469051 #> 103         AC05153-1W CA.2013  CA 2013 CA.2013.1     6 -1.307167  ####=========================================#### #### Univariate homogeneous variance models  #### ####=========================================####  ## Compound simmetry (CS) model ans1 <- mmec(Yield~Env,              random= ~ Name + Env:Name,              rcov= ~ units,              data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -327.295   1:16:16      0           0 #>     2      -311.454   1:16:16      0           0 #>     3      -304.865   1:16:16      0           0 #>     4      -302.661   1:16:16      0           0 #>     5      -301.766   1:16:17      1           0 #>     6      -301.251   1:16:17      1           0 #>     7      -300.978   1:16:17      1           0 #>     8      -300.877   1:16:17      1           0 #>     9      -300.855   1:16:17      1           0 #>     10      -300.852   1:16:17      1           0 #>     11      -300.852   1:16:17      1           0 summary(ans1) #> ============================================================ #>          Multivariate Linear Mixed Model fit by REML          #> **********************  sommer 4.3  **********************  #> ============================================================ #>          logLik      AIC      BIC Method Converge #> Value -300.8517 607.7034 617.3645     AI     TRUE #> ============================================================ #> Variance-Covariance components: #>                  VarComp VarCompSE Zratio Constraint #> Name:isc:isc       3.683     1.881  1.958   Positive #> Env:Name:isc:isc   5.174     2.420  2.138   Positive #> units:isc:isc      4.360     2.270  1.920   Positive #> ============================================================ #> Fixed effects: #>           Estimate Std.Error t.value #> Intercept   16.496    0.6856  24.062 #> CA.2012     -5.777    0.7558  -7.643 #> CA.2013     -6.380    0.7960  -8.015 #> ============================================================ #> Use the '$' sign to access results and parameters  # ####===========================================#### # #### Univariate heterogeneous variance models  #### # ####===========================================#### # DT=DT[with(DT, order(Env)), ] # ## Compound simmetry (CS) + Diagonal (DIAG) model # ans2 <- mmec(Yield~Env, #              random= ~Name + vsc(dsc(Env),isc(Name)), #              rcov= ~ vsc(dsc(Env),isc(units)), #              data=DT) # summary(ans2) #  # ####===========================================#### # ####  Univariate unstructured variance models  #### # ####===========================================#### #  # ans3 <- mmec(Yield~Env, #              random=~ vsc(usc(Env),isc(Name)), #              rcov=~vsc(dsc(Env),isc(units)), #              data=DT) # summary(ans3)"},{"path":"https://github.com/covaruber/sommer/reference/mmer.html","id":null,"dir":"Reference","previous_headings":"","what":"mixed model equations for r records — mmer","title":"mixed model equations for r records — mmer","text":"mmer function uses Direct-Inversion Newton-Raphson Average Information coded C++ using Armadillo library optimize dense matrix operations common genomic selection models. algorithms intended used problems type c > r (coefficients estimate records dataset) /dense matrices. problems sparse data, problems type r > c (records dataset coefficients estimate), MME-based algorithm mmec function faster recommend shift use function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mixed model equations for r records — mmer","text":"","code":"mmer(fixed, random, rcov, data, weights, W, nIters=20, tolParConvLL = 1e-03,       tolParInv = 1e-06, init=NULL, constraints=NULL,method=\"NR\", getPEV=TRUE,      naMethodX=\"exclude\", naMethodY=\"exclude\",returnParam=FALSE,       dateWarning=TRUE,date.warning=TRUE,verbose=TRUE, reshapeOutput=TRUE, stepWeight=NULL,      emWeight=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/mmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mixed model equations for r records — mmer","text":"fixed formula specifying response variable(s) fixed effects, e.g.: response ~ covariate univariate models cbind(response.,response.j) ~ covariate multivariate models fcm() function can used constrain fixed effects multi-response models.  random formula specifying name random effects, e.g. random= ~ genotype + year. Useful functions can used fit heterogeneous variances special models (see 'Special Functions' Details section information): vsr(...,Gu,Gti,Gtc) main function specify variance models special structures random effects. ... argument provide unknown variance-covariance structures (e.g., usr,dsr,atr,csr) random effect covariance structure used (random effect interest). Gu used provide known covariance matrices among levels random effect, Gti initial values Gtc constraints. Auxiliar functions building variance models : ** dsr(x), usr(x), csr(x) atr(x,levs) can used specify unknown diagonal, unstructured customized unstructured diagonal covariance structures estimated REML. ** unsm(x), fixm(x) diag(x) can used build easily matrices specify constraints Gtc argument vsr() function. ** overlay(), spl2Da(), spl2Db(), leg() functions can used specify overlayed design matrices random effects, two dimensional spline random regression models within vsr() function. gvsr(...,Gu,Guc,Gti,Gtc) alternative function specify general variance structures different random effects. special case indirect genetic effect models. similar vsr function ... argument different random effects provided.  rcov formula specifying name error term, e.g., rcov= ~ units. Special heterogeneous special variance models constraints residual part used random term name random effect always \"units\" can thought column many levels rows data, e.g., rcov=~vsr(dsr(covariate),units)  data data frame containing variables specified formulas response, fixed, random effects. weights Name covariate weights. used product R = Wsi*R*Wsi, * matrix product, Wsi square root inverse W R residual matrix. W Alternatively, instead providing vector weights user can specify entire W matrix (e.g., covariances exist). used first produce Wis = solve(chol(W)), calculate R = Wsi*R*Wsi.t(), * matrix product, R residual matrix. one arguments weights W used. indicated W given preference. nIters Maximum number iterations allowed. tolParConvLL Convergence criteria change log-likelihood. tolParInv Tolerance parameter matrix inverse used singularities encountered estimation procedure. init Initial values variance components. default NULL initial values variance components provided algorithm, case user want provide initial values var-cov components argument functional. provided list, list element corresponds one random effect (1x1 matrix) multitrait model pursued element list matrix variance covariance components among traits random effect. Initial values can also provided Gti argument vsr function. highly encouraged use Gti Gtc arguments vsr function instead argument, argument can used provide initial values constraints initial values provided accompanied constraints. See vsr function details constraints. highly encouraged use Gti Gtc arguments vsr function instead argument argument can used provide constraints . method refers method algorithm used estimating variance components. Direct-inversion Newton-Raphson NR Average Information AI (Tunnicliffe 1989; Gilmour et al. 1995; Lee et al. 2015). getPEV TRUE/FALSE value indicating program return predicted error variance variance random effects. option provided since can take long time certain models p > n big extent. naMethodX One two possible values; \"include\" \"exclude\". \"include\" selected function impute X matrices fixed effects median value. \"exclude\" selected get rid rows missing values X (fixed) covariates. default \"exclude\". \"include\" option used carefully. naMethodY One three possible values; \"include\", \"include2\" \"exclude\" (default) treat observations response variable used estimation variance components. first option \"include\" impute response variables rows median value, whereas \"include2\" imputes responses rows observation(s) least one responses (available multi-response models). \"exclude\" selected (default) get rid rows response(s) missing values present least one responses. returnParam TRUE/FALSE value indicate program return parameters used fitting model instead fitting model. dateWarning TRUE/FALSE value indicate program warn time update sommer package. date.warning TRUE/FALSE value indicate program warn time update sommer package. argument removed soon, just left backcompatibility. verbose TRUE/FALSE value indicate program return progress iterative algorithm. reshapeOutput TRUE/FALSE value indicate output reshaped easier interpret user, information missing multivariate models easy interpretation. stepWeight vector values (length equal number iterations) indicating weight used multiply update (delta) variance components iteration. NULL 1st iteration multiplied 0.5, 2nd 0.7, rest 0.9. argument can help avoid variance components go outside parameter space initial iterations happen often NR method can detected looking behavior likelihood. case may want give smaller weight initial 8-10 iterations. emWeight vector values (length equal number iterations) indicating values 0 1 weight assigned EM information matrix. values 1 - emWeight applied NR/AI information matrix produce joint information matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"mixed model equations for r records — mmer","text":"use function requires good understanding mixed models. Please review 'sommer.quick.start' vignette pay attention details like format random fixed variables (e.g. character factor variables different properties returning BLUEs BLUPs, please see 'sommer.changes..faqs' vignette). tutorials perform different analysis sommer please look vignettes typing terminal: vignette(\"v1.sommer.quick.start\") vignette(\"v2.sommer.changes..faqs\") vignette(\"v3.sommer.qg\") vignette(\"v4.sommer.gxe\") Citation Type citation(\"sommer\") know cite sommer package publications. Special variance structures vsr(atr(x,levels),y) can used specify heterogeneous variance \"y\" covariate specific levels covariate \"x\", e.g., random=~vsr((Location,c(\"\",\"B\")),ID) fits variance component ID levels B covariate Location. vsr(dsr(x),y) can used specify diagonal covariance structure \"y\" covariate levels covariate \"x\", e.g., random=~vsr(dsr(Location),ID)  fits variance component ID levels covariate Location. vsr(usr(x),y) can used specify unstructured covariance structure \"y\" covariate levels  covariate \"x\", e.g., random=~vsr(usr(Location),ID)  fits variance covariance components ID levels covariate Location. vsr(overlay(...,rlist=NULL,prefix=NULL)) can used specify overlay design matrices consecutive random effects specified, e.g., random=~vsr(overlay(male,female)) overlays (overlaps) incidence matrices male female random effects obtain single variance component effects. `rlist` argument list element numeric value multiplies incidence matrix overlayed. See overlay details.Can combined vsr(). vsr(leg(x,n),y) can used fit random regression model using numerical variable x marks trayectory random effect y. leg function can combined special functions dsr, usr csr. example random=~vsr(leg(x,1),y) random=~vsr(usr(leg(x,1)),y). vsr(x,Gtc=fcm(v)) can used constrain fixed effects multi-response mixed models. vector specifies fixed effect estimated trait. example fixed=cbind(response., response.j)~vsr(Rowf, Gtc=fcm(c(1,0))) means fixed effect Rowf estimated first response second intercept. gvsr(x,y) can used fit variance covariance parameters two random effects. example, indirect genetic effect models. spl2Da(x.coord, y.coord, .var, .levels)) can used fit 2-dimensional spline (e.g., spatial modeling) using coordinates x.coord y.coord (numeric class) assuming single variance component. 2D spline can fitted specific levels using .var .levels arguments. example random=~spl2Da(x.coord=Row,y.coord=Range,.var=FIELD). spl2Db(x.coord, y.coord, .var, .levels)) can used fit 2-dimensional spline (e.g., spatial modeling) using coordinates x.coord y.coord (numeric class) assuming multiple variance components. 2D spline can fitted specific levels using .var .levels arguments. example random=~spl2Db(x.coord=Row,y.coord=Range,.var=FIELD). S3 methods S3 methods available parameter extraction fitted.mmer, residuals.mmer, summary.mmer, randef, coef.mmer, anova.mmer, plot.mmer, predict.mmer obtain adjusted means. addition, vpredict function (replacement pin function) can used estimate standard errors linear combinations variance components (e.g., ratios like h2). Additional Functions Additional functions genetic analysis included relationship matrix building (.mat, D.mat, E.mat, H.mat), build genotypic hybrid marker matrix (build.HMM), plot genetic maps (map.plot), manhattan plots (manhattan). need build pedigree-based relationship matrix use getA function pedigreemm package. Bug report contact technical questions suggestions please post https://stackoverflow.com https://stats.stackexchange.com bug report please go https://github.com/covaruber/sommer send email address asap, just make sure read vignettes carefully sending question. Example Datasets package equiped several datasets learn use sommer package: * DT_halfdiallel, DT_fulldiallel DT_mohring datasets examples fit half full diallel designs. * DT_h2 calculate heritability * DT_cornhybrids DT_technow datasets perform genomic prediction hybrid single crosses * DT_wheat dataset genomic prediction single crosses species displaying additive effects. * DT_cpdata dataset fit genomic prediction models within biparental population coming 2 highly heterozygous parents including additive, dominance epistatic effects. * DT_polyploid fit genomic prediction GWAS analysis polyploids. * DT_gryphon data contains example animal model including pedigree information. * DT_btdata dataset contains animal (birds) model. * DT_legendre simulated dataset random regression model. * DT_sleepstudy dataset know translate lme4 models sommer models. * DT_ige dataset show fit indirect genetic effect models. Models Enabled details models enabled information covariance structures please check help page package (sommer).","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"mixed model equations for r records — mmer","text":"parameters correctly indicated program return list following information: Vi inverse phenotypic variance matrix V^- = (ZGZ+R)^-1 P projection matrix  Vi - [Vi*(X*Vi*X)^-*Vi] sigma list values variance-covariance components one list element random effect. sigma_scaled list values scaled variance-covariance components one list element random effect. sigmaSE Hessian matrix containing variance-covariance variance components. SE's can obtained taking square root diagonal values Hessian. Beta data frame trait BLUEs (fixed effects). VarBeta variance-covariance matrix trait BLUEs U list (one element random effect) data frame trait BLUPs. VarU list (one element random effect) variance-covariance matrix trait BLUPs. PevU list (one element random effect) predicted error variance matrix trait BLUPs. fitted Fitted values y.hat=XB residuals Residual values e = Y - XB AIC Akaike information criterion BIC Bayesian information criterion convergence TRUE/FALSE statement indicating model converged. monitor values log-likelihood variance-covariance components across iterations REML estimation. percChange percent change variance components across iterations. one column less number iterations. Calculated percChange = ((x_i/x_i-1) - 1) * 100 ith iteration. dL vector first derivatives likelihood respect ith variance-covariance component. dL2 matrix second derivatives likelihood respect .j th variance-covariance component. method method extimation variance components specified user. call Formula fixed, random rcov used. constraints contraints used mixed models random effects. constraintsF contraints used mixed models fixed effects. data dataset used model removing missing records response variable. dataOriginal original dataset used model. terms name terms responses, fixed, random residual effects model. termsN number effects associated fixed, random residual effects model. sigmaVector vectorized version sigma element (variance-covariance components) match easily standard errors var-cov components stored element sigmaSE. reshapeOutput value provided mmer function argument name.","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmer.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"mixed model equations for r records — mmer","text":"Covarrubias-Pazaran G. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 2016, 11(6): doi:10.1371/journal.pone.0156744 Covarrubias-Pazaran G. 2018. Software update: Moving R package sommer multivariate mixed models genome-assisted prediction. doi: https://doi.org/10.1101/354639 Bernardo Rex. 2010. Breeding quantitative traits plants. Second edition. Stemma Press. 390 pp. Gilmour et al. 1995. Average Information REML: efficient algorithm variance parameter estimation linear mixed models. Biometrics 51(4):1440-1450. Kang et al. 2008. Efficient control population structure model organism association mapping. Genetics 178:1709-1723. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Lee et al. 2015. MTG2: efficient algorithm multivariate linear mixed model analysis based genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201. Maier et al. 2015. Joint analysis psychiatric disorders increases accuracy risk prediction schizophrenia, bipolar disorder, major depressive disorder. J Hum Genet; 96(2):283-294. Rodriguez-Alvarez, Maria Xose, et al. Correcting spatial heterogeneity plant breeding experiments P-splines. Spatial Statistics 23 (2018): 52-71. Searle. 1993. Applying EM algorithm calculating ML REML estimates variance components. Paper invited 1993 American Statistical Association Meeting, San Francisco. Yu et al. 2006. unified mixed-model method association mapping accounts multiple levels relatedness. Genetics 38:203-208. Tunnicliffe W. 1989. use marginal likelihood time series model estimation. JRSS 51(1):15-27. Zhang et al. 2010. Mixed linear model approach adapted genome-wide association studies. Nat. Genet. 42:355-360.","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mixed model equations for r records — mmer","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":"https://github.com/covaruber/sommer/reference/mmer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"mixed model equations for r records — mmer","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================####  ####=========================================#### #### EXAMPLES #### Different models with sommer ####=========================================####  data(DT_example) DT <- DT_example head(DT) #>                   Name     Env Loc Year     Block Yield    Weight #> 33  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.1     4 -1.904711 #> 65          CO02024-9W CA.2013  CA 2013 CA.2013.1     5 -1.446958 #> 66  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.2     5 -1.516271 #> 67            MSL007-B CA.2011  CA 2011 CA.2011.2     5 -1.435510 #> 68           MSR169-8Y CA.2013  CA 2013 CA.2013.1     5 -1.469051 #> 103         AC05153-1W CA.2013  CA 2013 CA.2013.1     6 -1.307167  ####=========================================#### #### Univariate homogeneous variance models  #### ####=========================================####  ## Compound simmetry (CS) model ans1 <- mmer(Yield~Env,              random= ~ Name + Env:Name,              rcov= ~ units,              data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -31.2668   1:16:17      0           0 #>     2      -23.2804   1:16:17      0           0 #>     3      -20.4746   1:16:17      0           0 #>     4      -20.1501   1:16:17      0           0 #>     5      -20.1454   1:16:17      0           0 #>     6      -20.1454   1:16:17      0           0 summary(ans1) #> ============================================================ #>          Multivariate Linear Mixed Model fit by REML          #> **********************  sommer 4.3  **********************  #> ============================================================ #>          logLik      AIC      BIC Method Converge #> Value -20.14538 46.29075 55.95182     NR     TRUE #> ============================================================ #> Variance-Covariance components: #>                      VarComp VarCompSE Zratio Constraint #> Name.Yield-Yield       3.682     1.691  2.177   Positive #> Env:Name.Yield-Yield   5.173     1.495  3.460   Positive #> units.Yield-Yield      4.366     0.647  6.748   Positive #> ============================================================ #> Fixed effects: #>   Trait      Effect Estimate Std.Error t.value #> 1 Yield (Intercept)   16.496    0.6855  24.065 #> 2 Yield  EnvCA.2012   -5.777    0.7558  -7.643 #> 3 Yield  EnvCA.2013   -6.380    0.7960  -8.015 #> ============================================================ #> Groups and observations: #>          Yield #> Name        41 #> Env:Name   123 #> ============================================================ #> Use the '$' sign to access results and parameters  ####===========================================#### #### Univariate heterogeneous variance models  #### ####===========================================####  ## Compound simmetry (CS) + Diagonal (DIAG) model ans2 <- mmer(Yield~Env,              random= ~Name + vsr(dsr(Env),Name),              rcov= ~ vsr(dsr(Env),units),              data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -31.2668   1:16:17      0           0 #>     2      -19.8549   1:16:17      0           0 #>     3      -15.9797   1:16:17      0           0 #>     4      -15.4374   1:16:18      1           0 #>     5      -15.43   1:16:18      1           0 #>     6      -15.4298   1:16:18      1           0 summary(ans2) #> ============================================================ #>          Multivariate Linear Mixed Model fit by REML          #> **********************  sommer 4.3  **********************  #> ============================================================ #>          logLik      AIC      BIC Method Converge #> Value -15.42983 36.85965 46.52072     NR     TRUE #> ============================================================ #> Variance-Covariance components: #>                           VarComp VarCompSE Zratio Constraint #> Name.Yield-Yield            2.963     1.496  1.980   Positive #> CA.2011:Name.Yield-Yield   10.146     4.507  2.251   Positive #> CA.2012:Name.Yield-Yield    1.878     1.870  1.004   Positive #> CA.2013:Name.Yield-Yield    6.629     2.503  2.649   Positive #> CA.2011:units.Yield-Yield   4.942     1.525  3.242   Positive #> CA.2012:units.Yield-Yield   5.725     1.312  4.363   Positive #> CA.2013:units.Yield-Yield   2.560     0.640  4.000   Positive #> ============================================================ #> Fixed effects: #>   Trait      Effect Estimate Std.Error t.value #> 1 Yield (Intercept)   16.508    0.8268  19.965 #> 2 Yield  EnvCA.2012   -5.817    0.8575  -6.783 #> 3 Yield  EnvCA.2013   -6.412    0.9356  -6.854 #> ============================================================ #> Groups and observations: #>              Yield #> Name            41 #> CA.2011:Name    41 #> CA.2012:Name    41 #> CA.2013:Name    41 #> ============================================================ #> Use the '$' sign to access results and parameters  ####===========================================#### ####  Univariate unstructured variance models  #### ####===========================================####  ans3 <- mmer(Yield~Env,              random=~ vsr(usr(Env),Name),              rcov=~vsr(dsr(Env),units),               data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -37.9059   1:16:18      0           0 #>     2      -17.9745   1:16:18      0           0 #>     3      -12.2427   1:16:18      0           0 #>     4      -11.5121   1:16:18      0           0 #>     5      -11.5001   1:16:18      0           0 #>     6      -11.4997   1:16:18      0           0 summary(ans3) #> ================================================================== #>             Multivariate Linear Mixed Model fit by REML             #> *************************  sommer 4.3  *************************  #> ================================================================== #>          logLik      AIC      BIC Method Converge #> Value -11.49971 28.99943 38.66049     NR     TRUE #> ================================================================== #> Variance-Covariance components: #>                                  VarComp VarCompSE Zratio Constraint #> CA.2011:Name.Yield-Yield          15.665    5.4207  2.890   Positive #> CA.2012:CA.2011:Name.Yield-Yield   6.110    2.4851  2.459   Unconstr #> CA.2012:Name.Yield-Yield           4.530    1.8208  2.488   Positive #> CA.2013:CA.2011:Name.Yield-Yield   6.384    3.0659  2.082   Unconstr #> CA.2013:CA.2012:Name.Yield-Yield   0.393    1.5234  0.258   Unconstr #> CA.2013:Name.Yield-Yield           8.597    2.4838  3.461   Positive #> CA.2011:units.Yield-Yield          4.970    1.5323  3.243   Positive #> CA.2012:units.Yield-Yield          5.673    1.3008  4.361   Positive #> CA.2013:units.Yield-Yield          2.557    0.6393  4.000   Positive #> ================================================================== #> Fixed effects: #>   Trait      Effect Estimate Std.Error t.value #> 1 Yield (Intercept)   16.331    0.8137  20.070 #> 2 Yield  EnvCA.2012   -5.696    0.7404  -7.693 #> 3 Yield  EnvCA.2013   -6.271    0.8191  -7.656 #> ================================================================== #> Groups and observations: #>                      Yield #> CA.2011:Name            41 #> CA.2012:CA.2011:Name    82 #> CA.2012:Name            41 #> CA.2013:CA.2011:Name    82 #> CA.2013:CA.2012:Name    82 #> CA.2013:Name            41 #> ================================================================== #> Use the '$' sign to access results and parameters  # ####==========================================#### # #### Multivariate homogeneous variance models #### # ####==========================================#### #  # ## Multivariate Compound simmetry (CS) model # DT$EnvName <- paste(DT$Env,DT$Name) # ans4 <- mmer(cbind(Yield, Weight) ~ Env, #               random= ~ vsr(Name, Gtc = unsm(2)) + vsr(EnvName,Gtc = unsm(2)), #               rcov= ~ vsr(units, Gtc = unsm(2)), #               data=DT) # summary(ans4) #  # ####=============================================#### # #### Multivariate heterogeneous variance models  #### # ####=============================================#### #  # ## Multivariate Compound simmetry (CS) + Diagonal (DIAG) model # ans5 <- mmer(cbind(Yield, Weight) ~ Env, #               random= ~ vsr(Name, Gtc = unsm(2)) + vsr(dsr(Env),Name, Gtc = unsm(2)), #               rcov= ~ vsr(dsr(Env),units, Gtc = unsm(2)), #               data=DT) # summary(ans5) #  # ####===========================================#### # #### Multivariate unstructured variance models #### # ####===========================================#### #  # ans6 <- mmer(cbind(Yield, Weight) ~ Env, #               random= ~ vsr(usr(Env),Name, Gtc = unsm(2)), #               rcov= ~ vsr(dsr(Env),units, Gtc = unsm(2)), #               data=DT) # summary(ans6) #  # ####=========================================#### # ####=========================================#### # #### EXAMPLE SET 2 # #### 2 variance components # #### one random effect with variance covariance structure # ####=========================================#### # ####=========================================#### #  # data(\"DT_cpdata\") # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # head(DT) # GT[1:4,1:4] # #### create the variance-covariance matrix # A <- A.mat(GT) # #### look at the data and fit the model # mix1 <- mmer(Yield~1, #              random=~vsr(id, Gu=A) + Rowf, #              rcov=~units, #              data=DT) # summary(mix1)$varcomp # #### calculate heritability # vpredict(mix1, h1 ~ V1/(V1+V3) ) # #### multi trait example # mix2 <- mmer(cbind(Yield,color)~1, #               random = ~ vsr(id, Gu=A, Gtc = unsm(2)) + # unstructured at trait level #                             vsr(Rowf, Gtc=diag(2)) + # diagonal structure at trait level #                                 vsr(Colf, Gtc=diag(2)), # diagonal structure at trait level #               rcov = ~ vsr(units, Gtc = unsm(2)), # unstructured at trait level #               data=DT) # summary(mix2) #  # ####=========================================#### # #### EXAMPLE SET 3 # #### comparison with lmer, install 'lme4'  # #### and run the code below # ####=========================================#### #  # #### lmer cannot use var-cov matrices so we will not  # #### use them in this comparison example #  # library(lme4) # library(sommer) # data(\"DT_cornhybrids\") # DT <- DT_cornhybrids # DTi <- DTi_cornhybrids # GT <- GT_cornhybrids #  # fm1 <- lmer(Yield ~ Location + (1|GCA1) + (1|GCA2) + (1|SCA), #             data=DT ) # out <- mmer(Yield ~ Location, #              random = ~ GCA1 + GCA2 + SCA, #              rcov = ~ units, #              data=DT) # summary(fm1) # summary(out) # ### same BLUPs for GCA1, GCA2, SCA than lme4 # plot(out$U$GCA1$Yield, ranef(fm1)$GCA1[,1]) # plot(out$U$GCA2$Yield, ranef(fm1)$GCA2[,1]) # vv=which(abs(out$U$SCA$Yield) > 0) # plot(out$U$SCA$Yield[vv], ranef(fm1)$SCA[,1]) #  # ### a more complex model specifying which locations # head(DT) # out2 <- mmer(Yield ~ Location, #               random = ~ vsr(atr(Location,c(\"3\",\"4\")),GCA2) + #                          vsr(atr(Location,c(\"3\",\"4\")),SCA), #               rcov = ~ vsr(dsr(Location),units), #               data=DT) # summary(out2)"},{"path":"https://github.com/covaruber/sommer/reference/neMarker.html","id":null,"dir":"Reference","previous_headings":"","what":"Effective population size based on marker matrix — neMarker","title":"Effective population size based on marker matrix — neMarker","text":"`neMarker` uses marker matrix approximate effective population size (Ne) discovering many individuals needed sample possible alleles population.","code":""},{"path":"https://github.com/covaruber/sommer/reference/neMarker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Effective population size based on marker matrix — neMarker","text":"","code":"neMarker(M, maxNe=100, maxMarker=1000, nSamples=5)"},{"path":"https://github.com/covaruber/sommer/reference/neMarker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Effective population size based on marker matrix — neMarker","text":"M marker matrix coded numerical faashion (allele dosage fine). maxNe maximum number effective population size calculated. maxMarker maximum number markers use analysis. nSamples number individuals sample Ne calculation.","code":""},{"path":"https://github.com/covaruber/sommer/reference/neMarker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Effective population size based on marker matrix — neMarker","text":"$S3 vector allele coverage based different number individuals","code":""},{"path":"https://github.com/covaruber/sommer/reference/neMarker.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Effective population size based on marker matrix — neMarker","text":"based theory published yet solid intuition really important breeding program ask effective population size","code":""},{"path":"https://github.com/covaruber/sommer/reference/neMarker.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Effective population size based on marker matrix — neMarker","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/neMarker.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Effective population size based on marker matrix — neMarker","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================####  # data(DT_cpdata) # Madison cranberries # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # M <- GT # # run the function # ne <- neMarker(M, maxNe = 30, nSamples = 10) # ################ # data(DT_technow) # maize # M <- Md_technow # dent # M <- (M*2) - 1 # M <- M + 1 # # run the function # ne <- neMarker(M, maxNe = 60, nSamples = 10) # ## # M <- Mf_technow # flint # M <- (M*2) - 1 # M <- M + 1 # # run the function # ne <- neMarker(M, maxNe = 60, nSamples = 10) # ################ # data(DT_wheat) # cimmyt wheat # M <- GT_wheat + 1 # # run the function # ne <- neMarker(M, maxNe = 60, nSamples = 10) # ############### # data(DT_rice) # Zhao rice # M <- atcg1234(GT_rice)$M # # run the function # ne <- neMarker(M,  maxNe = 60, nSamples = 10) # ############### # data(DT_polyploid) # endelman potatoes # M <- atcg1234(data=GT_polyploid, ploidy=4)$M # # run the function # ne <- neMarker(M,  maxNe = 60, nSamples = 10) #  # library(ggplot2) #For making plots # ggplot(ne,aes(x=Ne,y=allelesCovered))+ #   geom_ribbon(aes(x=Ne,ymin=allelesCovered-allelesCoveredSe, #                   ymax=allelesCovered+allelesCoveredSe), #                   alpha=0.2,linetype=0)+ #   geom_line(linewidth=1)+ #   guides(alpha=FALSE)+ #   theme_bw()+  #   scale_x_continuous(\"Individual number\")+ #   scale_y_continuous(\"Allele coverage\")  +  #                geom_hline(yintercept = 0.95) +  #                geom_hline(yintercept = 0.975)"},{"path":"https://github.com/covaruber/sommer/reference/overlay.html","id":null,"dir":"Reference","previous_headings":"","what":"Overlay Matrix — overlay","title":"Overlay Matrix — overlay","text":"`overlay` adds r times design matrix model term t existing design matrix. Specifically, model point p effects t effects, columns design matrix t multiplied scalar r (default value 1.0). can used force correlation 1 two terms diallel analysis.","code":""},{"path":"https://github.com/covaruber/sommer/reference/overlay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Overlay Matrix — overlay","text":"","code":"overlay(..., rlist=NULL, prefix=NULL, sparse=FALSE)"},{"path":"https://github.com/covaruber/sommer/reference/overlay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Overlay Matrix — overlay","text":"... many vectors desired overlay. rlist list scalar values indicating times incidence matrix overlayed multiplied . default r=1. prefix character name added column names final overlay matrix. may useful entries names starting numbers programs asreml like, posterior extraction parameters, way 'grep'ing easier. sparse TRUE/FALSE statement specifying matrices built sparse regular matrices.","code":""},{"path":"https://github.com/covaruber/sommer/reference/overlay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Overlay Matrix — overlay","text":"$S3 incidence matrix many columns levels vectors provided build incidence matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/overlay.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Overlay Matrix — overlay","text":"Fikret Isik. 2009. Analysis Diallel Mating Designs. North Carolina State University, Raleigh, USA. Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/overlay.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Overlay Matrix — overlay","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/overlay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Overlay Matrix — overlay","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================#### data(\"DT_halfdiallel\") DT <- DT_halfdiallel head(DT) #>   rep geno male female     sugar #> 1   1   12    1      2 13.950509 #> 2   2   12    1      2  9.756918 #> 3   1   13    1      3 13.906355 #> 4   2   13    1      3  9.119455 #> 5   1   14    1      4  5.174483 #> 6   2   14    1      4  8.452221 DT$femalef <- as.factor(DT$female) DT$malef <- as.factor(DT$male) DT$genof <- as.factor(DT$geno)  with(DT, overlay(femalef,malef, sparse = TRUE)) #> 42 x 7 sparse Matrix of class \"dgCMatrix\" #>    1 2 3 4 5 6 7 #> 1  1 1 . . . . . #> 2  1 1 . . . . . #> 3  1 . 1 . . . . #> 4  1 . 1 . . . . #> 5  1 . . 1 . . . #> 6  1 . . 1 . . . #> 7  1 . . . 1 . . #> 8  1 . . . 1 . . #> 9  1 . . . . 1 . #> 10 1 . . . . 1 . #> 11 1 . . . . . 1 #> 12 1 . . . . . 1 #> 13 . 1 1 . . . . #> 14 . 1 1 . . . . #> 15 . 1 . 1 . . . #> 16 . 1 . 1 . . . #> 17 . 1 . . 1 . . #> 18 . 1 . . 1 . . #> 19 . 1 . . . 1 . #> 20 . 1 . . . 1 . #> 21 . 1 . . . . 1 #> 22 . 1 . . . . 1 #> 23 . . 1 1 . . . #> 24 . . 1 1 . . . #> 25 . . 1 . 1 . . #> 26 . . 1 . 1 . . #> 27 . . 1 . . 1 . #> 28 . . 1 . . 1 . #> 29 . . 1 . . . 1 #> 30 . . 1 . . . 1 #> 31 . . . 1 1 . . #> 32 . . . 1 1 . . #> 33 . . . 1 . 1 . #> 34 . . . 1 . 1 . #> 35 . . . 1 . . 1 #> 36 . . . 1 . . 1 #> 37 . . . . 1 1 . #> 38 . . . . 1 1 . #> 39 . . . . 1 . 1 #> 40 . . . . 1 . 1 #> 41 . . . . . 1 1 #> 42 . . . . . 1 1 with(DT, overlay(femalef,malef, sparse = FALSE)) #>    1 2 3 4 5 6 7 #> 1  1 1 0 0 0 0 0 #> 2  1 1 0 0 0 0 0 #> 3  1 0 1 0 0 0 0 #> 4  1 0 1 0 0 0 0 #> 5  1 0 0 1 0 0 0 #> 6  1 0 0 1 0 0 0 #> 7  1 0 0 0 1 0 0 #> 8  1 0 0 0 1 0 0 #> 9  1 0 0 0 0 1 0 #> 10 1 0 0 0 0 1 0 #> 11 1 0 0 0 0 0 1 #> 12 1 0 0 0 0 0 1 #> 13 0 1 1 0 0 0 0 #> 14 0 1 1 0 0 0 0 #> 15 0 1 0 1 0 0 0 #> 16 0 1 0 1 0 0 0 #> 17 0 1 0 0 1 0 0 #> 18 0 1 0 0 1 0 0 #> 19 0 1 0 0 0 1 0 #> 20 0 1 0 0 0 1 0 #> 21 0 1 0 0 0 0 1 #> 22 0 1 0 0 0 0 1 #> 23 0 0 1 1 0 0 0 #> 24 0 0 1 1 0 0 0 #> 25 0 0 1 0 1 0 0 #> 26 0 0 1 0 1 0 0 #> 27 0 0 1 0 0 1 0 #> 28 0 0 1 0 0 1 0 #> 29 0 0 1 0 0 0 1 #> 30 0 0 1 0 0 0 1 #> 31 0 0 0 1 1 0 0 #> 32 0 0 0 1 1 0 0 #> 33 0 0 0 1 0 1 0 #> 34 0 0 0 1 0 1 0 #> 35 0 0 0 1 0 0 1 #> 36 0 0 0 1 0 0 1 #> 37 0 0 0 0 1 1 0 #> 38 0 0 0 0 1 1 0 #> 39 0 0 0 0 1 0 1 #> 40 0 0 0 0 1 0 1 #> 41 0 0 0 0 0 1 1 #> 42 0 0 0 0 0 1 1 #> attr(,\"variables\") #> [1] \"femalef\" \"malef\""},{"path":"https://github.com/covaruber/sommer/reference/plot.monitor.html","id":null,"dir":"Reference","previous_headings":"","what":"plot the change of VC across iterations — pmonitor","title":"plot the change of VC across iterations — pmonitor","text":"plot monitoring.","code":""},{"path":"https://github.com/covaruber/sommer/reference/plot.monitor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot the change of VC across iterations — pmonitor","text":"","code":"pmonitor(object, ...)"},{"path":"https://github.com/covaruber/sommer/reference/plot.monitor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot the change of VC across iterations — pmonitor","text":"object model object class \"mmec\" ... arguments passed plot function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/plot.monitor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot the change of VC across iterations — pmonitor","text":"vector plot","code":""},{"path":"https://github.com/covaruber/sommer/reference/plot.monitor.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plot the change of VC across iterations — pmonitor","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/plot.monitor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot the change of VC across iterations — pmonitor","text":"","code":"data(DT_yatesoats) DT <- DT_yatesoats head(DT) #>   row col   Y   N          V  B         MP #> 1   1   1  91 0.2    Victory B2    Victory #> 2   2   1  61   0    Victory B2    Victory #> 3   3   1 121 0.4 Marvellous B2 Marvellous #> 4   4   1 144 0.6 Marvellous B2 Marvellous #> 5   5   1 149 0.6 GoldenRain B2 GoldenRain #> 6   6   1 108 0.2 GoldenRain B2 GoldenRain m3 <- mmec(fixed=Y ~ V + N + V:N,            random = ~ B + B:MP,            rcov=~units,            data = DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -220.267   1:16:19      0           0 #>     2      -213.15   1:16:19      0           0 #>     3      -209.956   1:16:19      0           0 #>     4      -209.412   1:16:19      0           0 #>     5      -209.384   1:16:19      0           0 #>     6      -209.379   1:16:19      0           0 #>     7      -209.378   1:16:19      0           0 #>     8      -209.378   1:16:19      0           0 pmonitor(m3)"},{"path":"https://github.com/covaruber/sommer/reference/plot_mmec.html","id":null,"dir":"Reference","previous_headings":"","what":"plot form a LMM plot with mmec — plot.mmec","title":"plot form a LMM plot with mmec — plot.mmec","text":"plot method class \"mmec\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/plot_mmec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot form a LMM plot with mmec — plot.mmec","text":"","code":"# S3 method for class 'mmec' plot(x,stnd=TRUE, ...)"},{"path":"https://github.com/covaruber/sommer/reference/plot_mmec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot form a LMM plot with mmec — plot.mmec","text":"x object class \"mmec\" stnd argument ploting residuals know standarized. ... arguments passed","code":""},{"path":"https://github.com/covaruber/sommer/reference/plot_mmec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot form a LMM plot with mmec — plot.mmec","text":"vector plot","code":""},{"path":"https://github.com/covaruber/sommer/reference/plot_mmec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plot form a LMM plot with mmec — plot.mmec","text":"Giovanny Covarrubias covarrubiasp@wisc.edu","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/plot_mmec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot form a LMM plot with mmec — plot.mmec","text":"","code":"data(DT_yatesoats) DT <- DT_yatesoats head(DT) #>   row col   Y   N          V  B         MP #> 1   1   1  91 0.2    Victory B2    Victory #> 2   2   1  61   0    Victory B2    Victory #> 3   3   1 121 0.4 Marvellous B2 Marvellous #> 4   4   1 144 0.6 Marvellous B2 Marvellous #> 5   5   1 149 0.6 GoldenRain B2 GoldenRain #> 6   6   1 108 0.2 GoldenRain B2 GoldenRain m3 <- mmec(fixed=Y ~ V + N + V:N,            random = ~ B + B:MP,            rcov=~units,            data = DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -220.267   1:16:20      0           0 #>     2      -213.15   1:16:20      0           0 #>     3      -209.956   1:16:20      0           0 #>     4      -209.412   1:16:20      0           0 #>     5      -209.384   1:16:20      0           0 #>     6      -209.379   1:16:20      0           0 #>     7      -209.378   1:16:20      0           0 #>     8      -209.378   1:16:20      0           0 plot(m3)"},{"path":"https://github.com/covaruber/sommer/reference/plot_mmer.html","id":null,"dir":"Reference","previous_headings":"","what":"plot form a LMM plot with mmer — plot.mmer","title":"plot form a LMM plot with mmer — plot.mmer","text":"plot method class \"mmer\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/plot_mmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot form a LMM plot with mmer — plot.mmer","text":"","code":"# S3 method for class 'mmer' plot(x,stnd=TRUE, ...)"},{"path":"https://github.com/covaruber/sommer/reference/plot_mmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot form a LMM plot with mmer — plot.mmer","text":"x object class \"mmer\" stnd argument ploting residuals know standarized. ... arguments passed","code":""},{"path":"https://github.com/covaruber/sommer/reference/plot_mmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot form a LMM plot with mmer — plot.mmer","text":"vector plot","code":""},{"path":"https://github.com/covaruber/sommer/reference/plot_mmer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plot form a LMM plot with mmer — plot.mmer","text":"Giovanny Covarrubias covarrubiasp@wisc.edu","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/plot_mmer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot form a LMM plot with mmer — plot.mmer","text":"","code":"data(DT_yatesoats) DT <- DT_yatesoats head(DT) #>   row col   Y   N          V  B         MP #> 1   1   1  91 0.2    Victory B2    Victory #> 2   2   1  61   0    Victory B2    Victory #> 3   3   1 121 0.4 Marvellous B2 Marvellous #> 4   4   1 144 0.6 Marvellous B2 Marvellous #> 5   5   1 149 0.6 GoldenRain B2 GoldenRain #> 6   6   1 108 0.2 GoldenRain B2 GoldenRain m3 <- mmer(fixed=Y ~ V + N + V:N,            random = ~ B + B:MP,            rcov=~units,            data = DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -4.46709   1:16:20      0           0 #>     2      -1.34644   1:16:20      0           0 #>     3      -0.788146   1:16:20      0           0 #>     4      -0.746308   1:16:20      0           0 #>     5      -0.745925   1:16:20      0           0 plot(m3)"},{"path":"https://github.com/covaruber/sommer/reference/predict_mmec.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict form of a LMM fitted with mmec — predict.mmec","title":"Predict form of a LMM fitted with mmec — predict.mmec","text":"predict method class \"mmec\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/predict_mmec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict form of a LMM fitted with mmec — predict.mmec","text":"","code":"# S3 method for class 'mmec' predict(object, Dtable=NULL, D, ...)"},{"path":"https://github.com/covaruber/sommer/reference/predict_mmec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict form of a LMM fitted with mmec — predict.mmec","text":"object mixed model class \"mmec\" Dtable table specifying terms included averaged. \"include\" term means model matrices fixed random effect filled 1's positions column names row names match. \"include average\" term means model matrices fixed random effect filled 1/#1's row. \"average\" term alone means rows fixed random effect filled 1/#levels effect. term considered \"include\" \"average\" totally ignored BLUP SE calculation. default rule invoke user provide Dtable include average terms match argument D.  D character string specifying variable used extract levels rows D matrix construction. Alternatively, D matrix (class dgCMatrix) specifying matrix used predictions directly. ... arguments passed.","code":""},{"path":"https://github.com/covaruber/sommer/reference/predict_mmec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict form of a LMM fitted with mmec — predict.mmec","text":"function allows produce predictions specifying variables define margins hypertable predicted (argument D). Predictions obtained combination values specified variables present data set used fit model. See vignettes details. predicted values pertinent design matrices X Z together BLUEs (b) BLUPs (u) multiplied added together. predicted.value equal Xb + Zu.1 + ... + Zu.n computing standard errors predictions parts coefficient matrix: C11 equal (X.t() V.inv() X).inv() C12 equal 0 - [(X.t() V.inv() X).inv() X.t() V.inv() G Z] C22 equal PEV equal G - [Z.t() G[V.inv() - (V.inv() X X.t() V.inv() X V.inv() X)]G Z.t()] practive C equals ( W.t() V.inv() W ).inv() fixed random effects present inclusion set. fixed random effects included, respective terms SE fixed random effects calculated.","code":""},{"path":"https://github.com/covaruber/sommer/reference/predict_mmec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict form of a LMM fitted with mmec — predict.mmec","text":"pvals table predictions according specified arguments. vcov variance covariance predictions. D model matrix predictions defined Welham et al.(2004). Dtable table specifying terms include terms averaged.","code":""},{"path":"https://github.com/covaruber/sommer/reference/predict_mmec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predict form of a LMM fitted with mmec — predict.mmec","text":"Welham, S., Cullis, B., Gogel, B., Gilmour, ., Thompson, R. (2004). Prediction linear mixed models. Australian New Zealand Journal Statistics, 46, 325 - 347.","code":""},{"path":"https://github.com/covaruber/sommer/reference/predict_mmec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Predict form of a LMM fitted with mmec — predict.mmec","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/predict_mmec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict form of a LMM fitted with mmec — predict.mmec","text":"","code":"data(DT_yatesoats) DT <- DT_yatesoats m3 <- mmec(fixed=Y ~ V + N + V:N ,            random = ~ B + B:MP,            rcov=~units,            data = DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -220.267   1:16:20      0           0 #>     2      -213.15   1:16:20      0           0 #>     3      -209.956   1:16:20      0           0 #>     4      -209.412   1:16:20      0           0 #>     5      -209.384   1:16:20      0           0 #>     6      -209.379   1:16:20      0           0 #>     7      -209.378   1:16:20      0           0 #>     8      -209.378   1:16:20      0           0  ############################# ## predict means for nitrogen ############################# Dt <- m3$Dtable; Dt #>     type               term include average #> 1  fixed                  V   FALSE   FALSE #> 2  fixed                  N   FALSE   FALSE #> 3  fixed                V:N   FALSE   FALSE #> 4 random    vsc( isc( B ) )   FALSE   FALSE #> 5 random vsc( isc( B:MP ) )   FALSE   FALSE # first fixed effect just average Dt[1,\"average\"] = TRUE # second fixed effect include Dt[2,\"include\"] = TRUE # third fixed effect include and average Dt[3,\"include\"] = TRUE Dt[3,\"average\"] = TRUE Dt #>     type               term include average #> 1  fixed                  V   FALSE    TRUE #> 2  fixed                  N    TRUE   FALSE #> 3  fixed                V:N    TRUE    TRUE #> 4 random    vsc( isc( B ) )   FALSE   FALSE #> 5 random vsc( isc( B:MP ) )   FALSE   FALSE  pp=predict(object=m3, Dtable=Dt, D=\"N\") pp$pvals #>       N predicted.value std.error #> 0     0        79.38889  7.153894 #> 0.2 0.2        98.88889  7.153894 #> 0.4 0.4       114.22222  7.153894 #> 0.6 0.6       123.38889  7.153894  ############################# ## predict means for variety #############################  Dt <- m3$Dtable; Dt #>     type               term include average #> 1  fixed                  V   FALSE   FALSE #> 2  fixed                  N   FALSE   FALSE #> 3  fixed                V:N   FALSE   FALSE #> 4 random    vsc( isc( B ) )   FALSE   FALSE #> 5 random vsc( isc( B:MP ) )   FALSE   FALSE # first fixed effect include Dt[1,\"include\"] = TRUE # second fixed effect just average Dt[2,\"average\"] = TRUE # third fixed effect include and average Dt[3,\"include\"] = TRUE Dt[3,\"average\"] = TRUE Dt #>     type               term include average #> 1  fixed                  V    TRUE   FALSE #> 2  fixed                  N   FALSE    TRUE #> 3  fixed                V:N    TRUE    TRUE #> 4 random    vsc( isc( B ) )   FALSE   FALSE #> 5 random vsc( isc( B:MP ) )   FALSE   FALSE  pp=predict(object=m3, Dtable=Dt, D=\"V\") pp$pvals #>                     V predicted.value std.error #> GoldenRain GoldenRain        104.5000  7.777895 #> Marvellous Marvellous        109.7917  7.777895 #> ictory         ictory         97.6250  7.777895  ############################# ## predict means for nitrogen:variety ############################# # prediction matrix D based on (equivalent to classify in asreml) Dt <- m3$Dtable; Dt #>     type               term include average #> 1  fixed                  V   FALSE   FALSE #> 2  fixed                  N   FALSE   FALSE #> 3  fixed                V:N   FALSE   FALSE #> 4 random    vsc( isc( B ) )   FALSE   FALSE #> 5 random vsc( isc( B:MP ) )   FALSE   FALSE # first fixed effect include and average Dt[1,\"include\"] = TRUE Dt[1,\"average\"] = TRUE # second fixed effect include and average Dt[2,\"include\"] = TRUE Dt[2,\"average\"] = TRUE # third fixed effect include and average Dt[3,\"include\"] = TRUE Dt[3,\"average\"] = TRUE Dt #>     type               term include average #> 1  fixed                  V    TRUE    TRUE #> 2  fixed                  N    TRUE    TRUE #> 3  fixed                V:N    TRUE    TRUE #> 4 random    vsc( isc( B ) )   FALSE   FALSE #> 5 random vsc( isc( B:MP ) )   FALSE   FALSE  pp=predict(object=m3, Dtable=Dt, D=\"N:V\") pp$pvals #>                               N:V predicted.value std.error #> N0:VGoldenRain     N0:VGoldenRain        80.00000  9.091182 #> N0.2:VGoldenRain N0.2:VGoldenRain        89.25000  8.238950 #> N0.4:VGoldenRain N0.4:VGoldenRain        97.33333  8.238950 #> N0.6:VGoldenRain N0.6:VGoldenRain       102.41667  8.238950 #> N0:VMarvellous     N0:VMarvellous        83.33333  7.684143 #> N0.2:VMarvellous N0.2:VMarvellous        94.25000  7.684143 #> N0.4:VMarvellous N0.4:VMarvellous        98.58333  7.684143 #> N0.6:VMarvellous N0.6:VMarvellous       103.41667  7.684143 #> N0:VVictory           N0:VVictory        75.75000  7.684143 #> N0.2:VVictory       N0.2:VVictory        84.83333  7.684143 #> N0.4:VVictory       N0.4:VVictory        95.41667  7.684143 #> N0.6:VVictory       N0.6:VVictory        99.25000  7.684143"},{"path":"https://github.com/covaruber/sommer/reference/predict_mmer.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict form of a LMM fitted with mmer — predict.mmer","title":"Predict form of a LMM fitted with mmer — predict.mmer","text":"predict method class \"mmer\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/predict_mmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict form of a LMM fitted with mmer — predict.mmer","text":"","code":"# S3 method for class 'mmer' predict(object, Dtable=NULL, D, ...)"},{"path":"https://github.com/covaruber/sommer/reference/predict_mmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict form of a LMM fitted with mmer — predict.mmer","text":"object mixed model class \"mmer\" Dtable table specifying terms included averaged. \"include\" term means model matrices fixed random effect filled 1's positions column names row names match. \"include average\" term means model matrices fixed random effect filled 1/#1's row. \"average\" term alone means rows fixed random effect filled 1/#levels effect. term considered \"include\" \"average\" totally ignored BLUP SE calculation. default rule invoke user provide Dtable include average terms match argument D.  D character string specifying variable used extract levels rows D matrix construction. Alternatively, D matrix (class dgCMatrix) specifying matrix used predictions directly. ... arguments passed.","code":""},{"path":"https://github.com/covaruber/sommer/reference/predict_mmer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict form of a LMM fitted with mmer — predict.mmer","text":"function allows produce predictions specifying variables define margins hypertable predicted (argument D). Predictions obtained combination values specified variables present data set used fit model. See vignettes details. predicted values pertinent design matrices X Z together BLUEs (b) BLUPs (u) multiplied added together. predicted.value equal Xb + Zu.1 + ... + Zu.n computing standard errors predictions parts coefficient matrix: C11 equal (X.t() V.inv() X).inv() C12 equal 0 - [(X.t() V.inv() X).inv() X.t() V.inv() G Z] C22 equal PEV equal G - [Z.t() G[V.inv() - (V.inv() X X.t() V.inv() X V.inv() X)]G Z.t()] practive C equals ( W.t() V.inv() W ).inv() fixed random effects present inclusion set. fixed random effects included, respective terms SE fixed random effects calculated.","code":""},{"path":"https://github.com/covaruber/sommer/reference/predict_mmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict form of a LMM fitted with mmer — predict.mmer","text":"pvals table predictions according specified arguments. vcov variance covariance predictions. D model matrix predictions defined Welham et al.(2004). Dtable table specifying terms include terms averaged.","code":""},{"path":"https://github.com/covaruber/sommer/reference/predict_mmer.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predict form of a LMM fitted with mmer — predict.mmer","text":"Welham, S., Cullis, B., Gogel, B., Gilmour, ., Thompson, R. (2004). Prediction linear mixed models. Australian New Zealand Journal Statistics, 46, 325 - 347.","code":""},{"path":"https://github.com/covaruber/sommer/reference/predict_mmer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Predict form of a LMM fitted with mmer — predict.mmer","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/predict_mmer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict form of a LMM fitted with mmer — predict.mmer","text":"","code":"data(DT_yatesoats) DT <- DT_yatesoats m3 <- mmer(fixed=Y ~ V + N + V:N ,            random = ~ B + B:MP,            rcov=~units,            data = DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -4.46709   1:16:21      0           0 #>     2      -1.34644   1:16:21      0           0 #>     3      -0.788146   1:16:21      0           0 #>     4      -0.746308   1:16:21      0           0 #>     5      -0.745925   1:16:21      0           0  ############################# ## predict means for nitrogen ############################# pp=predict(object=m3, D=\"N\") pp$pvals #>       N predicted.value std.error #> 0     0         80.0000  9.106654 #> 0.2 0.2         98.5000  9.106654 #> 0.4 0.4        114.6667  9.106654 #> 0.6 0.6        124.8333  9.106654  ############################# ## predict means for variety ############################# pp=predict(object=m3, D=\"V\") pp$pvals #>                     V predicted.value std.error #> GoldenRain GoldenRain        80.00000  9.106654 #> Marvellous Marvellous        86.66667  9.106654 #> ictory         ictory        71.50000  9.106654"},{"path":"https://github.com/covaruber/sommer/reference/propMissing.html","id":null,"dir":"Reference","previous_headings":"","what":"Proportion of missing data — propMissing","title":"Proportion of missing data — propMissing","text":"propMissing quick calculation proportion missing data vector.","code":""},{"path":"https://github.com/covaruber/sommer/reference/propMissing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proportion of missing data — propMissing","text":"","code":"propMissing(x)"},{"path":"https://github.com/covaruber/sommer/reference/propMissing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Proportion of missing data — propMissing","text":"x vector observations.","code":""},{"path":"https://github.com/covaruber/sommer/reference/propMissing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proportion of missing data — propMissing","text":"$res numeric value proportion missing data.","code":""},{"path":"https://github.com/covaruber/sommer/reference/propMissing.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Proportion of missing data — propMissing","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/propMissing.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Proportion of missing data — propMissing","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/propMissing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Proportion of missing data — propMissing","text":"","code":"x <- c(1:10, NA) propMissing(x) #> [1] 0.09090909"},{"path":"https://github.com/covaruber/sommer/reference/r2.html","id":null,"dir":"Reference","previous_headings":"","what":"Reliability — r2","title":"Reliability — r2","text":"Calculates reliability BLUPs sommer model.","code":""},{"path":"https://github.com/covaruber/sommer/reference/r2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reliability — r2","text":"","code":"r2(object, object2=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/r2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reliability — r2","text":"object Model fitted mmec function. object2 optional model identical object first argument fitted argument returnParam set TRUE access relationship matrices fitted model.","code":""},{"path":"https://github.com/covaruber/sommer/reference/r2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reliability — r2","text":"reliability method calculated classical animal model: R2=(G-PEV)/G","code":""},{"path":"https://github.com/covaruber/sommer/reference/r2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reliability — r2","text":"result list many elements random effects fitted containing reliabilities individual BLUPs.","code":""},{"path":"https://github.com/covaruber/sommer/reference/r2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Reliability — r2","text":"Mrode, R. . (2014). Linear models prediction animal breeding values. Cabi. Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/r2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reliability — r2","text":"","code":"####=========================================#### #### Example population ####=========================================#### data(DT_example) DT <- DT_example head(DT) #>                   Name     Env Loc Year     Block Yield    Weight #> 33  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.1     4 -1.904711 #> 65          CO02024-9W CA.2013  CA 2013 CA.2013.1     5 -1.446958 #> 66  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.2     5 -1.516271 #> 67            MSL007-B CA.2011  CA 2011 CA.2011.2     5 -1.435510 #> 68           MSR169-8Y CA.2013  CA 2013 CA.2013.1     5 -1.469051 #> 103         AC05153-1W CA.2013  CA 2013 CA.2013.1     6 -1.307167 ans1 <- mmec(Yield~Env,              random= ~ Name + Env:Name,              rcov= ~ units,              data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -327.295   1:16:21      0           0 #>     2      -311.454   1:16:21      0           0 #>     3      -304.865   1:16:21      0           0 #>     4      -302.661   1:16:21      0           0 #>     5      -301.766   1:16:21      0           0 #>     6      -301.251   1:16:22      1           0 #>     7      -300.978   1:16:22      1           0 #>     8      -300.877   1:16:22      1           0 #>     9      -300.855   1:16:22      1           0 #>     10      -300.852   1:16:22      1           0 #>     11      -300.852   1:16:22      1           0 rel=r2(ans1)"},{"path":"https://github.com/covaruber/sommer/reference/randef.html","id":null,"dir":"Reference","previous_headings":"","what":"extracting random effects — randef","title":"extracting random effects — randef","text":"function extracts random effects mixed model fitted mmer.","code":""},{"path":"https://github.com/covaruber/sommer/reference/randef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"extracting random effects — randef","text":"","code":"randef(object)"},{"path":"https://github.com/covaruber/sommer/reference/randef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"extracting random effects — randef","text":"object mmer object","code":""},{"path":"https://github.com/covaruber/sommer/reference/randef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"extracting random effects — randef","text":"$randef list structure random effects BLUPs.","code":""},{"path":"https://github.com/covaruber/sommer/reference/randef.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"extracting random effects — randef","text":"","code":"# randef(model)"},{"path":"https://github.com/covaruber/sommer/reference/redmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Reduced Model Matrix — redmm","title":"Reduced Model Matrix — redmm","text":"`redmm` reduces model matrix performing singular value decomposition Cholesky incidence matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/redmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reduced Model Matrix — redmm","text":"","code":"redmm(x, M = NULL, Lam=NULL, nPC=50, cholD=FALSE, returnLam=FALSE)"},{"path":"https://github.com/covaruber/sommer/reference/redmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reduced Model Matrix — redmm","text":"x vector values form model matrix complete incidence matrix effect interest. M optional matrix features explaining levels x. provided assumed entire incidence matrix provided x. provided, decomposition occurs matrix M. Lam matrix loadings case already available avoid recomputing . nPC number principal components keep matrix loadings form model matrix. cholD Cholesky Singular value decomposition used. default SVD. returnLam function return loading matrix addition incidence matrix. Default FALSE.","code":""},{"path":"https://github.com/covaruber/sommer/reference/redmm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reduced Model Matrix — redmm","text":"$S3 list 3 elements: 1) model matrix used mixed modeling. 2) reduced matrix loadings (nPC columns). 3) full matrix loadings.","code":""},{"path":"https://github.com/covaruber/sommer/reference/redmm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Reduced Model Matrix — redmm","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/redmm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reduced Model Matrix — redmm","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/redmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reduced Model Matrix — redmm","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================####  data(DT_technow) DT <- DT_technow Md <- Md_technow  M <- tcrossprod(Md) xx = with(DT, redmm(x=dent, M=M, nPC=10))  # ans <- mmec(GY~1, #             # new model matrix instead of dent #             random=~vsc(isc(xx$Z)), #             rcov=~units, #             data=DT) # summary(ans)$varcomp # u = xx$Lam * ans$uList[[1]] # change * for matrix product"},{"path":"https://github.com/covaruber/sommer/reference/residuals_mmec.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals form a GLMM fitted with mmec — residuals.mmec","title":"Residuals form a GLMM fitted with mmec — residuals.mmec","text":"residuals method class \"mmec\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/residuals_mmec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals form a GLMM fitted with mmec — residuals.mmec","text":"","code":"# S3 method for class 'mmec' residuals(object, ...)"},{"path":"https://github.com/covaruber/sommer/reference/residuals_mmec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals form a GLMM fitted with mmec — residuals.mmec","text":"object object class \"mmec\" ... arguments passed","code":""},{"path":"https://github.com/covaruber/sommer/reference/residuals_mmec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals form a GLMM fitted with mmec — residuals.mmec","text":"vector residuals form e = y - Xb - Zu, called conditional residuals.","code":""},{"path":"https://github.com/covaruber/sommer/reference/residuals_mmec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Residuals form a GLMM fitted with mmec — residuals.mmec","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/residuals_mmer.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals form a GLMM fitted with mmer — residuals.mmer","title":"Residuals form a GLMM fitted with mmer — residuals.mmer","text":"residuals method class \"mmer\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/residuals_mmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals form a GLMM fitted with mmer — residuals.mmer","text":"","code":"# S3 method for class 'mmer' residuals(object, ...)"},{"path":"https://github.com/covaruber/sommer/reference/residuals_mmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals form a GLMM fitted with mmer — residuals.mmer","text":"object object class \"mmer\" ... arguments passed","code":""},{"path":"https://github.com/covaruber/sommer/reference/residuals_mmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals form a GLMM fitted with mmer — residuals.mmer","text":"vector residuals form e = y - Xb - Zu, called conditional residuals.","code":""},{"path":"https://github.com/covaruber/sommer/reference/residuals_mmer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Residuals form a GLMM fitted with mmer — residuals.mmer","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/rrc.html","id":null,"dir":"Reference","previous_headings":"","what":"reduced rank covariance structure — rrc","title":"reduced rank covariance structure — rrc","text":"rrc creates reduced rank factor analytic covariance structure selecting n vectors L matrix Cholesky decomposition U vectors SVD decomposition (loadings latent covariates) create new incidence matrix latent covariates can used mmec solver fit random regressions latent covariates.","code":""},{"path":"https://github.com/covaruber/sommer/reference/rrc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"reduced rank covariance structure — rrc","text":"","code":"rrc(x=NULL, H=NULL, nPC=2, returnGamma=FALSE, cholD=TRUE)"},{"path":"https://github.com/covaruber/sommer/reference/rrc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"reduced rank covariance structure — rrc","text":"x vector dataset containing variable used form incidence matrix. H two-way table identifiers (rows; e.g., genotypes) features (columns; e.g., environments) effects. Row names column names required. missing data allowed. nPC number principal components keep loadings matrix. returnGamma TRUE/FALSE argument specifying function return matrix loadings used build incidence matrix model. default FALSE returns incidence matrix. cholD TRUE/FALSE argument specifying Cholesky decomposition calculated singular value decomposition used instead.","code":""},{"path":"https://github.com/covaruber/sommer/reference/rrc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"reduced rank covariance structure — rrc","text":"implementation version reduced rank factor analytic models uses -called principal component (PC) models (Meyer, 2009) assumes specific effects (psi) equal 0. model follows: y = Xb + Zu + e variance u ~ MVN(0, Sigma) Sigma = (Gamma_t Gamma) + Psi Extended factor analytic model: y = Xb + Z(Gamma)c + Zs + e = Xb + Z*c + Zs + e y response variable, X Z incidence matrices fixed random effects respectively, diagonal matrix, Gamma factor loadings c common factor scores, s specific effects, e vector residuals. Reduced rank model: y = Xb + Z(Gamma)c + e = Xb + Z*c + e equal one assumes specific effects = 0. algorithm rrc following: 1) uses wide-format table timevar (m columns) idvar (q rows) named H form initial variance-covariance matrix (Sigma) calculated Sigma = H'H dimensions m x m (column dimensions, e.g., environments x environments). 2) Sigma matrix center scaled. 3) Cholesky (L matrix) SVD decomposition (U D V') performed Sigma matrix. 4) n vectors L (Cholesky used) U sqrt(D) (SVD used) kept form Gamma. Gamma = L[,1:nPc] Gamma = U[,1:nPC]. -called loadings (L loadings, Gamma subset loadings). 4) Gamma used form new incidence matrix Z* = Z Gamma 5) matrix later used REML machinery used usc (unstructured) dsc (diagonal) structures estimate variance components factor scores. resulting BLUPs mixed model optimized factor scores. Pretty much random regression latent covariates. implementation update loadings (latent covariates) REML process, estimates REML factor scores fixed loadings. different software (e.g., asreml) loadings updated REML process well. BLUPs genotypes locations can recovered : u = Gamma * u_scores resulting loadings (Gamma) factor scores can thought equivalent classical factor analysis.","code":""},{"path":"https://github.com/covaruber/sommer/reference/rrc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"reduced rank covariance structure — rrc","text":"$Z incidence matrix Z* = Z Gamma original incidence matrix timevar multiplied loadings. $Gamma matrix loadings latent covariates. $Sigma covariance matrix used calculate Gamma.","code":""},{"path":"https://github.com/covaruber/sommer/reference/rrc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"reduced rank covariance structure — rrc","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Meyer K (2009) Factor analytic models genotype environment type problems structured covariance matrices. Genetics Selection Evolution, 41:21","code":""},{"path":"https://github.com/covaruber/sommer/reference/rrc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"reduced rank covariance structure — rrc","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/rrc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"reduced rank covariance structure — rrc","text":"","code":"data(DT_h2) DT <- DT_h2 DT=DT[with(DT, order(Env)), ] head(DT) #>          Name     Env Loc Year     Block  y #> 67   MSL007-B CA.2011  CA 2011 CA.2011.2  5 #> 105  MSL007-B CA.2011  CA 2011 CA.2011.1  6 #> 308  MSK061-4 CA.2011  CA 2011 CA.2011.2  9 #> 393  MSK061-4 CA.2011  CA 2011 CA.2011.1 10 #> 469 MSR169-8Y CA.2011  CA 2011 CA.2011.1 11 #> 471     NY148 CA.2011  CA 2011 CA.2011.1 11 indNames <- na.omit(unique(DT$Name)) A <- diag(length(indNames)) rownames(A) <- colnames(A) <- indNames  # \\donttest{    # fit diagonal model first to produce H matrix ansDG <- mmec(y~Env,               random=~ vsc(dsc(Env), isc(Name)),               rcov=~units, nIters = 100,               # we recommend giving more EM iterations at the beggining               emWeight = c(rep(1,10),logspace(10,1,.05), rep(.05,80)),               data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -1509.65   1:16:24      1           0 #>     2      -1457.08   1:16:25      2           0 #>     3      -1407.42   1:16:26      3           0 #>     4      -1368.55   1:16:27      4           0 #>     5      -1343.65   1:16:27      4           0 #>     6      -1327.76   1:16:28      5           0 #>     7      -1318.84   1:16:29      6           0 #>     8      -1314.21   1:16:30      7           0 #>     9      -1311.84   1:16:31      8           0 #>     10      -1310.57   1:16:32      9           0 #>     11      -1309.85   1:16:33      10           0 #>     12      -1309.4   1:16:33      10           0 #>     13      -1308.98   1:16:34      11           0 #>     14      -1308.62   1:16:35      12           0 #>     15      -1308.29   1:16:36      13           0 #>     16      -1308.01   1:16:37      14           0 #>     17      -1307.77   1:16:38      15           0 #>     18      -1307.58   1:16:39      16           0 #>     19      -1307.44   1:16:40      17           0 #>     20      -1307.33   1:16:40      17           0 #>     21      -1307.27   1:16:41      18           0 #>     22      -1307.46   1:16:42      19           0  H0 <- ansDG$uList$`vsc(dsc(Env), isc(Name))` # GxE table  # reduced rank model ansFA <- mmec(y~Env,               random=~vsc( usc(rrc(Env, H = H0, nPC = 3)) , isc(Name)) + # rr                 vsc(dsc(Env), isc(Name)), # diag               rcov=~units,               # we recommend giving more iterations to these models               nIters = 100,               # we recommend giving more EM iterations at the beggining               emWeight = c(rep(1,10),logspace(10,1,.05), rep(.05,80)),               data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -1496.12   1:16:44      2           0 #>     2      -1428.93   1:16:46      4           0 #>     3      -1364.34   1:16:47      5           0 #>     4      -1319.74   1:16:49      7           0 #>     5      -1298.08   1:16:51      9           0 #>     6      -1286.14   1:16:52      10           0 #>     7      -1279.67   1:16:54      12           0 #>     8      -1276.14   1:16:56      14           0 #>     9      -1274.06   1:16:57      15           0 #>     10      -1272.67   1:16:59      17           0 #>     11      -1271.65   1:17:1      19           0 #>     12      -1270.85   1:17:2      20           0 #>     13      -1269.94   1:17:4      22           0 #>     14      -1268.97   1:17:6      24           0 #>     15      -1267.96   1:17:8      26           0 #>     16      -1266.99   1:17:9      27           0 #>     17      -1266.1   1:17:11      29           0 #>     18      -1265.33   1:17:13      31           0 #>     19      -1264.69   1:17:14      32           0 #>     20      -1264.19   1:17:16      34           0 #>     21      -1263.8   1:17:18      36           0 #>     22      -1263.61   1:17:19      37           0 #>     23      -1264.2   1:17:21      39           0  vcFA <- ansFA$theta[[1]] vcDG <- ansFA$theta[[2]]  loadings=with(DT, rrc(Env, nPC = 3, H = H0, returnGamma = TRUE) )$Gamma scores <- ansFA$uList[[1]]  vcUS <- loadings %*% vcFA %*% t(loadings) G <- vcUS + vcDG # colfunc <- colorRampPalette(c(\"steelblue4\",\"springgreen\",\"yellow\")) # hv <- heatmap(cov2cor(G), col = colfunc(100), symm = TRUE)  uFA <- scores %*% t(loadings) uDG <- ansFA$uList[[2]] u <- uFA + uDG    # }"},{"path":"https://github.com/covaruber/sommer/reference/simGECorMat.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a GE correlation matrix for simulation purposes. — simGECorMat","title":"Create a GE correlation matrix for simulation purposes. — simGECorMat","text":"Makes simple correlation matrix based number environments megaenvironments desired.","code":""},{"path":"https://github.com/covaruber/sommer/reference/simGECorMat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a GE correlation matrix for simulation purposes. — simGECorMat","text":"","code":"simGECorMat(nEnv,nMegaEnv,mu=0.7, v=0.2, mu2=0, v2=0.3)"},{"path":"https://github.com/covaruber/sommer/reference/simGECorMat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a GE correlation matrix for simulation purposes. — simGECorMat","text":"nEnv Number environments simulate. Needs divisible nMegaEnv argument. nMegaEnv Number megaenvironments simulate. mu Mean value genetic correlation within megaenvironments. v variance genetic correlation within megaenvironments. mu2 Mean value genetic correlation megaenvironments. v2 variance genetic correlation megaenvironments.","code":""},{"path":"https://github.com/covaruber/sommer/reference/simGECorMat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a GE correlation matrix for simulation purposes. — simGECorMat","text":"Simple simulation correlation matrix environments megaenvironments.","code":""},{"path":"https://github.com/covaruber/sommer/reference/simGECorMat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a GE correlation matrix for simulation purposes. — simGECorMat","text":"G correlation matrix $G correlation matrix","code":""},{"path":"https://github.com/covaruber/sommer/reference/simGECorMat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a GE correlation matrix for simulation purposes. — simGECorMat","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/simGECorMat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a GE correlation matrix for simulation purposes. — simGECorMat","text":"","code":"simGECorMat(9,3) #>              [,1]         [,2]        [,3]         [,4]       [,5]        [,6] #>  [1,]  1.00000000  0.896955994  0.45505242  0.068243833  0.4906042  0.10349851 #>  [2,]  0.89695599  1.000000000  0.84194524 -0.008220421  0.1313082  0.13031876 #>  [3,]  0.45505242  0.841945244  1.00000000  0.060263337 -0.3580608  0.39104330 #>  [4,]  0.06824383 -0.008220421  0.06026334  1.000000000  0.6781560  0.98000000 #>  [5,]  0.49060424  0.131308166 -0.35806076  0.678156001  1.0000000  0.65131106 #>  [6,]  0.10349851  0.130318758  0.39104330  0.980000000  0.6513111  1.00000000 #>  [7,] -0.33813986 -0.554691093  0.05865872  0.180469568  0.1917474 -0.41699785 #>  [8,] -0.33890336 -0.342346258 -0.20660145  0.051059345  0.1783450 -0.24450980 #>  [9,] -0.85930405  0.286147045  0.18458543 -0.210261210 -0.3220984 -0.08999736 #>              [,7]        [,8]        [,9] #>  [1,] -0.33813986 -0.33890336 -0.85930405 #>  [2,] -0.55469109 -0.34234626  0.28614704 #>  [3,]  0.05865872 -0.20660145  0.18458543 #>  [4,]  0.18046957  0.05105935 -0.21026121 #>  [5,]  0.19174745  0.17834503 -0.32209840 #>  [6,] -0.41699785 -0.24450980 -0.08999736 #>  [7,]  1.00000000  0.39457860  0.79836687 #>  [8,]  0.39457860  1.00000000  0.77090073 #>  [9,]  0.79836687  0.77090073  1.00000000"},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Solving Mixed Model Equations in R   — sommer-package","title":"Solving Mixed Model Equations in R   — sommer-package","text":"Sommer structural multivariate-univariate linear mixed model solver multiple random effects allowing specification /estimation variance covariance structures. REML estimates can obtained using two major methods Direct-Inversion (Newton-Raphson Average Information) >> mmer function Henderson's mixed model equations (Average Information) >> mmec function algorithms coded C++ using Armadillo library optimize dense matrix operations common genomic models. Sommer designed include complex covariance structures, e.g., unstructured, reduced-rank, diagonal. also model relationships levels random effect, e.g., additive, dominance epistatic relationship structures. mmer function can deal well small medium-size data sets (< 10,000 observations/records average computers given computational burden carried direct-inversion algorithms) since works c > r problem inverts r x r matrix (r number records c number coefficients). hand, mmec function can deal greater number records (r>250K) long number coefficients estimate < 10,000 coefficients (c) since works r > c problem inverts c x c matrix (c number coefficients). predict.mmer predict.mmec functions can used obtain adjusted means. package returns variance-covariance components, BLUPs, BLUEs, residuals, fitted values, variances-covariances fixed random effects, etc.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Solving Mixed Model Equations in R   — sommer-package","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"functions-for-genetic-analysis","dir":"Reference","previous_headings":"","what":"Functions for genetic analysis","title":"Solving Mixed Model Equations in R   — sommer-package","text":"package provides kernels estimate additive (.mat), dominance (D.mat), epistatic (E.mat), single-step (H.mat) relationship matrices diploid polyploid organisms. also provides flexibility fit genetic models full half diallel models random regression models. good converter letter code numeric format implemented function atcg1234, supports higher ploidy levels diploid. Additional functions genetic analysis included build genotypic hybrid marker matrix (build.HMM), plot genetic maps (map.plot), creation manhattan plots (manhattan). need use pedigree need convert pedigree relationship matrix (use `getA` function pedigreemm package).","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"functions-for-statistical-analysis-and-s-methods","dir":"Reference","previous_headings":"","what":"Functions for statistical analysis and S3 methods","title":"Solving Mixed Model Equations in R   — sommer-package","text":"vpredict function can used estimate standard errors linear combinations variance components (e.g. ratios like h2). r2 function calculates reliability. S3 methods available parameter extraction : + predict.mmer, predict.mmec, + fitted.mmer, fitted.mmec, + residuals.mmer,  residuals.mmec, + summary.mmer,  summary.mmec, + coef.mmer, coef.mmec, + anova.mmer, anova.mmec, + plot.mmer, plot.mmec.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"functions-for-trial-analysis","dir":"Reference","previous_headings":"","what":"Functions for trial analysis","title":"Solving Mixed Model Equations in R   — sommer-package","text":"Recently, spatial modeling added added sommer using two-dimensional spline (spl2Da spl2Db mmer spl2Dc mmec ) functions.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"keeping-sommer-updated","dir":"Reference","previous_headings":"","what":"Keeping sommer updated","title":"Solving Mixed Model Equations in R   — sommer-package","text":"sommer package updated CRAN every 4-months due CRAN policies can find latest source https://github.com/covaruber/sommer. can easily installed typing following R console: library(devtools) install_github(\"covaruber/sommer\") recommended reported bug, fixed immediately pushed GitHub CRAN next update.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"tutorials","dir":"Reference","previous_headings":"","what":"Tutorials","title":"Solving Mixed Model Equations in R   — sommer-package","text":"tutorials perform different analysis sommer please look vignettes typing terminal: vignette(\"v1.sommer.quick.start\") vignette(\"v2.sommer.changes..faqs\") vignette(\"v3.sommer.qg\") vignette(\"v4.sommer.gxe\") visit https://covaruber.github.io","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"getting-started","dir":"Reference","previous_headings":"","what":"Getting started","title":"Solving Mixed Model Equations in R   — sommer-package","text":"package equiped several datasets learn use sommer package (almost learn sort quantitative genetic analysis): * DT_halfdiallel, DT_fulldiallel DT_mohring datasets examples fit half full diallel designs. * DT_h2 calculate heritability * DT_cornhybrids DT_technow datasets perform genomic prediction hybrid single crosses * DT_wheat dataset genomic prediction single crosses species displaying additive effects. * DT_cpdata dataset fit genomic prediction models within biparental population coming 2 highly heterozygous parents including additive, dominance epistatic effects. * DT_polyploid fit genomic prediction GWAS analysis polyploids. * DT_gryphon data contains example animal model including pedigree information. * DT_btdata dataset contains animal (birds) model. * DT_legendre simulated dataset random regression model. * DT_sleepstudy dataset know translate lme4 models sommer models.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"differences-of-sommer-gt-with-previous-versions","dir":"Reference","previous_headings":"","what":"Differences of sommer >= 4.1.7 with previous versions","title":"Solving Mixed Model Equations in R   — sommer-package","text":"Since version 4.1.7 introduced mme-based average information function `mmec` much faster dealing r > c problem (records coefficients estimate). introduces covariance structure functons vsc(), usc(), dsc(), atc(), csc(). Please give try, although early phase development.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"differences-of-sommer-gt-with-previous-versions-1","dir":"Reference","previous_headings":"","what":"Differences of sommer >= 3.7.0 with previous versions","title":"Solving Mixed Model Equations in R   — sommer-package","text":"Since version 3.7 completly redefined specification variance-covariance structures provide flexibility user. particularly helped residual covariance structures easier combination custom random effects overlay models. think although bring uncomfortable situations beggining, long term help users fit better models. esence, abandoned asreml formulation (structures available) given limitations combine sommer structures covariance structures can now fitted using `vsr` functions.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"differences-of-sommer-gt-with-previous-versions-2","dir":"Reference","previous_headings":"","what":"Differences of sommer >= 3.0.0 with previous versions","title":"Solving Mixed Model Equations in R   — sommer-package","text":"Since version 3.0 decided focus developing multivariate solver decided remove M argument (GWAS analysis) mmer function move function GWAS. mmer solver implemented usr(trait), diag(trait), (trait) asreml formulation multivariate models allow specify structure trait multivariate models. Therefore MVM argument longer needed. version 3.7 now multi-trait structures can specified Gt Gtc arguments vsr function. Average Information algorithm removed past package instability deal complex models without good initial values. Now 3.7 brought back noticed starting NR first three iterations gives enough flexibility AI algorithm. Keep mind sommer uses direct inversion (DI) algorithm can slow datasets many observations (big 'n'). package focused problems type p > n (random effect(s) levels observations) models dense covariance structures. example, experiment dense covariance structures low-replication (.e. 2000 records 1000 individuals replicated  twice covariance structure 1000x1000) sommer faster MME-based software. Also genomic problems large number random effect levels, .e. 300 individuals (n) 100,000 genetic markers (p). hand, highly replicated trials small covariance structures n > p (.e. 2000 records 200 individuals replicated 10 times covariance structure 200x200) asreml MME-based algorithms much faster recommend use software.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"models-enabled","dir":"Reference","previous_headings":"","what":"Models Enabled","title":"Solving Mixed Model Equations in R   — sommer-package","text":"core package mmer mmec (formula-based) functions solve mixed model equations. functions interface call `NR` Direct-Inversion Newton-Raphson, `AI` Direct-Inversion Average Information mme-based Average Information (Tunnicliffe 1989; Gilmour et al. 1995; Lee et al. 2016). Since version 2.0 sommer can handle multivariate models. Following Maier et al. (2015), multivariate (extension univariate) mixed model implemented form:  y_i vector trait phenotypes, \\(\\beta_i\\) vector fixed effects, u_i vector random effects individuals e_i residuals trait (= 1,..., t). random effects (u_1 ... u_i e_i) assumed normally distributed mean zero. X Z incidence matrices fixed random effects respectively. distribution multivariate response phenotypic variance covariance (V) :  K relationship covariance matrix kth random effect (u=1,...,k), R=identity matrix residual term. terms \\(\\sigma^2_{g_{}}\\) \\(\\sigma^2_{\\epsilon_{}}\\) denote genetic (kth random terms) residual variance trait , respectively \\(\\sigma_{g_{_{ij}}}\\) \\(\\sigma_{\\epsilon_{_{ij}}}\\) genetic (kth random terms) residual covariance traits j (=1,...,t, j=1,...,t). algorithm implemented optimizes log likelihood:  || determinant matrix. REML estimates updated using Newton optimization algorithm form:  , theta vector variance components random effects covariance components among traits, H^-1 inverse Hessian matrix second derivatives kth cycle, dL/dsigma^2_i vector first derivatives likelihood respect variance-covariance components. Eigen decomposition relationship matrix proposed Lee Van Der Werf (2016) included Newton-Raphson algorithm improve time efficiency. Additionally, popular vpredict function estimate standard errors linear combinations variance components (.e. heritabilities genetic correlations) added package well.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"gwas-models","dir":"Reference","previous_headings":"","what":"GWAS Models","title":"Solving Mixed Model Equations in R   — sommer-package","text":"GWAS models sommer package enabled using M argument functions GWAS, expected numeric marker matrix. Markers treated fixed effects according model proposed Yu et al. (2006) diploids, Rosyara et al. (2016) (polyploids). matrices X M fixed effects, separated 2 different arguments distinguish factors environmental design factors argument \"X\" markers \"M\". genome-wide association analysis based mixed model: $$y = X \\beta + Z g + M \\tau + e$$ \\(\\beta\\) vector fixed effects can model environmental factors population structure. variable \\(g\\) models genetic background line random effect \\(Var[g] = K \\sigma^2\\). variable \\(\\tau\\) models additive SNP effect fixed effect.  residual variance \\(Var[\\varepsilon] = \\sigma_e^2\\) principal components included (P+K model), loadings determined eigenvalue decomposition K matrix used fixed effect part. argument \"P3D\" introduced Zhang et al. (2010) can used P3D argument.  P3D=FALSE, function equivalent AI/NR REML variance components estimated SNP marker tested (Kang et al. 2008).  P3D=TRUE, equivalent NR (Kang et al. 2010) assumption variance components SNP/markers therefore variance components estimated (markers tested WLS framework weight matrix (M) inverse phenotypic variance matrix (V)).  Therefore, P3D=TRUE option faster can underestimate significance compared P3D=FALSE. Multivariate GWAS based Covarrubias-Pazaran et al. (2018, preparation), adjusts betas response variables regular GWAS adjusted betas marker effects. extra details methods please read canonical papers listed References section.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"bug-report-and-contact","dir":"Reference","previous_headings":"","what":"Bug report and contact","title":"Solving Mixed Model Equations in R   — sommer-package","text":"questions suggestions please post https://stackoverflow.com https://stats.stackexchange.com glad help answer question. spent valuable amount time developing package. Please cite package publication. Type 'citation(\"sommer\")' know cite .","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Solving Mixed Model Equations in R   — sommer-package","text":"Covarrubias-Pazaran G. 2016. Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Covarrubias-Pazaran G. 2018. Software update: Moving R package sommer multivariate mixed models genome-assisted prediction. doi: https://doi.org/10.1101/354639 Bernardo Rex. 2010. Breeding quantitative traits plants. Second edition. Stemma Press. 390 pp. Gilmour et al. 1995. Average Information REML: efficient algorithm variance parameter estimation linear mixed models. Biometrics 51(4):1440-1450. Henderson C.R. 1975. Best Linear Unbiased Estimation Prediction Selection Model. Biometrics vol. 31(2):423-447. Kang et al. 2008. Efficient control population structure model organism association mapping. Genetics 178:1709-1723. Lee et al. 2015. MTG2: efficient algorithm multivariate linear mixed model analysis based genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201. Maier et al. 2015. Joint analysis psychiatric disorders increases accuracy risk prediction schizophrenia, bipolar disorder, major depressive disorder. J Hum Genet; 96(2):283-294. Searle. 1993. Applying EM algorithm calculating ML REML estimates variance components. Paper invited 1993 American Statistical Association Meeting, San Francisco. Yu et al. 2006. unified mixed-model method association mapping accounts multiple levels relatedness. Genetics 38:203-208. Tunnicliffe W. 1989. use marginal likelihood time series model estimation. JRSS 51(1):15-27.","code":""},{"path":"https://github.com/covaruber/sommer/reference/sommer-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solving Mixed Model Equations in R   — sommer-package","text":"","code":"####=========================================#### #### For CRAN time limitations most lines in the  #### examples are silenced with one '#' mark,  #### remove them and run the examples ####=========================================####  ####=========================================#### #### EXAMPLES #### Different models with sommer ####=========================================####  data(DT_example)  # DT <- DT_example # DT=DT[with(DT, order(Env)), ] # head(DT) #  # ####=========================================#### # #### Univariate homogeneous variance models  #### # ####=========================================#### #  # ## Compound simmetry (CS) model # ans1 <- mmer(Yield~Env, #              random= ~ Name + Env:Name, #              rcov= ~ units, #              data=DT) # summary(ans1) #  # ans2 <- mmec(Yield~Env, #              random= ~ Name + Env:Name, #              rcov= ~ units, #              data=DT) # summary(ans2) #  # ####===========================================#### # #### Univariate heterogeneous variance models  #### # ####===========================================#### # ## Compound simmetry (CS) + Diagonal (DIAG) model # ans3 <- mmer(Yield~Env, #              random= ~Name + vsr(dsr(Env),Name), #              rcov= ~ vsr(dsr(Env),units), #              data=DT) # summary(ans3) #  # ans4 <- mmec(Yield~Env, #              random= ~Name + vsc(dsc(Env),isc(Name)), #              rcov= ~ vsc(dsc(Env),isc(units)), #              data=DT) # summary(ans4)"},{"path":"https://github.com/covaruber/sommer/reference/spl2Da.html","id":null,"dir":"Reference","previous_headings":"","what":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Da","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Da","text":"Auxiliary function used modelling spatial environmental effect two-dimensional penalised tensor-product (isotropic approach) based Lee et al. (2013) Rodriguez-Alvarez et al. (2018). modified wrapper portions SpATS package build single incidence matrix containing columns tensor products x y coordinates fits matrix single random effect. heterogeneous covariances structure capabilities sommer can used enhance model fit. may interested reading citing sommer also Wageningen publications using 2D spline methodology.","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Da.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Da","text":"","code":"spl2Da(x.coord,y.coord,at.var=NULL,at.levels=NULL, type=\"PSANOVA\",        nsegments = c(10,10), penaltyord = c(2,2), degree = c(3,3),        nestorder = c(1,1))"},{"path":"https://github.com/covaruber/sommer/reference/spl2Da.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Da","text":"x.coord vector coordinates x-axis direction (.e. row) use 2 dimensional spline. y.coord vector coordinates y-axis direction (.e. range column) use 2 dimensional spline. .var vector indication variable heterogeneous variance required (e.g., different spl2D field). .levels character vector names leves term used, missing levels used. type one two methods \"PSANOVA\" \"SAP\". See details . nsegments numerical vector length 2 containing number segments marginal (strictly nsegments - 1 number internal knots domain covariate). Atomic values also valid, recycled. Default set 10. penaltyord numerical vector length 2 containing penalty order marginal. Atomic values also valid, recycled. Default set 2 (second order). Currently, second order penalties allowed. degree numerical vector length 2 containing order polynomial B-spline basis marginal. Atomic values also valid, recycled. Default set 3 (cubic B-splines). nestorder numerical vector length 2 containing divisor number segments (nsegments) used construction nested B-spline basis smooth--smooth interaction component. case, nested B-spline basis constructed assuming total nsegments/nestorder segments. Default set 1, implies nested basis used. See SAP details.","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Da.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Da","text":"following documentation taken SpATS package. Please refer package associated publications interested going deeper technique: Within P-spline framework, anisotropic low-rank tensor-product smoothers become general approach modelling multidimensional surfaces (Eilers Marx 2003; Wood 2006). original SpATS package, proposed model spatial environmental effect means tensor-product B-splines basis functions. words, proposed model spatial trend smooth bivariate surface jointly defined spatial coordinates. Accordingly, current function designed allow user specify spatial coordinates spatial trend function . restriction spatial coordinates shall specified: can longitude latitude position plot field column row numbers. restriction variables defining spatial coordinates numeric (contrast factors). far estimation concerned, used package equivalence P-splines linear mixed models (Currie Durban, 2002). approach, smoothing parameters expressed ratio variance components. Moreover, smooth components decomposed two parts: one penalised (treated fixed) one penalised (treated random). two-dimensional case, mixed model representation leads also interesting decomposition penalised part bivariate surface three different components (Lee Durban, 2011): () component contains smooth main effect (smooth trend)\talong one covariates surface function (, e.g, x-spatial coordinate column position plot field), (b) component contains smooth main effect (smooth trend) along covariate (.e., y-spatial coordinate row position); (c) smooth interaction component (sum linear--smooth interaction components smooth--smooth interaction component). original implementation SpATS assumes two different smoothing parameters, .e., one covariate smooth component. Accordingly, smoothing parameters used , main effects smooth interaction. However, approach can extended deal ANOVA-type decomposition presented Lee Durban (2011). approach, four different smoothing parameters considered smooth surface, concordance aforementioned decomposition: () two smoothing parameter, one main effects; (b) two smoothing parameter smooth interaction component. noted , computational burden associated estimation two-dimensional tensor-product smoother might prohibitive dimension marginal bases large. cases, Lee et al. (2013) propose reduce computational cost using nested bases. idea reduce dimension marginal bases (therefore associated number parameters estimated), smooth--smooth interaction component. pointed authors, simplification can justified fact main effects fact explain structure (spatial trend) presented data, less rich representation smooth--smooth interaction component needed. order ensure reduced bivariate surface fact nested model including main effects, Lee et al. (2013) show number segments used nested basis divisor number segments used original basis (nsegments argument). present function, divisor number segments specified argument nestorder. detailed review topic, see Lee (2010) Lee et al. (2013). \"PSANOVA\" approach represents alternative method. case, smooth bivariate surface (spatial trend) decomposed five different components depending single smoothing parameter (see Lee et al., 2013). —————– mentioned beginning, piece documentation stated taken completely SpATS package order provide deeper explanation. practice, sommer uses pieces code SpATS build design matrix containing columns tensor products x y coordinates fits matrix single random effect. result variance component assumed linear, linear linear, linear spline, spline spline interactions. results less flexible approach one proposed Rodriguez-Alvarez et al. (2018) still makes pretty good job model spatial variation. Use risk.","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Da.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Da","text":"Rodriguez-Alvarez, M.X, Boer, M.P., van Eeuwijk, F.., Eilers, P.H.C. (2018). SpATS: Spatial Analysis Field Trials Splines. R package version 1.0-9. https://CRAN.R-project.org/package=SpATS. Rodriguez-Alvarez, M.X., et al. (2015) Fast smoothng parameter separaton n multdmensonal generalzed P-splnes: SAP algorthm. Statistics Computing 25.5: 941-957. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Gilmour, .R., Cullis, B.R., Verbyla, .P. (1997). Accounting Natural Extraneous Variation Analysis Field Experiments. Journal Agricultural, Biological, Environmental Statistics, 2, 269 - 293.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/spl2Da.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Da","text":"","code":"## ============================ ## ## example to use spl2Da()  ## ============================ ##  data(DT_cpdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # A <- A.mat(GT) # mix <- mmer(Yield~1, #             random=~vsr(id, Gu=A) + #               vsr(Rowf) + #               vsr(Colf) + #               spl2Da(Row,Col), #             rcov=~units, #             data=DT) # summary(mix)$varcomp ## ============================ ## ## mimic 2 fields ## ============================ ##  # aa <- DT; bb <- DT # aa$FIELD <- \"A\";bb$FIELD <- \"B\" # set.seed(1234) # aa$Yield <- aa$Yield + rnorm(length(aa$Yield),0,4) # DT2 <- rbind(aa,bb) # head(DT2) # A <- A.mat(GT) # mix <- mmer(Yield~1, #             random=~vsr(dsr(FIELD),id, Gu=A) + #               vsr(dsr(FIELD),Rowf) + #               vsr(dsr(FIELD),Colf) + #                 spl2Da(Row,Col,at.var=FIELD), #             rcov=~vsr(dsr(FIELD),units), #             data=DT2)"},{"path":"https://github.com/covaruber/sommer/reference/spl2Db.html","id":null,"dir":"Reference","previous_headings":"","what":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Db","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Db","text":"Auxiliary function used modelling spatial environmental effect two-dimensional penalised tensor-product (isotropic approach) based Lee et al. (2013) Rodriguez-Alvarez et al. (2018). spl2Db gets Tensor-Product P-Spline Mixed Model Incidence Matrices     use sommer main function mmer. thank Sue Welham making TPSbits package available community. using function research please cite TPSbits package :) mostly wrapper tpsmmb function enable use sommer.","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Db.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Db","text":"","code":"spl2Db(x.coord,y.coord,at.var=NULL,at.levels=NULL,nsegments = c(10,10),         degree = c(3,3), penaltyord = c(2,2), nestorder = c(1,1),        minbound=NULL, maxbound=NULL, method=\"Lee\", what=\"bits\")"},{"path":"https://github.com/covaruber/sommer/reference/spl2Db.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Db","text":"x.coord vector coordinates x-axis direction (.e. row) use 2 dimensional spline. y.coord vector coordinates y-axis direction (.e. range column) use 2 dimensional spline. .var vector indication variable heterogeneous variance required (e.g., different spl2D field). .levels character vector names leves term used, missing levels used. nsegments numerical vector length 2 containing number segments marginal (strictly nsegments - 1 number internal knots domain covariate). Atomic values also valid, recycled. Default set 10. degree numerical vector length 2 containing order polynomial B-spline basis marginal. Atomic values also valid, recycled. Default set 3 (cubic B-splines). penaltyord numerical vector length 2 containing penalty order marginal. Atomic values also valid, recycled. Default set 2 (second order). Currently, second order penalties allowed. nestorder numerical vector length 2 containing divisor number segments (nsegments) used construction nested B-spline basis smooth--smooth interaction component. case, nested B-spline basis constructed assuming total nsegments/nestorder segments. Default set 1, implies nested basis used. See SAP details. minbound list length 2. lower bound used column row dimensions respectively; default calculated minimum value dimension. maxbound list length 2. upper bound used column row dimensions respectively; default calculated maximum value dimension. method string. Method forming penalty; default=\"Lee\" ie penalty Lee, Durban & Eilers (2013, CSDA 61, 22-37). alternative method \"Wood\" ie. method Wood et al (2012, Stat Comp 23, 341-360). option research tool requires investigation. one two values; 'base' 'bits' return: base = matrix columns cbind(TP.col,TP.row,TP.C.n,TP.R.n,TP.CR.n). used fixed part. bits = matrices tensor products. used random part.","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Db.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Db","text":"following documentation taken SpATS package. Please refer package associated publications interested going deeper technique: Within P-spline framework, anisotropic low-rank tensor-product smoothers become general approach modelling multidimensional surfaces (Eilers Marx 2003; Wood 2006). original SpATS package, proposed model spatial environmental effect means tensor-product B-splines basis functions. words, proposed model spatial trend smooth bivariate surface jointly defined spatial coordinates. Accordingly, current function designed allow user specify spatial coordinates spatial trend function . restriction spatial coordinates shall specified: can longitude latitude position plot field column row numbers. restriction variables defining spatial coordinates numeric (contrast factors). far estimation concerned, used package equivalence P-splines linear mixed models (Currie Durban, 2002). approach, smoothing parameters expressed ratio variance components. Moreover, smooth components decomposed two parts: one penalised (treated fixed) one penalised (treated random). two-dimensional case, mixed model representation leads also interesting decomposition penalised part bivariate surface three different components (Lee Durban, 2011): () component contains smooth main effect (smooth trend)\talong one covariates surface function (, e.g, x-spatial coordinate column position plot field), (b) component contains smooth main effect (smooth trend) along covariate (.e., y-spatial coordinate row position); (c) smooth interaction component (sum linear--smooth interaction components smooth--smooth interaction component). default implementation assumes two different smoothing parameters, .e., one covariate smooth component. Accordingly, smoothing parameters used , main effects smooth interaction. However, approach can extended deal ANOVA-type decomposition presented Lee Durban (2011). approach, four different smoothing parameters considered smooth surface, concordance aforementioned decomposition: () two smoothing parameter, one main effects; (b) two smoothing parameter smooth interaction component. noted , computational burden associated estimation two-dimensional tensor-product smoother might prohibitive dimension marginal bases large. cases, Lee et al. (2013) propose reduce computational cost using nested bases. idea reduce dimension marginal bases (therefore associated number parameters estimated), smooth--smooth interaction component. pointed authors, simplification can justified fact main effects fact explain structure (spatial trend) presented data, less rich representation smooth--smooth interaction component needed. order ensure reduced bivariate surface fact nested model including main effects, Lee et al. (2013) show number segments used nested basis divisor number segments used original basis (nsegments argument). present function, divisor number segments specified argument nestorder. detailed review topic, see Lee (2010) Lee et al. (2013). \"PSANOVA\" approach represents alternative method. case, smooth bivariate surface (spatial trend) decomposed five different components depending single smoothing parameter (see Lee et al., 2013).","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Db.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Db","text":"List length 7 elements: data = input data frame augmented structures required     fit tensor product splines asreml-R. data frame can used     fit TPS model. Added columns: TP.col, TP.row = column row coordinates TP.CxR = combined index use smooth x smooth term TP.C.n n=1:(diff.c) = X parts column spline use     random model (diff.c order column differencing) TP.R.n n=1:(diff.r) = X parts row spline use     random model (diff.r order row differencing) TP.CR.n n=1:((diff.c*diff.r)) = interaction     two X parts use fixed model. first variate     constant term omitted model constant     (1) present. elements     included model constant term omitted,     eg. y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + terms... asreml=\"grp\" \"sepgrp\", spline basis     functions also added data frame. Column numbers     term given grp list structure. fR = Xr1:Zc fC = Xr2:Zc fR.C = Zr:Xc1 R.fC = Zr:Xc2 fR.fC = Zc:Zr = Xr1:Zc | Xr2:Zc | Zr:Xc1 | Zr:Xc2 | Zc:Zr","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Db.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Db","text":"Sue Welham (2021). TPSbits: Creates Structures Enable Fitting Examination 2D Tensor-Product Splines using ASReml-R. R package version 1.0.0. Rodriguez-Alvarez, M.X, Boer, M.P., van Eeuwijk, F.., Eilers, P.H.C. (2018). SpATS: Spatial Analysis Field Trials Splines. R package version 1.0-9. https://CRAN.R-project.org/package=SpATS. Rodriguez-Alvarez, M.X., et al. (2015) Fast smoothng parameter separaton n multdmensonal generalzed P-splnes: SAP algorthm. Statistics Computing 25.5: 941-957. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Gilmour, .R., Cullis, B.R., Verbyla, .P. (1997). Accounting Natural Extraneous Variation Analysis Field Experiments. Journal Agricultural, Biological, Environmental Statistics, 2, 269 - 293.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/spl2Db.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Db","text":"","code":"## ============================ ## ## example to use spl2Db()  ## ============================ ##  data(DT_cpdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # A <- A.mat(GT) # mix <- mmer(Yield~1, #             random=~vsr(id, Gu=A) + #               vsr(Rowf) + #               vsr(Colf) + #               spl2Db(Row,Col), #             rcov=~units, #             data=DT) # summary(mix)$varcomp ## ============================ ## ## mimic 2 fields ## ============================ ##  # aa <- DT; bb <- DT # aa$FIELD <- \"A\";bb$FIELD <- \"B\" # set.seed(1234) # aa$Yield <- aa$Yield + rnorm(length(aa$Yield),0,4) # DT2 <- rbind(aa,bb) # head(DT2) # A <- A.mat(GT) # mix <- mmer(Yield~1, #             random=~vsr(dsr(FIELD),id, Gu=A) + #               vsr(dsr(FIELD),Rowf) + #               vsr(dsr(FIELD),Colf) + #                 spl2Db(Row,Col,at.var=FIELD), #             rcov=~vsr(dsr(FIELD),units), #             data=DT2)"},{"path":"https://github.com/covaruber/sommer/reference/spl2Dc.html","id":null,"dir":"Reference","previous_headings":"","what":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Dc","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Dc","text":"Auxiliary function used modelling spatial environmental effect two-dimensional penalised tensor-product (isotropic approach) based Lee et al. (2013) Rodriguez-Alvarez et al. (2018). modified wrapper portions SpATS package build single incidence matrix containing columns tensor products x y coordinates fits matrix single random effect. heterogeneous covariances structure capabilities sommec can used enhance model fit. may interested reading citing sommec also Wageningen publications using 2D spline methodology.","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Dc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Dc","text":"","code":"spl2Dc(x.coord,y.coord,at.var=NULL,at.levels=NULL, type=\"PSANOVA\",        nsegments = c(10,10), penaltyord = c(2,2), degree = c(3,3),        nestorder = c(1,1), thetaC=NULL, theta=NULL, sp=FALSE)"},{"path":"https://github.com/covaruber/sommer/reference/spl2Dc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Dc","text":"x.coord vector coordinates x-axis direction (.e. row) use 2 dimensional spline. y.coord vector coordinates y-axis direction (.e. range column) use 2 dimensional spline. .var vector indication variable heterogeneous variance required (e.g., different spl2D field). .levels character vector names leves term used, missing levels used. type one two methods \"PSANOVA\" \"SAP\". See details . nsegments numerical vector length 2 containing number segments marginal (strictly nsegments - 1 number internal knots domain covariate). Atomic values also valid, recycled. Default set 10. penaltyord numerical vector length 2 containing penalty order marginal. Atomic values also valid, recycled. Default set 2 (second order). Currently, second order penalties allowed. degree numerical vector length 2 containing order polynomial B-spline basis marginal. Atomic values also valid, recycled. Default set 3 (cubic B-splines). nestorder numerical vector length 2 containing divisor number segments (nsegments) used construction nested B-spline basis smooth--smooth interaction component. case, nested B-spline basis constructed assuming total nsegments/nestorder segments. Default set 1, implies nested basis used. See SAP details. thetaC optional matrix constraints variance components. theta optional matrix initial values variance components. sp TRUE/FALSE statement indicate VC structure multiplied scale parameter added mmec function addScaleParam argument mmec function .","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Dc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Dc","text":"following documentation taken SpATS package. Please refer package associated publications interested going deeper technique: Within P-spline framework, anisotropic low-rank tensor-product smoothers become general approach modelling multidimensional surfaces (Eilers Marx 2003; Wood 2006). original SpATS package, proposed model spatial environmental effect means tensor-product B-splines basis functions. words, proposed model spatial trend smooth bivariate surface jointly defined spatial coordinates. Accordingly, current function designed allow user specify spatial coordinates spatial trend function . restriction spatial coordinates shall specified: can longitude latitude position plot field column row numbers. restriction variables defining spatial coordinates numeric (contrast factors). far estimation concerned, used package equivalence P-splines linear mixed models (Currie Durban, 2002). approach, smoothing parameters expressed ratio variance components. Moreover, smooth components decomposed two parts: one penalised (treated fixed) one penalised (treated random). two-dimensional case, mixed model representation leads also interesting decomposition penalised part bivariate surface three different components (Lee Durban, 2011): () component contains smooth main effect (smooth trend)\talong one covariates surface function (, e.g, x-spatial coordinate column position plot field), (b) component contains smooth main effect (smooth trend) along covariate (.e., y-spatial coordinate row position); (c) smooth interaction component (sum linear--smooth interaction components smooth--smooth interaction component). original implementation SpATS assumes two different smoothing parameters, .e., one covariate smooth component. Accordingly, smoothing parameters used , main effects smooth interaction. However, approach can extended deal ANOVA-type decomposition presented Lee Durban (2011). approach, four different smoothing parameters considered smooth surface, concordance aforementioned decomposition: () two smoothing parameter, one main effects; (b) two smoothing parameter smooth interaction component. noted , computational burden associated estimation two-dimensional tensor-product smoother might prohibitive dimension marginal bases large. cases, Lee et al. (2013) propose reduce computational cost using nested bases. idea reduce dimension marginal bases (therefore associated number parameters estimated), smooth--smooth interaction component. pointed authors, simplification can justified fact main effects fact explain structure (spatial trend) presented data, less rich representation smooth--smooth interaction component needed. order ensure reduced bivariate surface fact nested model including main effects, Lee et al. (2013) show number segments used nested basis divisor number segments used original basis (nsegments argument). present function, divisor number segments specified argument nestorder. detailed review topic, see Lee (2010) Lee et al. (2013). \"PSANOVA\" approach represents alternative method. case, smooth bivariate surface (spatial trend) decomposed five different components depending single smoothing parameter (see Lee et al., 2013). —————– mentioned beginning, piece documentation stated taken completely SpATS package order provide deeper explanation. practice, sommec uses pieces code SpATS build design matrix containing columns tensor products x y coordinates fits matrix single random effect. result variance component assumed linear, linear linear, linear spline, spline spline interactions. results less flexible approach one proposed Rodriguez-Alvarez et al. (2018) still makes pretty good job model spatial variation. Use risk.","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Dc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Dc","text":"Rodriguez-Alvarez, M.X, Boer, M.P., van Eeuwijk, F.., Eilers, P.H.C. (2018). SpATS: Spatial Analysis Field Trials Splines. R package version 1.0-9. https://CRAN.R-project.org/package=SpATS. Rodriguez-Alvarez, M.X., et al. (2015) Fast smoothng parameter separaton n multdmensonal generalzed P-splnes: SAP algorthm. Statistics Computing 25.5: 941-957. Lee, D.-J., Durban, M., Eilers, P.H.C. (2013). Efficient two-dimensional smoothing P-spline ANOVA mixed models nested bases. Computational Statistics Data Analysis, 61, 22 - 37. Gilmour, .R., Cullis, B.R., Verbyla, .P. (1997). Accounting Natural Extraneous Variation Analysis Field Experiments. Journal Agricultural, Biological, Environmental Statistics, 2, 269 - 293.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/spl2Dc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Two-dimensional penalised tensor-product of marginal B-Spline basis. — spl2Dc","text":"","code":"## ============================ ## ## example to use spl2Dc()  ## ============================ ##  data(DT_cpdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # A <- A.mat(GT) # Ai <- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class=\"dgCMatrix\") # mix <- mmec(Yield~1, #             random=~vsc(isc(id), Gu=Ai) + #               Rowf + Colf + #               spl2Dc(Row,Col), #             rcov=~units, #             data=DT) # summary(mix)$varcomp ## ============================ ## ## mimic 2 fields ## ============================ ##  # aa <- DT; bb <- DT # aa$FIELD <- \"A\";bb$FIELD <- \"B\" # set.seed(1234) # aa$Yield <- aa$Yield + rnorm(length(aa$Yield),0,4) # DT2 <- rbind(aa,bb) # head(DT2) # mix <- mmec(Yield~1, #             random=~vsc(dsc(FIELD),isc(id), Gu=Ai) + #               vsc(dsc(FIELD),isc(Rowf)) + #               vsc(dsc(FIELD),isc(Colf)) + #                 spl2Dc(Row,Col,at.var=FIELD), #             rcov=~vsc(dsc(FIELD),isc(units)), #             data=DT2)"},{"path":"https://github.com/covaruber/sommer/reference/spl2Dmats.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Tensor Product Spline Mixed Model Incidence Matrices — spl2Dmats","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — spl2Dmats","text":"spl2Dmats gets Tensor-Product P-Spline Mixed Model Incidence Matrices     use sommer main function mmer. thank Sue Welham making TPSbits package available community. using function research please cite TPSbits package :) mostly wrapper tpsmmb function enable use sommer.","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Dmats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — spl2Dmats","text":"","code":"spl2Dmats(   x.coord.name,   y.coord.name,   data,   at.name,   at.levels,    nsegments=NULL,   minbound=NULL,   maxbound=NULL,   degree = c(3, 3),   penaltyord = c(2,2),    nestorder = c(1,1),   method = \"Lee\" )"},{"path":"https://github.com/covaruber/sommer/reference/spl2Dmats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — spl2Dmats","text":"x.coord.name string. Gives name data element holding column locations. y.coord.name string. Gives name data element holding row locations. data dataframe. Holds dataset used fitting. .name name variable defining 2D spline matrices created different units (e.g., different environments). .levels vector names indicating levels .name variable used fitting 2D spline function. nsegments list length 2. Number segments split column row ranges , respectively (= number internal knots + 1). one number specified, value used dimensions. specified, (number unique values - 1) used dimension; grid layout (equal spacing) gives knot data value. minbound list length 2. lower bound used column row dimensions respectively; default calculated minimum value dimension. maxbound list length 2. upper bound used column row dimensions respectively; default calculated maximum value dimension. degree list length 2. degree polynomial spline used column row dimensions respectively; default=3. penaltyord list length 2. order differencing column row dimensions, respectively; default=2. nestorder list length 2. order nesting column row dimensions, respectively; default=1 (nesting). value 2 generates spline half number segments dimension, etc. number segments direction must multiple order nesting. method string. Method forming  penalty; default=\"Lee\" ie penalty Lee, Durban & Eilers (2013, CSDA 61, 22-37). alternative method \"Wood\" ie. method Wood et al (2012, Stat Comp 23, 341-360). option research tool requires investigation.","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Dmats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — spl2Dmats","text":"List length 7 elements: data = input data frame augmented structures required     fit tensor product splines asreml-R. data frame can used     fit TPS model. Added columns: TP.col, TP.row = column row coordinates TP.CxR = combined index use smooth x smooth term TP.C.n n=1:(diff.c) = X parts column spline use     random model (diff.c order column differencing) TP.R.n n=1:(diff.r) = X parts row spline use     random model (diff.r order row differencing) TP.CR.n n=1:((diff.c*diff.r)) = interaction     two X parts use fixed model. first variate     constant term omitted model constant     (1) present. elements     included model constant term omitted,     eg. y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + terms... asreml=\"grp\" \"sepgrp\", spline basis     functions also added data frame. Column numbers     term given grp list structure. fR = Xr1:Zc fC = Xr2:Zc fR.C = Zr:Xc1 R.fC = Zr:Xc2 fR.fC = Zc:Zr = Xr1:Zc | Xr2:Zc | Zr:Xc1 | Zr:Xc2 | Zc:Zr","code":""},{"path":"https://github.com/covaruber/sommer/reference/spl2Dmats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — spl2Dmats","text":"","code":"data(\"DT_cpdata\") DT <- DT_cpdata GT <- GT_cpdata MP <- MP_cpdata #### create the variance-covariance matrix A <- A.mat(GT) # additive relationship matrix  M <- spl2Dmats(x.coord.name = \"Col\", y.coord.name = \"Row\", data=DT, nseg =c(14,21)) head(M$data) #>               id Row Col Year      color  Yield FruitAver Firmness Rowf Colf #> FIELD1.P003 P003   3   1 2014 0.10075269 154.67     41.93  588.917    3    1 #> FIELD1.P004 P004   4   1 2014 0.13891940 186.77     58.79  640.031    4    1 #> FIELD1.P005 P005   5   1 2014 0.08681502  80.21     48.16  671.523    5    1 #> FIELD1.P006 P006   6   1 2014 0.13408561 202.96     48.24  687.172    6    1 #> FIELD1.P007 P007   7   1 2014 0.13519278 174.74     45.83  601.322    7    1 #> FIELD1.P008 P008   8   1 2014 0.17406685 194.16     44.63  656.379    8    1 #>             FIELDINST TP.col TP.row TP.CxR    TP.C.1     TP.C.2    TP.R.1 #> FIELD1.P003    FIELD1      1      3    103 0.2425356 -0.3465516 0.2041241 #> FIELD1.P004    FIELD1      1      4    104 0.2425356 -0.3465516 0.2041241 #> FIELD1.P005    FIELD1      1      5    105 0.2425356 -0.3465516 0.2041241 #> FIELD1.P006    FIELD1      1      6    106 0.2425356 -0.3465516 0.2041241 #> FIELD1.P007    FIELD1      1      7    107 0.2425356 -0.3465516 0.2041241 #> FIELD1.P008    FIELD1      1      8    108 0.2425356 -0.3465516 0.2041241 #>                    TP.R.2    TP.CR.1       TP.CR.2     TP.CR.3       TP.CR.4 #> FIELD1.P003 -2.064187e-01 0.04950738 -5.006390e-02 -0.07073956  7.153475e-02 #> FIELD1.P004 -1.548141e-01 0.04950738 -3.754792e-02 -0.07073956  5.365106e-02 #> FIELD1.P005 -1.032094e-01 0.04950738 -2.503195e-02 -0.07073956  3.576738e-02 #> FIELD1.P006 -5.160468e-02 0.04950738 -1.251597e-02 -0.07073956  1.788369e-02 #> FIELD1.P007 -1.343925e-13 0.04950738 -3.259497e-14 -0.07073956  4.657394e-14 #> FIELD1.P008  5.160468e-02 0.04950738  1.251597e-02 -0.07073956 -1.788369e-02 # m1g <- mmer(Yield~1+TP.CR.2+TP.CR.3+TP.CR.4, #             random=~Rowf+Colf+vsr(M$fC)+vsr(M$fR)+ #               vsr(M$fC.R)+vsr(M$C.fR)+vsr(M$fC.fR)+ #               vsr(id,Gu=A), #             data=M$data, tolpar = 1e-6, #             iters=30) #  # summary(m1g)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/stackTrait.html","id":null,"dir":"Reference","previous_headings":"","what":"Stacking traits in a dataset — stackTrait","title":"Stacking traits in a dataset — stackTrait","text":"stackTrait creates dataset stacking traits long format used mmec solver multi-trait models.","code":""},{"path":"https://github.com/covaruber/sommer/reference/stackTrait.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stacking traits in a dataset — stackTrait","text":"","code":"stackTrait(data, traits)"},{"path":"https://github.com/covaruber/sommer/reference/stackTrait.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stacking traits in a dataset — stackTrait","text":"data data frame traits wide format. traits variable names corresponding traits long format.","code":""},{"path":"https://github.com/covaruber/sommer/reference/stackTrait.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stacking traits in a dataset — stackTrait","text":"$res data frame traits long format.","code":""},{"path":"https://github.com/covaruber/sommer/reference/stackTrait.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Stacking traits in a dataset — stackTrait","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/stackTrait.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Stacking traits in a dataset — stackTrait","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/stackTrait.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stacking traits in a dataset — stackTrait","text":"","code":"data(DT_example) DT <- DT_example A <- A_example head(DT) #>                   Name     Env Loc Year     Block Yield    Weight #> 33  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.1     4 -1.904711 #> 65          CO02024-9W CA.2013  CA 2013 CA.2013.1     5 -1.446958 #> 66  Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.2     5 -1.516271 #> 67            MSL007-B CA.2011  CA 2011 CA.2011.2     5 -1.435510 #> 68           MSR169-8Y CA.2013  CA 2013 CA.2013.1     5 -1.469051 #> 103         AC05153-1W CA.2013  CA 2013 CA.2013.1     6 -1.307167  DT2 <- stackTrait(DT, traits = c(\"Yield\",\"Weight\")) head(DT2) #> $long #>                     Name     Env Loc Year     Block  trait        value #> 1     Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.1  Yield  4.000000000 #> 2             CO02024-9W CA.2013  CA 2013 CA.2013.1  Yield  5.000000000 #> 3     Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.2  Yield  5.000000000 #> 4               MSL007-B CA.2011  CA 2011 CA.2011.2  Yield  5.000000000 #> 5              MSR169-8Y CA.2013  CA 2013 CA.2013.1  Yield  5.000000000 #> 6             AC05153-1W CA.2013  CA 2013 CA.2013.1  Yield  6.000000000 #> 7               AF4157-6 CA.2012  CA 2012 CA.2012.2  Yield  6.000000000 #> 8               MSL007-B CA.2011  CA 2011 CA.2011.1  Yield  6.000000000 #> 9              MSR128-4Y CA.2012  CA 2012 CA.2012.1  Yield  6.000000000 #> 10        NY153(NYH25-4) CA.2012  CA 2012 CA.2012.2  Yield  6.000000000 #> 11        NY153(NYH25-4) CA.2012  CA 2012 CA.2012.1  Yield  6.000000000 #> 12               W8822-1 CA.2013  CA 2013 CA.2013.1  Yield  6.000000000 #> 13            AC05153-1W CA.2013  CA 2013 CA.2013.2  Yield  7.000000000 #> 14            CO02024-9W CA.2013  CA 2013 CA.2013.2  Yield  7.000000000 #> 15            CO05061-6W CA.2013  CA 2013 CA.2013.1  Yield  7.000000000 #> 16              MSK061-4 CA.2012  CA 2012 CA.2012.1  Yield  7.000000000 #> 17              MSL007-B CA.2013  CA 2013 CA.2013.2  Yield  7.000000000 #> 18              MSL007-B CA.2013  CA 2013 CA.2013.1  Yield  7.000000000 #> 19              MSM246-B CA.2013  CA 2013 CA.2013.2  Yield  7.000000000 #> 20              MSM246-B CA.2013  CA 2013 CA.2013.1  Yield  7.000000000 #> 21              MSR058-1 CA.2012  CA 2012 CA.2012.1  Yield  7.000000000 #> 22              MSR127-2 CA.2012  CA 2012 CA.2012.2  Yield  7.000000000 #> 23             MSR128-4Y CA.2013  CA 2013 CA.2013.1  Yield  7.000000000 #> 24             MSR169-8Y CA.2012  CA 2012 CA.2012.2  Yield  7.000000000 #> 25             MSR169-8Y CA.2013  CA 2013 CA.2013.2  Yield  7.000000000 #> 26        NY153(NYH25-4) CA.2013  CA 2013 CA.2013.1  Yield  7.000000000 #> 27               W8822-1 CA.2013  CA 2013 CA.2013.2  Yield  7.000000000 #> 28               W8822-2 CA.2013  CA 2013 CA.2013.2  Yield  7.000000000 #> 29               W8867-5 CA.2012  CA 2012 CA.2012.2  Yield  7.000000000 #> 30               W8867-5 CA.2012  CA 2012 CA.2012.1  Yield  7.000000000 #> 31             A01143-3C CA.2012  CA 2012 CA.2012.1  Yield  8.000000000 #> 32            AC00206-2W CA.2013  CA 2013 CA.2013.2  Yield  8.000000000 #> 33            AC03433-1W CA.2013  CA 2013 CA.2013.1  Yield  8.000000000 #> 34            AC05153-1W CA.2012  CA 2012 CA.2012.2  Yield  8.000000000 #> 35              AF4157-6 CA.2012  CA 2012 CA.2012.1  Yield  8.000000000 #> 36              AF4157-6 CA.2013  CA 2013 CA.2013.2  Yield  8.000000000 #> 37              AF4157-6 CA.2013  CA 2013 CA.2013.1  Yield  8.000000000 #> 38              AF4648-2 CA.2012  CA 2012 CA.2012.2  Yield  8.000000000 #> 39              AF4648-2 CA.2012  CA 2012 CA.2012.1  Yield  8.000000000 #> 40            CO05061-2P CA.2012  CA 2012 CA.2012.1  Yield  8.000000000 #> 41            CO05061-6W CA.2013  CA 2013 CA.2013.2  Yield  8.000000000 #> 42    Manistee(MSL292-A) CA.2012  CA 2012 CA.2012.2  Yield  8.000000000 #> 43    Manistee(MSL292-A) CA.2012  CA 2012 CA.2012.1  Yield  8.000000000 #> 44              MSR057-4 CA.2013  CA 2013 CA.2013.2  Yield  8.000000000 #> 45              MSR058-1 CA.2012  CA 2012 CA.2012.2  Yield  8.000000000 #> 46             MSR128-4Y CA.2012  CA 2012 CA.2012.2  Yield  8.000000000 #> 47             MSR128-4Y CA.2013  CA 2013 CA.2013.2  Yield  8.000000000 #> 48             MSR157-1Y CA.2012  CA 2012 CA.2012.1  Yield  8.000000000 #> 49            AC01151-5W CA.2012  CA 2012 CA.2012.2  Yield  9.000000000 #> 50            AC03433-1W CA.2013  CA 2013 CA.2013.2  Yield  9.000000000 #> 51            AC05153-1W CA.2012  CA 2012 CA.2012.1  Yield  9.000000000 #> 52  Accumulator(W2324-1) CA.2013  CA 2013 CA.2013.1  Yield  9.000000000 #> 53              MSK061-4 CA.2011  CA 2011 CA.2011.2  Yield  9.000000000 #> 54              MSK061-4 CA.2012  CA 2012 CA.2012.2  Yield  9.000000000 #> 55              MSK061-4 CA.2013  CA 2013 CA.2013.1  Yield  9.000000000 #> 56              MSL007-B CA.2012  CA 2012 CA.2012.2  Yield  9.000000000 #> 57              MSL007-B CA.2012  CA 2012 CA.2012.1  Yield  9.000000000 #> 58              MSQ086-3 CA.2013  CA 2013 CA.2013.2  Yield  9.000000000 #> 59              MSQ086-3 CA.2013  CA 2013 CA.2013.1  Yield  9.000000000 #> 60              MSR057-4 CA.2013  CA 2013 CA.2013.1  Yield  9.000000000 #> 61             MSR157-1Y CA.2012  CA 2012 CA.2012.2  Yield  9.000000000 #> 62             MSS165-2Y CA.2012  CA 2012 CA.2012.1  Yield  9.000000000 #> 63                 NY148 CA.2012  CA 2012 CA.2012.1  Yield  9.000000000 #> 64              W8539-2Y CA.2012  CA 2012 CA.2012.2  Yield  9.000000000 #> 65               W8822-2 CA.2013  CA 2013 CA.2013.1  Yield  9.000000000 #> 66               W8822-3 CA.2012  CA 2012 CA.2012.1  Yield  9.000000000 #> 67               W8822-3 CA.2013  CA 2013 CA.2013.2  Yield  9.000000000 #> 68               W8867-7 CA.2013  CA 2013 CA.2013.1  Yield  9.000000000 #> 69            AC00206-2W CA.2012  CA 2012 CA.2012.1  Yield 10.000000000 #> 70            AC01151-5W CA.2012  CA 2012 CA.2012.1  Yield 10.000000000 #> 71            AC03433-1W CA.2012  CA 2012 CA.2012.1  Yield 10.000000000 #> 72              Atlantic CA.2012  CA 2012 CA.2012.1  Yield 10.000000000 #> 73            CO02033-1W CA.2012  CA 2012 CA.2012.2  Yield 10.000000000 #> 74            CO02033-1W CA.2013  CA 2013 CA.2013.1  Yield 10.000000000 #> 75            CO05061-2P CA.2012  CA 2012 CA.2012.2  Yield 10.000000000 #> 76            CO05061-6W CA.2012  CA 2012 CA.2012.1  Yield 10.000000000 #> 77              MSK061-4 CA.2011  CA 2011 CA.2011.1  Yield 10.000000000 #> 78              MSR058-1 CA.2013  CA 2013 CA.2013.2  Yield 10.000000000 #> 79              MSR058-1 CA.2013  CA 2013 CA.2013.1  Yield 10.000000000 #> 80             MSR169-8Y CA.2012  CA 2012 CA.2012.1  Yield 10.000000000 #> 81        NY153(NYH25-4) CA.2013  CA 2013 CA.2013.2  Yield 10.000000000 #> 82               W8615-5 CA.2012  CA 2012 CA.2012.1  Yield 10.000000000 #> 83               W8867-7 CA.2012  CA 2012 CA.2012.1  Yield 10.000000000 #> 84             A01143-3C CA.2012  CA 2012 CA.2012.2  Yield 11.000000000 #> 85            AC00206-2W CA.2012  CA 2012 CA.2012.2  Yield 11.000000000 #> 86            AC00206-2W CA.2013  CA 2013 CA.2013.1  Yield 11.000000000 #> 87            AC03433-1W CA.2012  CA 2012 CA.2012.2  Yield 11.000000000 #> 88            AC03452-2W CA.2013  CA 2013 CA.2013.2  Yield 11.000000000 #> 89              Atlantic CA.2012  CA 2012 CA.2012.2  Yield 11.000000000 #> 90              Atlantic CA.2013  CA 2013 CA.2013.2  Yield 11.000000000 #> 91            CO02024-9W CA.2012  CA 2012 CA.2012.2  Yield 11.000000000 #> 92            CO02024-9W CA.2012  CA 2012 CA.2012.1  Yield 11.000000000 #> 93            CO02033-1W CA.2012  CA 2012 CA.2012.1  Yield 11.000000000 #> 94            CO02033-1W CA.2013  CA 2013 CA.2013.2  Yield 11.000000000 #> 95              MSQ089-1 CA.2012  CA 2012 CA.2012.2  Yield 11.000000000 #> 96              MSQ089-1 CA.2013  CA 2013 CA.2013.2  Yield 11.000000000 #> 97              MSR127-2 CA.2013  CA 2013 CA.2013.1  Yield 11.000000000 #> 98             MSR169-8Y CA.2011  CA 2011 CA.2011.1  Yield 11.000000000 #> 99             MSS165-2Y CA.2012  CA 2012 CA.2012.2  Yield 11.000000000 #> 100                NY148 CA.2011  CA 2011 CA.2011.1  Yield 11.000000000 #> 101              W8822-1 CA.2012  CA 2012 CA.2012.2  Yield 11.000000000 #> 102              W8822-3 CA.2013  CA 2013 CA.2013.1  Yield 11.000000000 #> 103              W8867-5 CA.2013  CA 2013 CA.2013.1  Yield 11.000000000 #> 104              W8867-7 CA.2013  CA 2013 CA.2013.2  Yield 11.000000000 #> 105             AF4648-2 CA.2013  CA 2013 CA.2013.1  Yield 12.000000000 #> 106           CO05061-6W CA.2012  CA 2012 CA.2012.2  Yield 12.000000000 #> 107             MSK061-4 CA.2013  CA 2013 CA.2013.2  Yield 12.000000000 #> 108             MSQ086-3 CA.2012  CA 2012 CA.2012.2  Yield 12.000000000 #> 109             MSQ089-1 CA.2012  CA 2012 CA.2012.1  Yield 12.000000000 #> 110             MSR148-4 CA.2012  CA 2012 CA.2012.1  Yield 12.000000000 #> 111            MSR157-1Y CA.2013  CA 2013 CA.2013.1  Yield 12.000000000 #> 112            MSR169-8Y CA.2011  CA 2011 CA.2011.2  Yield 12.000000000 #> 113                NY148 CA.2012  CA 2012 CA.2012.2  Yield 12.000000000 #> 114       NY152(NYH15-5) CA.2012  CA 2012 CA.2012.2  Yield 12.000000000 #> 115       NY152(NYH15-5) CA.2012  CA 2012 CA.2012.1  Yield 12.000000000 #> 116              Snowden CA.2013  CA 2013 CA.2013.2  Yield 12.000000000 #> 117             W8539-2Y CA.2012  CA 2012 CA.2012.1  Yield 12.000000000 #> 118              W8867-7 CA.2012  CA 2012 CA.2012.2  Yield 12.000000000 #> 119           AC03433-1W CA.2011  CA 2011 CA.2011.2  Yield 13.000000000 #> 120             AF4157-6 CA.2011  CA 2011 CA.2011.1  Yield 13.000000000 #> 121             Atlantic CA.2013  CA 2013 CA.2013.1  Yield 13.000000000 #> 122           CO00270-7W CA.2012  CA 2012 CA.2012.1  Yield 13.000000000 #> 123             MSM246-B CA.2011  CA 2011 CA.2011.1  Yield 13.000000000 #> 124             MSM246-B CA.2012  CA 2012 CA.2012.2  Yield 13.000000000 #> 125             MSM246-B CA.2012  CA 2012 CA.2012.1  Yield 13.000000000 #> 126             MSQ086-3 CA.2012  CA 2012 CA.2012.1  Yield 13.000000000 #> 127             MSR057-4 CA.2012  CA 2012 CA.2012.2  Yield 13.000000000 #> 128             MSR057-4 CA.2012  CA 2012 CA.2012.1  Yield 13.000000000 #> 129             MSR127-2 CA.2013  CA 2013 CA.2013.2  Yield 13.000000000 #> 130              Snowden CA.2013  CA 2013 CA.2013.1  Yield 13.000000000 #> 131              W8822-3 CA.2012  CA 2012 CA.2012.2  Yield 13.000000000 #> 132              W8867-5 CA.2013  CA 2013 CA.2013.2  Yield 13.000000000 #> 133           AC03433-1W CA.2011  CA 2011 CA.2011.1  Yield 14.000000000 #> 134           AC03452-2W CA.2012  CA 2012 CA.2012.2  Yield 14.000000000 #> 135           AC03452-2W CA.2012  CA 2012 CA.2012.1  Yield 14.000000000 #> 136           AC03452-2W CA.2013  CA 2013 CA.2013.1  Yield 14.000000000 #> 137             AF4648-2 CA.2013  CA 2013 CA.2013.2  Yield 14.000000000 #> 138             MSQ089-1 CA.2013  CA 2013 CA.2013.1  Yield 14.000000000 #> 139             MSR148-4 CA.2012  CA 2012 CA.2012.2  Yield 14.000000000 #> 140       NY152(NYH15-5) CA.2013  CA 2013 CA.2013.2  Yield 14.000000000 #> 141              W8603-1 CA.2013  CA 2013 CA.2013.1  Yield 14.000000000 #> 142              W8822-1 CA.2012  CA 2012 CA.2012.1  Yield 14.000000000 #> 143 Accumulator(W2324-1) CA.2013  CA 2013 CA.2013.2  Yield 15.000000000 #> 144             Atlantic CA.2011  CA 2011 CA.2011.2  Yield 15.000000000 #> 145             Atlantic CA.2011  CA 2011 CA.2011.1  Yield 15.000000000 #> 146           CO00270-7W CA.2012  CA 2012 CA.2012.2  Yield 15.000000000 #> 147             MSR058-1 CA.2011  CA 2011 CA.2011.1  Yield 15.000000000 #> 148            MSR128-4Y CA.2011  CA 2011 CA.2011.1  Yield 15.000000000 #> 149                NY148 CA.2011  CA 2011 CA.2011.2  Yield 15.000000000 #> 150       NY152(NYH15-5) CA.2013  CA 2013 CA.2013.1  Yield 15.000000000 #> 151              W8603-1 CA.2013  CA 2013 CA.2013.2  Yield 15.000000000 #> 152 Accumulator(W2324-1) CA.2012  CA 2012 CA.2012.2  Yield 16.000000000 #> 153             MSQ089-1 CA.2011  CA 2011 CA.2011.1  Yield 16.000000000 #> 154             MSR058-1 CA.2011  CA 2011 CA.2011.2  Yield 16.000000000 #> 155             MSR127-2 CA.2012  CA 2012 CA.2012.1  Yield 16.000000000 #> 156              W8603-1 CA.2011  CA 2011 CA.2011.2  Yield 16.000000000 #> 157            A01143-3C CA.2013  CA 2013 CA.2013.2  Yield 17.000000000 #> 158             AF4157-6 CA.2011  CA 2011 CA.2011.2  Yield 17.000000000 #> 159           CO02024-9W CA.2011  CA 2011 CA.2011.1  Yield 17.000000000 #> 160             MSR148-4 CA.2011  CA 2011 CA.2011.2  Yield 17.000000000 #> 161             W8539-2Y CA.2011  CA 2011 CA.2011.2  Yield 17.000000000 #> 162              W8615-5 CA.2011  CA 2011 CA.2011.2  Yield 17.000000000 #> 163           AC01151-5W CA.2011  CA 2011 CA.2011.2  Yield 18.000000000 #> 164 Accumulator(W2324-1) CA.2012  CA 2012 CA.2012.1  Yield 18.000000000 #> 165           CO02024-9W CA.2011  CA 2011 CA.2011.2  Yield 18.000000000 #> 166             MSM246-B CA.2011  CA 2011 CA.2011.2  Yield 18.000000000 #> 167              W8603-1 CA.2011  CA 2011 CA.2011.1  Yield 18.000000000 #> 168              W8822-2 CA.2012  CA 2012 CA.2012.1  Yield 18.000000000 #> 169           CO00270-7W CA.2011  CA 2011 CA.2011.2  Yield 19.000000000 #> 170           CO00270-7W CA.2011  CA 2011 CA.2011.1  Yield 19.000000000 #> 171             MSQ089-1 CA.2011  CA 2011 CA.2011.2  Yield 19.000000000 #> 172            MSS165-2Y CA.2011  CA 2011 CA.2011.2  Yield 19.000000000 #> 173             W8539-2Y CA.2011  CA 2011 CA.2011.1  Yield 19.000000000 #> 174             MSR127-2 CA.2011  CA 2011 CA.2011.2  Yield 20.000000000 #> 175            MSS165-2Y CA.2011  CA 2011 CA.2011.1  Yield 20.000000000 #> 176             MSR127-2 CA.2011  CA 2011 CA.2011.1  Yield 21.000000000 #> 177              W8615-5 CA.2011  CA 2011 CA.2011.1  Yield 21.000000000 #> 178            A01143-3C CA.2011  CA 2011 CA.2011.1  Yield 22.000000000 #> 179 Accumulator(W2324-1) CA.2011  CA 2011 CA.2011.1  Yield 22.000000000 #> 180            A01143-3C CA.2011  CA 2011 CA.2011.2  Yield 23.000000000 #> 181            A01143-3C CA.2013  CA 2013 CA.2013.1  Yield 23.000000000 #> 182           AC01151-5W CA.2011  CA 2011 CA.2011.1  Yield 23.000000000 #> 183             MSR148-4 CA.2011  CA 2011 CA.2011.1  Yield 23.000000000 #> 184              W8615-5 CA.2012  CA 2012 CA.2012.2  Yield 25.000000000 #> 185 Accumulator(W2324-1) CA.2011  CA 2011 CA.2011.2  Yield 29.000000000 #> 186   Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.1 Weight -1.904710944 #> 187           CO02024-9W CA.2013  CA 2013 CA.2013.1 Weight -1.446958222 #> 188   Manistee(MSL292-A) CA.2013  CA 2013 CA.2013.2 Weight -1.516271359 #> 189             MSL007-B CA.2011  CA 2011 CA.2011.2 Weight -1.435510310 #> 190            MSR169-8Y CA.2013  CA 2013 CA.2013.1 Weight -1.469051308 #> 191           AC05153-1W CA.2013  CA 2013 CA.2013.1 Weight -1.307167384 #> 192             AF4157-6 CA.2012  CA 2012 CA.2012.2 Weight -1.252885127 #> 193             MSL007-B CA.2011  CA 2011 CA.2011.1 Weight -1.438962493 #> 194            MSR128-4Y CA.2012  CA 2012 CA.2012.1 Weight -1.362001169 #> 195       NY153(NYH25-4) CA.2012  CA 2012 CA.2012.2 Weight -1.180293079 #> 196       NY153(NYH25-4) CA.2012  CA 2012 CA.2012.1 Weight -0.686940586 #> 197              W8822-1 CA.2013  CA 2013 CA.2013.1 Weight -0.972147457 #> 198           AC05153-1W CA.2013  CA 2013 CA.2013.2 Weight -1.076444843 #> 199           CO02024-9W CA.2013  CA 2013 CA.2013.2 Weight -1.159478980 #> 200           CO05061-6W CA.2013  CA 2013 CA.2013.1 Weight -1.188148689 #> 201             MSK061-4 CA.2012  CA 2012 CA.2012.1 Weight -1.246607923 #> 202             MSL007-B CA.2013  CA 2013 CA.2013.2 Weight -1.145567730 #> 203             MSL007-B CA.2013  CA 2013 CA.2013.1 Weight -0.819852994 #> 204             MSM246-B CA.2013  CA 2013 CA.2013.2 Weight -1.251570337 #> 205             MSM246-B CA.2013  CA 2013 CA.2013.1 Weight -1.219755634 #> 206             MSR058-1 CA.2012  CA 2012 CA.2012.1 Weight -1.017792171 #> 207             MSR127-2 CA.2012  CA 2012 CA.2012.2 Weight -0.671175400 #> 208            MSR128-4Y CA.2013  CA 2013 CA.2013.1 Weight -1.111328466 #> 209            MSR169-8Y CA.2012  CA 2012 CA.2012.2 Weight -1.283317496 #> 210            MSR169-8Y CA.2013  CA 2013 CA.2013.2 Weight -1.020208579 #> 211       NY153(NYH25-4) CA.2013  CA 2013 CA.2013.1 Weight -1.081052481 #> 212              W8822-1 CA.2013  CA 2013 CA.2013.2 Weight -0.867852941 #> 213              W8822-2 CA.2013  CA 2013 CA.2013.2 Weight -1.234828942 #> 214              W8867-5 CA.2012  CA 2012 CA.2012.2 Weight -0.429062666 #> 215              W8867-5 CA.2012  CA 2012 CA.2012.1 Weight -1.195027706 #> 216            A01143-3C CA.2012  CA 2012 CA.2012.1 Weight -0.589984373 #> 217           AC00206-2W CA.2013  CA 2013 CA.2013.2 Weight -0.323892485 #> 218           AC03433-1W CA.2013  CA 2013 CA.2013.1 Weight -1.226764427 #> 219           AC05153-1W CA.2012  CA 2012 CA.2012.2 Weight -0.655897507 #> 220             AF4157-6 CA.2012  CA 2012 CA.2012.1 Weight -0.587283518 #> 221             AF4157-6 CA.2013  CA 2013 CA.2013.2 Weight -0.636425366 #> 222             AF4157-6 CA.2013  CA 2013 CA.2013.1 Weight -0.879965476 #> 223             AF4648-2 CA.2012  CA 2012 CA.2012.2 Weight -0.448960197 #> 224             AF4648-2 CA.2012  CA 2012 CA.2012.1 Weight -0.659728628 #> 225           CO05061-2P CA.2012  CA 2012 CA.2012.1 Weight -0.958733815 #> 226           CO05061-6W CA.2013  CA 2013 CA.2013.2 Weight -0.122812023 #> 227   Manistee(MSL292-A) CA.2012  CA 2012 CA.2012.2 Weight -1.043605282 #> 228   Manistee(MSL292-A) CA.2012  CA 2012 CA.2012.1 Weight -0.828186933 #> 229             MSR057-4 CA.2013  CA 2013 CA.2013.2 Weight -0.854903222 #> 230             MSR058-1 CA.2012  CA 2012 CA.2012.2 Weight -0.318770439 #> 231            MSR128-4Y CA.2012  CA 2012 CA.2012.2 Weight -0.488842618 #> 232            MSR128-4Y CA.2013  CA 2013 CA.2013.2 Weight -0.735799397 #> 233            MSR157-1Y CA.2012  CA 2012 CA.2012.1 Weight -0.865993142 #> 234           AC01151-5W CA.2012  CA 2012 CA.2012.2 Weight -0.628242662 #> 235           AC03433-1W CA.2013  CA 2013 CA.2013.2 Weight -0.936532122 #> 236           AC05153-1W CA.2012  CA 2012 CA.2012.1 Weight -0.594419352 #> 237 Accumulator(W2324-1) CA.2013  CA 2013 CA.2013.1 Weight -0.247575971 #> 238             MSK061-4 CA.2011  CA 2011 CA.2011.2 Weight -0.798393744 #> 239             MSK061-4 CA.2012  CA 2012 CA.2012.2 Weight -0.788407168 #> 240             MSK061-4 CA.2013  CA 2013 CA.2013.1 Weight -0.705221520 #> 241             MSL007-B CA.2012  CA 2012 CA.2012.2 Weight -0.348264860 #> 242             MSL007-B CA.2012  CA 2012 CA.2012.1 Weight -0.338483315 #> 243             MSQ086-3 CA.2013  CA 2013 CA.2013.2 Weight -0.755715811 #> 244             MSQ086-3 CA.2013  CA 2013 CA.2013.1 Weight -0.752285772 #> 245             MSR057-4 CA.2013  CA 2013 CA.2013.1 Weight -0.735646645 #> 246            MSR157-1Y CA.2012  CA 2012 CA.2012.2 Weight -0.842713637 #> 247            MSS165-2Y CA.2012  CA 2012 CA.2012.1 Weight -0.697167716 #> 248                NY148 CA.2012  CA 2012 CA.2012.1 Weight -0.955954922 #> 249             W8539-2Y CA.2012  CA 2012 CA.2012.2 Weight -0.634630752 #> 250              W8822-2 CA.2013  CA 2013 CA.2013.1 Weight -1.031659120 #> 251              W8822-3 CA.2012  CA 2012 CA.2012.1 Weight -0.522481207 #> 252              W8822-3 CA.2013  CA 2013 CA.2013.2 Weight -1.062704793 #> 253              W8867-7 CA.2013  CA 2013 CA.2013.1 Weight -0.746255681 #> 254           AC00206-2W CA.2012  CA 2012 CA.2012.1 Weight -0.546320423 #> 255           AC01151-5W CA.2012  CA 2012 CA.2012.1 Weight -0.116574612 #> 256           AC03433-1W CA.2012  CA 2012 CA.2012.1 Weight -0.671755443 #> 257             Atlantic CA.2012  CA 2012 CA.2012.1 Weight -0.338181708 #> 258           CO02033-1W CA.2012  CA 2012 CA.2012.2 Weight -0.412168564 #> 259           CO02033-1W CA.2013  CA 2013 CA.2013.1 Weight -0.495521488 #> 260           CO05061-2P CA.2012  CA 2012 CA.2012.2 Weight -0.057343421 #> 261           CO05061-6W CA.2012  CA 2012 CA.2012.1 Weight -0.248603108 #> 262             MSK061-4 CA.2011  CA 2011 CA.2011.1 Weight -0.190226553 #> 263             MSR058-1 CA.2013  CA 2013 CA.2013.2 Weight -0.538487643 #> 264             MSR058-1 CA.2013  CA 2013 CA.2013.1 Weight -0.264204088 #> 265            MSR169-8Y CA.2012  CA 2012 CA.2012.1 Weight -0.463717649 #> 266       NY153(NYH25-4) CA.2013  CA 2013 CA.2013.2 Weight -0.833799536 #> 267              W8615-5 CA.2012  CA 2012 CA.2012.1 Weight -0.103570522 #> 268              W8867-7 CA.2012  CA 2012 CA.2012.1 Weight -0.568484395 #> 269            A01143-3C CA.2012  CA 2012 CA.2012.2 Weight  0.098566285 #> 270           AC00206-2W CA.2012  CA 2012 CA.2012.2 Weight  0.066715229 #> 271           AC00206-2W CA.2013  CA 2013 CA.2013.1 Weight -0.524833610 #> 272           AC03433-1W CA.2012  CA 2012 CA.2012.2 Weight -0.325822019 #> 273           AC03452-2W CA.2013  CA 2013 CA.2013.2 Weight  0.011424613 #> 274             Atlantic CA.2012  CA 2012 CA.2012.2 Weight -0.219217660 #> 275             Atlantic CA.2013  CA 2013 CA.2013.2 Weight -0.039319589 #> 276           CO02024-9W CA.2012  CA 2012 CA.2012.2 Weight  0.003720692 #> 277           CO02024-9W CA.2012  CA 2012 CA.2012.1 Weight  0.022758094 #> 278           CO02033-1W CA.2012  CA 2012 CA.2012.1 Weight -0.202947472 #> 279           CO02033-1W CA.2013  CA 2013 CA.2013.2 Weight  0.061383574 #> 280             MSQ089-1 CA.2012  CA 2012 CA.2012.2 Weight -0.136667734 #> 281             MSQ089-1 CA.2013  CA 2013 CA.2013.2 Weight -0.231594448 #> 282             MSR127-2 CA.2013  CA 2013 CA.2013.1 Weight -0.136450583 #> 283            MSR169-8Y CA.2011  CA 2011 CA.2011.1 Weight  0.026820367 #> 284            MSS165-2Y CA.2012  CA 2012 CA.2012.2 Weight -0.013424286 #> 285                NY148 CA.2011  CA 2011 CA.2011.1 Weight -0.032782056 #> 286              W8822-1 CA.2012  CA 2012 CA.2012.2 Weight -0.362160719 #> 287              W8822-3 CA.2013  CA 2013 CA.2013.1 Weight -0.330839989 #> 288              W8867-5 CA.2013  CA 2013 CA.2013.1 Weight  0.018349694 #> 289              W8867-7 CA.2013  CA 2013 CA.2013.2 Weight -0.420701351 #> 290             AF4648-2 CA.2013  CA 2013 CA.2013.1 Weight  0.192229417 #> 291           CO05061-6W CA.2012  CA 2012 CA.2012.2 Weight  0.009404862 #> 292             MSK061-4 CA.2013  CA 2013 CA.2013.2 Weight  0.056437997 #> 293             MSQ086-3 CA.2012  CA 2012 CA.2012.2 Weight -0.248137458 #> 294             MSQ089-1 CA.2012  CA 2012 CA.2012.1 Weight  0.306390867 #> 295             MSR148-4 CA.2012  CA 2012 CA.2012.1 Weight  0.161373012 #> 296            MSR157-1Y CA.2013  CA 2013 CA.2013.1 Weight  0.011815822 #> 297            MSR169-8Y CA.2011  CA 2011 CA.2011.2 Weight  0.170630337 #> 298                NY148 CA.2012  CA 2012 CA.2012.2 Weight -0.374530775 #> 299       NY152(NYH15-5) CA.2012  CA 2012 CA.2012.2 Weight -0.116689464 #> 300       NY152(NYH15-5) CA.2012  CA 2012 CA.2012.1 Weight  0.234711307 #> 301              Snowden CA.2013  CA 2013 CA.2013.2 Weight  0.144312781 #> 302             W8539-2Y CA.2012  CA 2012 CA.2012.1 Weight -0.072281390 #> 303              W8867-7 CA.2012  CA 2012 CA.2012.2 Weight  0.139732621 #> 304           AC03433-1W CA.2011  CA 2011 CA.2011.2 Weight  0.052357810 #> 305             AF4157-6 CA.2011  CA 2011 CA.2011.1 Weight  0.152735425 #> 306             Atlantic CA.2013  CA 2013 CA.2013.1 Weight  0.233158452 #> 307           CO00270-7W CA.2012  CA 2012 CA.2012.1 Weight  0.295743756 #> 308             MSM246-B CA.2011  CA 2011 CA.2011.1 Weight  0.181131304 #> 309             MSM246-B CA.2012  CA 2012 CA.2012.2 Weight  0.014473805 #> 310             MSM246-B CA.2012  CA 2012 CA.2012.1 Weight -0.123372067 #> 311             MSQ086-3 CA.2012  CA 2012 CA.2012.1 Weight -0.195697581 #> 312             MSR057-4 CA.2012  CA 2012 CA.2012.2 Weight  0.078407572 #> 313             MSR057-4 CA.2012  CA 2012 CA.2012.1 Weight  0.306855809 #> 314             MSR127-2 CA.2013  CA 2013 CA.2013.2 Weight  0.095513681 #> 315              Snowden CA.2013  CA 2013 CA.2013.1 Weight  0.323058995 #> 316              W8822-3 CA.2012  CA 2012 CA.2012.2 Weight  0.300202359 #> 317              W8867-5 CA.2013  CA 2013 CA.2013.2 Weight  0.506922239 #> 318           AC03433-1W CA.2011  CA 2011 CA.2011.1 Weight  0.541638035 #> 319           AC03452-2W CA.2012  CA 2012 CA.2012.2 Weight  0.322587942 #> 320           AC03452-2W CA.2012  CA 2012 CA.2012.1 Weight  0.229329439 #> 321           AC03452-2W CA.2013  CA 2013 CA.2013.1 Weight  0.187346766 #> 322             AF4648-2 CA.2013  CA 2013 CA.2013.2 Weight  0.058886587 #> 323             MSQ089-1 CA.2013  CA 2013 CA.2013.1 Weight  0.452509051 #> 324             MSR148-4 CA.2012  CA 2012 CA.2012.2 Weight  0.733302892 #> 325       NY152(NYH15-5) CA.2013  CA 2013 CA.2013.2 Weight  0.830753384 #> 326              W8603-1 CA.2013  CA 2013 CA.2013.1 Weight  0.755462905 #> 327              W8822-1 CA.2012  CA 2012 CA.2012.1 Weight  0.188998663 #> 328 Accumulator(W2324-1) CA.2013  CA 2013 CA.2013.2 Weight  0.942897542 #> 329             Atlantic CA.2011  CA 2011 CA.2011.2 Weight  0.803957279 #> 330             Atlantic CA.2011  CA 2011 CA.2011.1 Weight  0.743956031 #> 331           CO00270-7W CA.2012  CA 2012 CA.2012.2 Weight  0.794595932 #> 332             MSR058-1 CA.2011  CA 2011 CA.2011.1 Weight  0.927006619 #> 333            MSR128-4Y CA.2011  CA 2011 CA.2011.1 Weight  0.742004197 #> 334                NY148 CA.2011  CA 2011 CA.2011.2 Weight  0.563513496 #> 335       NY152(NYH15-5) CA.2013  CA 2013 CA.2013.1 Weight  0.548594198 #> 336              W8603-1 CA.2013  CA 2013 CA.2013.2 Weight  0.662051979 #> 337 Accumulator(W2324-1) CA.2012  CA 2012 CA.2012.2 Weight  0.969064668 #> 338             MSQ089-1 CA.2011  CA 2011 CA.2011.1 Weight  1.075121195 #> 339             MSR058-1 CA.2011  CA 2011 CA.2011.2 Weight  1.057640874 #> 340             MSR127-2 CA.2012  CA 2012 CA.2012.1 Weight  1.156882774 #> 341              W8603-1 CA.2011  CA 2011 CA.2011.2 Weight  0.731064690 #> 342            A01143-3C CA.2013  CA 2013 CA.2013.2 Weight  1.445208429 #> 343             AF4157-6 CA.2011  CA 2011 CA.2011.2 Weight  1.089790016 #> 344           CO02024-9W CA.2011  CA 2011 CA.2011.1 Weight  1.275715985 #> 345             MSR148-4 CA.2011  CA 2011 CA.2011.2 Weight  1.299792377 #> 346             W8539-2Y CA.2011  CA 2011 CA.2011.2 Weight  0.900243680 #> 347              W8615-5 CA.2011  CA 2011 CA.2011.2 Weight  1.050795807 #> 348           AC01151-5W CA.2011  CA 2011 CA.2011.2 Weight  1.527842293 #> 349 Accumulator(W2324-1) CA.2012  CA 2012 CA.2012.1 Weight  1.436841076 #> 350           CO02024-9W CA.2011  CA 2011 CA.2011.2 Weight  1.167324315 #> 351             MSM246-B CA.2011  CA 2011 CA.2011.2 Weight  0.951697157 #> 352              W8603-1 CA.2011  CA 2011 CA.2011.1 Weight  1.370161990 #> 353              W8822-2 CA.2012  CA 2012 CA.2012.1 Weight  1.360552015 #> 354           CO00270-7W CA.2011  CA 2011 CA.2011.2 Weight  1.782248836 #> 355           CO00270-7W CA.2011  CA 2011 CA.2011.1 Weight  1.606139445 #> 356             MSQ089-1 CA.2011  CA 2011 CA.2011.2 Weight  1.528815926 #> 357            MSS165-2Y CA.2011  CA 2011 CA.2011.2 Weight  1.209406380 #> 358             W8539-2Y CA.2011  CA 2011 CA.2011.1 Weight  1.821267867 #> 359             MSR127-2 CA.2011  CA 2011 CA.2011.2 Weight  1.581805839 #> 360            MSS165-2Y CA.2011  CA 2011 CA.2011.1 Weight  1.538216948 #> 361             MSR127-2 CA.2011  CA 2011 CA.2011.1 Weight  2.192971226 #> 362              W8615-5 CA.2011  CA 2011 CA.2011.1 Weight  1.906572817 #> 363            A01143-3C CA.2011  CA 2011 CA.2011.1 Weight  2.633592864 #> 364 Accumulator(W2324-1) CA.2011  CA 2011 CA.2011.1 Weight  1.923875436 #> 365            A01143-3C CA.2011  CA 2011 CA.2011.2 Weight  2.307183443 #> 366            A01143-3C CA.2013  CA 2013 CA.2013.1 Weight  2.718682078 #> 367           AC01151-5W CA.2011  CA 2011 CA.2011.1 Weight  2.040620572 #> 368             MSR148-4 CA.2011  CA 2011 CA.2011.1 Weight  2.621263670 #> 369              W8615-5 CA.2012  CA 2012 CA.2012.2 Weight  3.101811011 #> 370 Accumulator(W2324-1) CA.2011  CA 2011 CA.2011.2 Weight  3.610763025 #>           valueS #> 1   -1.720715415 #> 2   -1.499497659 #> 3   -1.499497659 #> 4   -1.499497659 #> 5   -1.499497659 #> 6   -1.278279902 #> 7   -1.278279902 #> 8   -1.278279902 #> 9   -1.278279902 #> 10  -1.278279902 #> 11  -1.278279902 #> 12  -1.278279902 #> 13  -1.057062145 #> 14  -1.057062145 #> 15  -1.057062145 #> 16  -1.057062145 #> 17  -1.057062145 #> 18  -1.057062145 #> 19  -1.057062145 #> 20  -1.057062145 #> 21  -1.057062145 #> 22  -1.057062145 #> 23  -1.057062145 #> 24  -1.057062145 #> 25  -1.057062145 #> 26  -1.057062145 #> 27  -1.057062145 #> 28  -1.057062145 #> 29  -1.057062145 #> 30  -1.057062145 #> 31  -0.835844389 #> 32  -0.835844389 #> 33  -0.835844389 #> 34  -0.835844389 #> 35  -0.835844389 #> 36  -0.835844389 #> 37  -0.835844389 #> 38  -0.835844389 #> 39  -0.835844389 #> 40  -0.835844389 #> 41  -0.835844389 #> 42  -0.835844389 #> 43  -0.835844389 #> 44  -0.835844389 #> 45  -0.835844389 #> 46  -0.835844389 #> 47  -0.835844389 #> 48  -0.835844389 #> 49  -0.614626632 #> 50  -0.614626632 #> 51  -0.614626632 #> 52  -0.614626632 #> 53  -0.614626632 #> 54  -0.614626632 #> 55  -0.614626632 #> 56  -0.614626632 #> 57  -0.614626632 #> 58  -0.614626632 #> 59  -0.614626632 #> 60  -0.614626632 #> 61  -0.614626632 #> 62  -0.614626632 #> 63  -0.614626632 #> 64  -0.614626632 #> 65  -0.614626632 #> 66  -0.614626632 #> 67  -0.614626632 #> 68  -0.614626632 #> 69  -0.393408875 #> 70  -0.393408875 #> 71  -0.393408875 #> 72  -0.393408875 #> 73  -0.393408875 #> 74  -0.393408875 #> 75  -0.393408875 #> 76  -0.393408875 #> 77  -0.393408875 #> 78  -0.393408875 #> 79  -0.393408875 #> 80  -0.393408875 #> 81  -0.393408875 #> 82  -0.393408875 #> 83  -0.393408875 #> 84  -0.172191119 #> 85  -0.172191119 #> 86  -0.172191119 #> 87  -0.172191119 #> 88  -0.172191119 #> 89  -0.172191119 #> 90  -0.172191119 #> 91  -0.172191119 #> 92  -0.172191119 #> 93  -0.172191119 #> 94  -0.172191119 #> 95  -0.172191119 #> 96  -0.172191119 #> 97  -0.172191119 #> 98  -0.172191119 #> 99  -0.172191119 #> 100 -0.172191119 #> 101 -0.172191119 #> 102 -0.172191119 #> 103 -0.172191119 #> 104 -0.172191119 #> 105  0.049026638 #> 106  0.049026638 #> 107  0.049026638 #> 108  0.049026638 #> 109  0.049026638 #> 110  0.049026638 #> 111  0.049026638 #> 112  0.049026638 #> 113  0.049026638 #> 114  0.049026638 #> 115  0.049026638 #> 116  0.049026638 #> 117  0.049026638 #> 118  0.049026638 #> 119  0.270244395 #> 120  0.270244395 #> 121  0.270244395 #> 122  0.270244395 #> 123  0.270244395 #> 124  0.270244395 #> 125  0.270244395 #> 126  0.270244395 #> 127  0.270244395 #> 128  0.270244395 #> 129  0.270244395 #> 130  0.270244395 #> 131  0.270244395 #> 132  0.270244395 #> 133  0.491462151 #> 134  0.491462151 #> 135  0.491462151 #> 136  0.491462151 #> 137  0.491462151 #> 138  0.491462151 #> 139  0.491462151 #> 140  0.491462151 #> 141  0.491462151 #> 142  0.491462151 #> 143  0.712679908 #> 144  0.712679908 #> 145  0.712679908 #> 146  0.712679908 #> 147  0.712679908 #> 148  0.712679908 #> 149  0.712679908 #> 150  0.712679908 #> 151  0.712679908 #> 152  0.933897665 #> 153  0.933897665 #> 154  0.933897665 #> 155  0.933897665 #> 156  0.933897665 #> 157  1.155115421 #> 158  1.155115421 #> 159  1.155115421 #> 160  1.155115421 #> 161  1.155115421 #> 162  1.155115421 #> 163  1.376333178 #> 164  1.376333178 #> 165  1.376333178 #> 166  1.376333178 #> 167  1.376333178 #> 168  1.376333178 #> 169  1.597550934 #> 170  1.597550934 #> 171  1.597550934 #> 172  1.597550934 #> 173  1.597550934 #> 174  1.818768691 #> 175  1.818768691 #> 176  2.039986448 #> 177  2.039986448 #> 178  2.261204204 #> 179  2.261204204 #> 180  2.482421961 #> 181  2.482421961 #> 182  2.482421961 #> 183  2.482421961 #> 184  2.924857474 #> 185  3.809728501 #> 186 -1.904710944 #> 187 -1.446958222 #> 188 -1.516271359 #> 189 -1.435510310 #> 190 -1.469051308 #> 191 -1.307167384 #> 192 -1.252885127 #> 193 -1.438962493 #> 194 -1.362001169 #> 195 -1.180293079 #> 196 -0.686940586 #> 197 -0.972147457 #> 198 -1.076444843 #> 199 -1.159478980 #> 200 -1.188148689 #> 201 -1.246607923 #> 202 -1.145567730 #> 203 -0.819852994 #> 204 -1.251570337 #> 205 -1.219755634 #> 206 -1.017792171 #> 207 -0.671175400 #> 208 -1.111328466 #> 209 -1.283317496 #> 210 -1.020208579 #> 211 -1.081052481 #> 212 -0.867852941 #> 213 -1.234828942 #> 214 -0.429062666 #> 215 -1.195027706 #> 216 -0.589984373 #> 217 -0.323892485 #> 218 -1.226764427 #> 219 -0.655897507 #> 220 -0.587283518 #> 221 -0.636425366 #> 222 -0.879965476 #> 223 -0.448960197 #> 224 -0.659728628 #> 225 -0.958733815 #> 226 -0.122812023 #> 227 -1.043605282 #> 228 -0.828186933 #> 229 -0.854903222 #> 230 -0.318770439 #> 231 -0.488842618 #> 232 -0.735799397 #> 233 -0.865993142 #> 234 -0.628242662 #> 235 -0.936532122 #> 236 -0.594419352 #> 237 -0.247575971 #> 238 -0.798393744 #> 239 -0.788407168 #> 240 -0.705221520 #> 241 -0.348264860 #> 242 -0.338483315 #> 243 -0.755715811 #> 244 -0.752285772 #> 245 -0.735646645 #> 246 -0.842713637 #> 247 -0.697167716 #> 248 -0.955954922 #> 249 -0.634630752 #> 250 -1.031659120 #> 251 -0.522481207 #> 252 -1.062704793 #> 253 -0.746255681 #> 254 -0.546320423 #> 255 -0.116574612 #> 256 -0.671755443 #> 257 -0.338181708 #> 258 -0.412168564 #> 259 -0.495521488 #> 260 -0.057343421 #> 261 -0.248603108 #> 262 -0.190226553 #> 263 -0.538487643 #> 264 -0.264204088 #> 265 -0.463717649 #> 266 -0.833799536 #> 267 -0.103570522 #> 268 -0.568484395 #> 269  0.098566285 #> 270  0.066715229 #> 271 -0.524833610 #> 272 -0.325822019 #> 273  0.011424613 #> 274 -0.219217660 #> 275 -0.039319589 #> 276  0.003720692 #> 277  0.022758094 #> 278 -0.202947472 #> 279  0.061383574 #> 280 -0.136667734 #> 281 -0.231594448 #> 282 -0.136450583 #> 283  0.026820367 #> 284 -0.013424286 #> 285 -0.032782056 #> 286 -0.362160719 #> 287 -0.330839989 #> 288  0.018349694 #> 289 -0.420701351 #> 290  0.192229417 #> 291  0.009404862 #> 292  0.056437997 #> 293 -0.248137458 #> 294  0.306390867 #> 295  0.161373012 #> 296  0.011815822 #> 297  0.170630337 #> 298 -0.374530775 #> 299 -0.116689464 #> 300  0.234711307 #> 301  0.144312781 #> 302 -0.072281390 #> 303  0.139732621 #> 304  0.052357810 #> 305  0.152735425 #> 306  0.233158452 #> 307  0.295743756 #> 308  0.181131304 #> 309  0.014473805 #> 310 -0.123372067 #> 311 -0.195697581 #> 312  0.078407572 #> 313  0.306855809 #> 314  0.095513681 #> 315  0.323058995 #> 316  0.300202359 #> 317  0.506922239 #> 318  0.541638035 #> 319  0.322587942 #> 320  0.229329439 #> 321  0.187346766 #> 322  0.058886587 #> 323  0.452509051 #> 324  0.733302892 #> 325  0.830753384 #> 326  0.755462905 #> 327  0.188998663 #> 328  0.942897542 #> 329  0.803957279 #> 330  0.743956031 #> 331  0.794595932 #> 332  0.927006619 #> 333  0.742004197 #> 334  0.563513496 #> 335  0.548594198 #> 336  0.662051979 #> 337  0.969064668 #> 338  1.075121195 #> 339  1.057640874 #> 340  1.156882774 #> 341  0.731064690 #> 342  1.445208429 #> 343  1.089790016 #> 344  1.275715985 #> 345  1.299792377 #> 346  0.900243680 #> 347  1.050795807 #> 348  1.527842293 #> 349  1.436841076 #> 350  1.167324315 #> 351  0.951697157 #> 352  1.370161990 #> 353  1.360552015 #> 354  1.782248836 #> 355  1.606139445 #> 356  1.528815926 #> 357  1.209406380 #> 358  1.821267867 #> 359  1.581805839 #> 360  1.538216948 #> 361  2.192971226 #> 362  1.906572817 #> 363  2.633592864 #> 364  1.923875436 #> 365  2.307183443 #> 366  2.718682078 #> 367  2.040620572 #> 368  2.621263670 #> 369  3.101811011 #> 370  3.610763025 #>  #> $varG #>            Yield   Weight #> Yield  20.434313 4.406246 #> Weight  4.406246 1.000000 #>  #> $mu #>        Yield       Weight  #> 1.177838e+01 9.763680e-18  #>"},{"path":"https://github.com/covaruber/sommer/reference/summary_mmec.html","id":null,"dir":"Reference","previous_headings":"","what":"summary form a GLMM fitted with mmec — summary.mmec","title":"summary form a GLMM fitted with mmec — summary.mmec","text":"summary method class \"mmec\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/summary_mmec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary form a GLMM fitted with mmec — summary.mmec","text":"","code":"# S3 method for class 'mmec' summary(object, ...)"},{"path":"https://github.com/covaruber/sommer/reference/summary_mmec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary form a GLMM fitted with mmec — summary.mmec","text":"object object class \"mmec\" ... arguments passed","code":""},{"path":"https://github.com/covaruber/sommer/reference/summary_mmec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"summary form a GLMM fitted with mmec — summary.mmec","text":"vector summary","code":""},{"path":"https://github.com/covaruber/sommer/reference/summary_mmec.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"summary form a GLMM fitted with mmec — summary.mmec","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/summary_mmer.html","id":null,"dir":"Reference","previous_headings":"","what":"summary form a GLMM fitted with mmer — summary.mmer","title":"summary form a GLMM fitted with mmer — summary.mmer","text":"summary method class \"mmer\".","code":""},{"path":"https://github.com/covaruber/sommer/reference/summary_mmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary form a GLMM fitted with mmer — summary.mmer","text":"","code":"# S3 method for class 'mmer' summary(object, ...)"},{"path":"https://github.com/covaruber/sommer/reference/summary_mmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary form a GLMM fitted with mmer — summary.mmer","text":"object object class \"mmer\" ... arguments passed","code":""},{"path":"https://github.com/covaruber/sommer/reference/summary_mmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"summary form a GLMM fitted with mmer — summary.mmer","text":"vector summary","code":""},{"path":"https://github.com/covaruber/sommer/reference/summary_mmer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"summary form a GLMM fitted with mmer — summary.mmer","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/tps.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Tensor Product Spline Mixed Model Incidence Matrices — tps","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — tps","text":"tps wrapper tpsmmb function TPSbits package avoid version dependencies using function research please cite TPSbits package. function internally used spl2Dmatrices function get Tensor-Product P-Spline Mixed Model Bits     (design matrices) use sommer main function mmer.","code":""},{"path":"https://github.com/covaruber/sommer/reference/tps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — tps","text":"","code":"tps(   columncoordinates,   rowcoordinates,   nsegments=NULL,   minbound=NULL,   maxbound=NULL,   degree = c(3, 3),   penaltyord = c(2, 2),   nestorder = c(1, 1),   asreml = \"grp\",   eigenvalues = \"include\",   method = \"Lee\",   stub = NULL )"},{"path":"https://github.com/covaruber/sommer/reference/tps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — tps","text":"columncoordinates string. Gives name data element holding column locations. rowcoordinates string. Gives name data element holding row locations. nsegments list length 2. Number segments split column row ranges , respectively (= number internal knots + 1). one number specified, value used dimensions. specified, (number unique values - 1) used dimension; grid layout (equal spacing) gives knot data value. minbound list length 2. lower bound used column row dimensions respectively; default calculated minimum value dimension. maxbound list length 2. upper bound used column row dimensions respectively; default calculated maximum value dimension. degree list length 2. degree polynomial spline used column row dimensions respectively; default=3. penaltyord list length 2. order differencing column row dimensions, respectively; default=2. nestorder list length 2. order nesting column row dimensions, respectively; default=1 (nesting). value 2 generates spline half number segments dimension, etc. number segments direction must multiple order nesting. asreml string. Indicates types structures generated use asreml models; default \"mbf\". appropriate eigenvalue scaling included within Z matrices unless setting scaling=\"none\" used, scaling factors supplied separately returned object. asreml=\"mbf\" indicates function put spline design matrices structures use \"mbf\"; asreml=\"grp\" indicates function add composite spline design matrices (eg. second-order differencing, matrices Xr1:Zc, Xr2:Zc, Zr:Xc1, Zr:Xc2 Zc:Zr) data frame provide group list structure term; asreml=\"sepgrp\" indicates function generate individual X Z spline design matrices separately (ie. Xc, Xr, Zc Zr), plus smooth x smooth interaction term whole (ie. Zc:Zr), provide group list structure term. asreml=\"\" indicates function generate composite matrix ( Xr:Zc | Zr:Xc | Zc:Zr ) single set columns. eigenvalues string. Indicates whether eigenvalues included within Z design matrices eigenvalues=\"include\", whether scaling omitted (eigenvalues=\"omit\"); default eigenvalues=\"include\". eigenvalue scaling omitted Z design matrices, instead included model variance structure obtain correct TPspline model. method string. Method forming  penalty; default=\"Lee\" ie penalty Lee, Durban & Eilers (2013, CSDA 61, 22-37). alternative method \"Wood\" ie. method Wood et al (2012, Stat Comp 23, 341-360). option research tool requires investigation. stub string. Stub attached names mbf list avoid -writing structures general confusion.","code":""},{"path":"https://github.com/covaruber/sommer/reference/tps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — tps","text":"List length 7, 8 9 (according asreml     eigenvalues parameter settings). data = input data frame augmented structures required     fit tensor product splines asreml-R. data frame can used     fit TPS model. Added columns: TP.col, TP.row = column row coordinates TP.CxR = combined index use smooth x smooth term TP.C.n n=1:(diff.c) = X parts column spline use     random model (diff.c order column differencing) TP.R.n n=1:(diff.r) = X parts row spline use     random model (diff.r order row differencing) TP.CR.n n=1:((diff.c*diff.r)) = interaction     two X parts use fixed model. first variate     constant term omitted model constant     (1) present. elements     included model constant term omitted,     eg. y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + terms... asreml=\"grp\" \"sepgrp\", spline basis     functions also added data frame. Column numbers     term given grp list structure. mbflist = list can used call asreml (long Z     matrix data frames extracted right names, eg BcZ<stub>.df) BcZ.df = mbf data frame mapping onto smooth part column     spline, last column (labelled TP.col) gives column index BrZ.df = mbf data frame mapping onto smooth part row spline,     last column (labelled TP.row) gives row index BcrZ.df = mbf data frame mapping onto smooth x smooth term, last     column (labelled TP.CxR) maps onto col x row combined index dim = list structure, holding dimension values relating     model: \"diff.c\" = order differencing used column dimension \"nbc\" = number random basis functions column dimension \"nbcn\" = number nested random basis functions column dimension            used smooth x smooth term \"diff.r\" = order differencing used column dimension \"nbr\" = number random basis functions column dimension \"nbrn\" = number nested random basis functions column dimension            used smooth x smooth term trace = list trace values ZGZ' random TPspline    terms, Z design matrix G    known diagonal variance matrix derived eigenvalues. can    used rescale spline design matrix (equivalently variance    components). grp = list structure, added settings    asreml=\"grp\",  asreml=\"sepgrp\" asreml=\"\".    asreml=\"grp\", provides column indexes 5    random components 2D splines.    asreml=\"sepgrp\", provides column indexes X    Z component matrices 1D splines, plus composite smooth x    smooth interaction term. asreml=\"\", provides column indexes    composite random model.    Dimensions components can derived values    dim item.  Z terms scaled associated    eigenvalues eigenvalues=\"include\",    eigenvalues=\"omit\". eigen = list structure, added option setting    eigenvalues=\"omit\". Holds diagonal elements inverse    variance matrix terms Xc:Zr (called diagr), Zc:Xr    (called diagc) Zc:Zr (called diagcr).","code":""},{"path":"https://github.com/covaruber/sommer/reference/tpsmmbwrapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Tensor Product Spline Mixed Model Incidence Matrices — tpsmmbwrapper","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — tpsmmbwrapper","text":"tpsmmbwrapper wrapper tpsmmb function TPSbits package avoid version dependencies using function research please cite TPSbits package. function internally used spl2Dmatrices function get Tensor-Product P-Spline Mixed Model Bits     (design matrices) use sommer main function mmer.","code":""},{"path":"https://github.com/covaruber/sommer/reference/tpsmmbwrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — tpsmmbwrapper","text":"","code":"tpsmmbwrapper(   columncoordinates,   rowcoordinates,   data,   nsegments=NULL,   minbound=NULL,   maxbound=NULL,   degree = c(3, 3),   penaltyord = c(2, 2),   nestorder = c(1, 1),   asreml = \"mbf\",   eigenvalues = \"include\",   method = \"Lee\",   stub = NULL )"},{"path":"https://github.com/covaruber/sommer/reference/tpsmmbwrapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — tpsmmbwrapper","text":"columncoordinates string. Gives name data element holding column locations. rowcoordinates string. Gives name data element holding row locations. data dataframe. Holds dataset used fitting. nsegments list length 2. Number segments split column row ranges , respectively (= number internal knots + 1). one number specified, value used dimensions. specified, (number unique values - 1) used dimension; grid layout (equal spacing) gives knot data value. minbound list length 2. lower bound used column row dimensions respectively; default calculated minimum value dimension. maxbound list length 2. upper bound used column row dimensions respectively; default calculated maximum value dimension. degree list length 2. degree polynomial spline used column row dimensions respectively; default=3. penaltyord list length 2. order differencing column row dimensions, respectively; default=2. nestorder list length 2. order nesting column row dimensions, respectively; default=1 (nesting). value 2 generates spline half number segments dimension, etc. number segments direction must multiple order nesting. asreml string. Indicates types structures generated use asreml models; default \"mbf\". appropriate eigenvalue scaling included within Z matrices unless setting scaling=\"none\" used, scaling factors supplied separately returned object. asreml=\"mbf\" indicates function put spline design matrices structures use \"mbf\"; asreml=\"grp\" indicates function add composite spline design matrices (eg. second-order differencing, matrices Xr1:Zc, Xr2:Zc, Zr:Xc1, Zr:Xc2 Zc:Zr) data frame provide group list structure term; asreml=\"sepgrp\" indicates function generate individual X Z spline design matrices separately (ie. Xc, Xr, Zc Zr), plus smooth x smooth interaction term whole (ie. Zc:Zr), provide group list structure term. asreml=\"\" indicates function generate composite matrix ( Xr:Zc | Zr:Xc | Zc:Zr ) single set columns. eigenvalues string. Indicates whether eigenvalues included within Z design matrices eigenvalues=\"include\", whether scaling omitted (eigenvalues=\"omit\"); default eigenvalues=\"include\". eigenvalue scaling omitted Z design matrices, instead included model variance structure obtain correct TPspline model. method string. Method forming  penalty; default=\"Lee\" ie penalty Lee, Durban & Eilers (2013, CSDA 61, 22-37). alternative method \"Wood\" ie. method Wood et al (2012, Stat Comp 23, 341-360). option research tool requires investigation. stub string. Stub attached names mbf list avoid -writing structures general confusion.","code":""},{"path":"https://github.com/covaruber/sommer/reference/tpsmmbwrapper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Tensor Product Spline Mixed Model Incidence Matrices — tpsmmbwrapper","text":"List length 7, 8 9 (according asreml     eigenvalues parameter settings). data = input data frame augmented structures required     fit tensor product splines asreml-R. data frame can used     fit TPS model. Added columns: TP.col, TP.row = column row coordinates TP.CxR = combined index use smooth x smooth term TP.C.n n=1:(diff.c) = X parts column spline use     random model (diff.c order column differencing) TP.R.n n=1:(diff.r) = X parts row spline use     random model (diff.r order row differencing) TP.CR.n n=1:((diff.c*diff.r)) = interaction     two X parts use fixed model. first variate     constant term omitted model constant     (1) present. elements     included model constant term omitted,     eg. y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + terms... asreml=\"grp\" \"sepgrp\", spline basis     functions also added data frame. Column numbers     term given grp list structure. mbflist = list can used call asreml (long Z     matrix data frames extracted right names, eg BcZ<stub>.df) BcZ.df = mbf data frame mapping onto smooth part column     spline, last column (labelled TP.col) gives column index BrZ.df = mbf data frame mapping onto smooth part row spline,     last column (labelled TP.row) gives row index BcrZ.df = mbf data frame mapping onto smooth x smooth term, last     column (labelled TP.CxR) maps onto col x row combined index dim = list structure, holding dimension values relating     model: \"diff.c\" = order differencing used column dimension \"nbc\" = number random basis functions column dimension \"nbcn\" = number nested random basis functions column dimension            used smooth x smooth term \"diff.r\" = order differencing used column dimension \"nbr\" = number random basis functions column dimension \"nbrn\" = number nested random basis functions column dimension            used smooth x smooth term trace = list trace values ZGZ' random TPspline    terms, Z design matrix G    known diagonal variance matrix derived eigenvalues. can    used rescale spline design matrix (equivalently variance    components). grp = list structure, added settings    asreml=\"grp\",  asreml=\"sepgrp\" asreml=\"\".    asreml=\"grp\", provides column indexes 5    random components 2D splines.    asreml=\"sepgrp\", provides column indexes X    Z component matrices 1D splines, plus composite smooth x    smooth interaction term. asreml=\"\", provides column indexes    composite random model.    Dimensions components can derived values    dim item.  Z terms scaled associated    eigenvalues eigenvalues=\"include\",    eigenvalues=\"omit\". eigen = list structure, added option setting    eigenvalues=\"omit\". Holds diagonal elements inverse    variance matrix terms Xc:Zr (called diagr), Zc:Xr    (called diagc) Zc:Zr (called diagcr).","code":""},{"path":"https://github.com/covaruber/sommer/reference/transformConstraints.html","id":null,"dir":"Reference","previous_headings":"","what":"transformConstraints — transformConstraints","title":"transformConstraints — transformConstraints","text":"transformConstraints takes list matrices constraints transforms non-zero values value desired. purpose function make easy transformation initial constraints fixed-constraint list provided mixed model fitted mmer function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/transformConstraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"transformConstraints — transformConstraints","text":"","code":"transformConstraints(list0,value=1)"},{"path":"https://github.com/covaruber/sommer/reference/transformConstraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"transformConstraints — transformConstraints","text":"list0 list matrices constraints according rules specified vsr function (0: estimated, 1: positive, 2:unconstrained, 3:fixed). value value used replace non-zero values constraint matrices.","code":""},{"path":"https://github.com/covaruber/sommer/reference/transformConstraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"transformConstraints — transformConstraints","text":"$res list modified constraint matrices.","code":""},{"path":"https://github.com/covaruber/sommer/reference/transformConstraints.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"transformConstraints — transformConstraints","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/transformConstraints.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"transformConstraints — transformConstraints","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/transformConstraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"transformConstraints — transformConstraints","text":"","code":"(a <- list(unsm(4), diag(4))) #> [[1]] #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    2    2 #> [2,]    2    1    2    2 #> [3,]    2    2    1    2 #> [4,]    2    2    2    1 #>  #> [[2]] #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #> [3,]    0    0    1    0 #> [4,]    0    0    0    1 #>  transformConstraints(a, value=3) #> [[1]] #>      [,1] [,2] [,3] [,4] #> [1,]    3    3    3    3 #> [2,]    3    3    3    3 #> [3,]    3    3    3    3 #> [4,]    3    3    3    3 #>  #> [[2]] #>      [,1] [,2] [,3] [,4] #> [1,]    3    0    0    0 #> [2,]    0    3    0    0 #> [3,]    0    0    3    0 #> [4,]    0    0    0    3 #>"},{"path":"https://github.com/covaruber/sommer/reference/transp.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating color with transparency — transp","title":"Creating color with transparency — transp","text":"function takes color returns certain alpha grade transparency.","code":""},{"path":"https://github.com/covaruber/sommer/reference/transp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating color with transparency — transp","text":"","code":"transp(col, alpha=0.5)"},{"path":"https://github.com/covaruber/sommer/reference/transp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating color with transparency — transp","text":"col Color used transparency alpha Grade transparency desired","code":""},{"path":"https://github.com/covaruber/sommer/reference/transp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creating color with transparency — transp","text":"major details.","code":""},{"path":"https://github.com/covaruber/sommer/reference/transp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating color with transparency — transp","text":"arguments correctly specified function returns: $res new color certain grade transparency","code":""},{"path":"https://github.com/covaruber/sommer/reference/transp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Creating color with transparency — transp","text":"Robert J. Henry. 2013. Molecular Markers Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0. Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/transp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating color with transparency — transp","text":"","code":"transp(\"red\", alpha=0.5) #> [1] \"#FF000080\""},{"path":"https://github.com/covaruber/sommer/reference/unsm.html","id":null,"dir":"Reference","previous_headings":"","what":"unstructured indication matrix — unsm","title":"unstructured indication matrix — unsm","text":"unsm creates square matrix ones diagonals 2's -diagonals quickly specify unstructured constraint Gtc argument vsr function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/unsm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"unstructured indication matrix — unsm","text":"","code":"unsm(x, reps=NULL)"},{"path":"https://github.com/covaruber/sommer/reference/unsm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"unstructured indication matrix — unsm","text":"x integer specifying number traits fitted given random effect. reps integer specifying number times matrix repeated list format provide easily constraints complex models use ds(), us() cs() structures.","code":""},{"path":"https://github.com/covaruber/sommer/reference/unsm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"unstructured indication matrix — unsm","text":"$res matrix list matrices constraints provided Gtc argument vsr function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/unsm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"unstructured indication matrix — unsm","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/unsm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"unstructured indication matrix — unsm","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/unsm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"unstructured indication matrix — unsm","text":"","code":"unsm(3) #>      [,1] [,2] [,3] #> [1,]    1    2    2 #> [2,]    2    1    2 #> [3,]    2    2    1 unsm(3,2) #> [[1]] #>      [,1] [,2] [,3] #> [1,]    1    2    2 #> [2,]    2    1    2 #> [3,]    2    2    1 #>  #> [[2]] #>      [,1] [,2] [,3] #> [1,]    1    2    2 #> [2,]    2    1    2 #> [3,]    2    2    1 #>"},{"path":"https://github.com/covaruber/sommer/reference/usc.html","id":null,"dir":"Reference","previous_headings":"","what":"unstructured covariance structure — usc","title":"unstructured covariance structure — usc","text":"usc creates unstructured covariance structure specific levels random effect used mmec solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/usc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"unstructured covariance structure — usc","text":"","code":"usc(x, thetaC, theta)"},{"path":"https://github.com/covaruber/sommer/reference/usc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"unstructured covariance structure — usc","text":"x vector observations random effect. thetaC optional symmetric matrix constraints variance-covariance components. symmetric matrix many rows columns number levels factor 'x'. values matrix define variance-covariance components estimated: 0: component estimated 1: component estimated constrained positive 2: component estimated unconstrained 3: component fixed value provided theta argument  theta optional symmetric matrix initial values variance-covariance components. providing customized values, values scaled respect original variance. example, provide initial value 1 given variance component, theta built : theta = matrix( 1 / var(response) ) symmetric matrix many rows columns number levels factor 'x'. values matrix define initial values variance-covariance components subject constraints provided thetaC. provided, initial values calculated : diag(ncol(mm))*.05 + matrix(.1,ncol(mm),ncol(mm)) mm incidence matrix factor 'x'.","code":""},{"path":"https://github.com/covaruber/sommer/reference/usc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"unstructured covariance structure — usc","text":"$res list provided vector variance covariance structure expected levels random effect.","code":""},{"path":"https://github.com/covaruber/sommer/reference/usc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"unstructured covariance structure — usc","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/usc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"unstructured covariance structure — usc","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/usc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"unstructured covariance structure — usc","text":"","code":"x <- as.factor(c(1:5,1:5,1:5));x #>  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 #> Levels: 1 2 3 4 5 usc(x) #> $Z #> 15 x 5 sparse Matrix of class \"dgCMatrix\" #>    1 2 3 4 5 #> 1  1 . . . . #> 2  . 1 . . . #> 3  . . 1 . . #> 4  . . . 1 . #> 5  . . . . 1 #> 6  1 . . . . #> 7  . 1 . . . #> 8  . . 1 . . #> 9  . . . 1 . #> 10 . . . . 1 #> 11 1 . . . . #> 12 . 1 . . . #> 13 . . 1 . . #> 14 . . . 1 . #> 15 . . . . 1 #>  #> $thetaC #>   1 2 3 4 5 #> 1 1 2 2 2 2 #> 2 0 1 2 2 2 #> 3 0 0 1 2 2 #> 4 0 0 0 1 2 #> 5 0 0 0 0 1 #>  #> $theta #>      [,1] [,2] [,3] [,4] [,5] #> [1,] 0.15 0.10 0.10 0.10 0.10 #> [2,] 0.10 0.15 0.10 0.10 0.10 #> [3,] 0.10 0.10 0.15 0.10 0.10 #> [4,] 0.10 0.10 0.10 0.15 0.10 #> [5,] 0.10 0.10 0.10 0.10 0.15 #>  ## how to use the theta and thetaC arguments: # data(DT_example) # DT <- DT_example # theta <- matrix(9:1,3,3);  # theta[lower.tri(theta)] <- t(theta)[lower.tri(theta)]  # theta # initial VCs # thetaC <- fixm(3); thetaC # fixed VCs # ans1 <- mmec(Yield~Env, #              random= ~ vsc( usc(Env,theta = theta,thetaC = thetaC),isc(Name) ), #              rcov= ~ units, nIters = 1, #              data=DT) # summary(ans1)$varcomp"},{"path":"https://github.com/covaruber/sommer/reference/usr.html","id":null,"dir":"Reference","previous_headings":"","what":"unstructured covariance structure — usr","title":"unstructured covariance structure — usr","text":"usr creates unstructured covariance structure specific levels random effect used mmer solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/usr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"unstructured covariance structure — usr","text":"","code":"usr(x)"},{"path":"https://github.com/covaruber/sommer/reference/usr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"unstructured covariance structure — usr","text":"x vector observations random effect.","code":""},{"path":"https://github.com/covaruber/sommer/reference/usr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"unstructured covariance structure — usr","text":"$res list provided vector variance covariance structure expected levels random effect.","code":""},{"path":"https://github.com/covaruber/sommer/reference/usr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"unstructured covariance structure — usr","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744","code":""},{"path":"https://github.com/covaruber/sommer/reference/usr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"unstructured covariance structure — usr","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/usr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"unstructured covariance structure — usr","text":"","code":"x <- as.factor(c(1:5,1:5,1:5));x #>  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 #> Levels: 1 2 3 4 5 usr(x) #> $Z #>    1 2 3 4 5 #> 1  1 0 0 0 0 #> 2  0 1 0 0 0 #> 3  0 0 1 0 0 #> 4  0 0 0 1 0 #> 5  0 0 0 0 1 #> 6  1 0 0 0 0 #> 7  0 1 0 0 0 #> 8  0 0 1 0 0 #> 9  0 0 0 1 0 #> 10 0 0 0 0 1 #> 11 1 0 0 0 0 #> 12 0 1 0 0 0 #> 13 0 0 1 0 0 #> 14 0 0 0 1 0 #> 15 0 0 0 0 1 #> attr(,\"assign\") #> [1] 1 1 1 1 1 #> attr(,\"contrasts\") #> attr(,\"contrasts\")$dummy #> [1] \"contr.treatment\" #>  #>  #> $thetaC #>   1 2 3 4 5 #> 1 1 2 2 2 2 #> 2 2 1 2 2 2 #> 3 2 2 1 2 2 #> 4 2 2 2 1 2 #> 5 2 2 2 2 1 #>"},{"path":"https://github.com/covaruber/sommer/reference/vpredict.html","id":null,"dir":"Reference","previous_headings":"","what":"vpredict form of a LMM fitted with mmer — vpredict","title":"vpredict form of a LMM fitted with mmer — vpredict","text":"vpredict method class \"mmer\". Post-analysis procedure calculate linear combinations variance components. intended use variance components either simple variances variances covariances unstructured matrix. functions covered linear combinations variance components (example, phenotypic variance), ratio two components (example, heritabilities) correlation based three components (example, genetic correlation). calculations based estimated variance parameters variance matrix represented inverse Fisher Average information matrix. Note matrix zero values fixed variance parameters including near parameter space boundary. transform specified formula. left side formula name transformation. right side formula transformation specified shortcut names like `V1`, `V2`, etc.  easiest way identify shortcut names use `summary(object)$varcomp`. rows object can referred shortcuts `V1`, `V2`, etc.  See example .","code":""},{"path":"https://github.com/covaruber/sommer/reference/vpredict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"vpredict form of a LMM fitted with mmer — vpredict","text":"","code":"vpredict(object, transform) # S3 method for class 'mmer' vpredict(object, transform)"},{"path":"https://github.com/covaruber/sommer/reference/vpredict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"vpredict form of a LMM fitted with mmer — vpredict","text":"object model fitted mmer function. transform formula calculate function.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vpredict.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"vpredict form of a LMM fitted with mmer — vpredict","text":"delta method (e.g., Lynch Walsh 1998, Appendix 1; Ver Hoef 2012) uses   Taylor series expansion approximate moments function   parameters. , second-order Taylor series expansion implemented   approximate standard error function (co)variance parameters.   Partial first derivatives function calculated algorithmic   differentiation deriv. Though vpredict can calculate standard errors non-linear functions   (co)variance parameters fitted mmer model, limited   non-linear functions constructed mathematical operations   arithmetic operators +, -, *, / ^,   single-variable functions  exp log. See   deriv information.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vpredict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"vpredict form of a LMM fitted with mmer — vpredict","text":"dd parameter standard error.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vpredict.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"vpredict form of a LMM fitted with mmer — vpredict","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Lynch, M. B. Walsh 1998. Genetics Analysis Quantitative Traits. Sinauer Associates, Inc., Sunderland, MA, USA. Ver Hoef, J.M. 2012. invented delta method? American Statistician 66:124-127. DOI: 10.1080/00031305.2012.687494","code":""},{"path":"https://github.com/covaruber/sommer/reference/vpredict.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"vpredict form of a LMM fitted with mmer — vpredict","text":"Giovanny Covarrubias","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/vpredict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"vpredict form of a LMM fitted with mmer — vpredict","text":"","code":"####=========================================#### ####=========================================#### #### EXAMPLE 1 #### simple example with univariate models ####=========================================#### ####=========================================#### # data(DT_cpdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # #### create the variance-covariance matrix  # A <- A.mat(GT) # #### look at the data and fit the model # head(DT) # mix1 <- mmer(Yield~1, #               random=~vsr(id,Gu=A),  #               data=DT) # summary(mix1)$varcomp # #### run the vpredict function # vpredict(mix1, h2 ~ V1 / ( V1 + V2 ) ) #  # ####=========================================#### # ####=========================================#### # #### EXAMPLE 2 # #### simple example with multivariate models # ####=========================================#### # ####=========================================#### # data(DT_cpdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # #### create the variance-covariance matrix  # A <- A.mat(GT) # #### look at the data and fit the model # head(DT) # mix2 <- mmer(cbind(Yield,color)~1, #                random=~vsr(id,Gu=A, Gt=unsm(2)),  #                rcov=~vsr(units, Gt=unsm(2)), #               data=DT) # summary(mix2)$varcomp # ## genetic correlation # vpredict(mix2, gen.cor ~ V2 / sqrt(V1*V3)) #  # ####=========================================#### # ####=========================================#### # #### EXAMPLE 3 # #### more complex multivariate model # ####=========================================#### # ####=========================================#### # data(DT_btdata) # DT <- DT_btdata # mix3 <- mmer(cbind(tarsus, back) ~ sex, #                random = ~ vsr(dam, Gtc=unsm(2)) + vsr(fosternest,Gtc=diag(2)), #                rcov=~vsr(units,Gtc=unsm(2)), #                data = DT) # summary(mix3)$varcomp # #### calculate the genetic correlation # vpredict(mix3, gen.cor ~ V2 / sqrt(V1*V3)) #  # ####=========================================#### # ####=========================================#### # #### EXAMPLE 4 # #### going back to simple examples # ####=========================================#### # ####=========================================#### # data(DT_btdata) # DT <- DT_btdata # mix4 <- mmer(tarsus ~ sex, random = ~ dam + fosternest, #                data = DT)  # summary(mix4)$varcomp # #### calculate the ratio and its SE # vpredict(mix4, dam.prop ~ V1 / ( V1 + V2 + V3 ) )"},{"path":"https://github.com/covaruber/sommer/reference/vs.html","id":null,"dir":"Reference","previous_headings":"","what":"variance structure specification — vs","title":"variance structure specification — vs","text":"vs main function build variance-covariance structure random effects fitted mmer solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"variance structure specification — vs","text":"","code":"vs(..., Gu=NULL, Gti=NULL, Gtc=NULL, reorderGu=TRUE, buildGu=TRUE)"},{"path":"https://github.com/covaruber/sommer/reference/vs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"variance structure specification — vs","text":"... variance structure specified following logic desired internal kronecker product. example, user wants define diagonal variance structure random effect 'genotypes'(g) respect random effect 'environments'(e), : var(g) = G.e @ .g G.e  matrix containing variance covariance components g (genotypes) level e (environments), .g covariance among levels g (genotypes; .e. relationship matrix), @ kronecker product. specified mmer solver : random=~vs(dsr(e),g) One strength sommer ability specify complex structures many kronecker products desired. example: var(g) = G.e @ G.f @ G.h @ .g equivalent random=~vs(e,f,h,g) different covariance structures can applied levels e,f,h (.e. dsr, usr, csr, atr combination ). examples please see vignettes 'sommer.start' available package. Gu matrix known variance-covariance values levels u.th random effect (.e. relationship matrix among individuals known covariance matrix). NULL, identity matrix assumed. Gu matrix can levels ones present random effect linked way around. Otherwise, error message missing level Gu returned. Gti matrix dimensions t x t (t equal number traits) initial values variance-covariance components random effect specified .... argument. NULL program provide initial values. values need scaled, see Details section. Gtc matrix dimensions t x t (t equal number traits) constraints variance-covariance components random effect specified ... argument according following rules: 0: estimated 1: estimated constrained positive (.e. variance component) 2: estimated unconstrained (can negative positive, .e. covariance component) 3: estimated fixed (value provided Gti argument) multi-response scenario user specify argument default build unstructured matrix (using unsm() function). argument needs used wisely since covariance among responses may make sense. Useful functions specify constraints ; diag(), unsm(), fixm(). reorderGu TRUE/FALSE statement Gu matrix reordered based names design matrix random effect passed custom order user. may important fitting covariance components customized fashion. advanced users. buildGu TRUE/FALSE statement indicate Gu matrix built R value argument Gu=NULL. Repeat, value argument Gu equal NULL. cases incidence matrix wide (e.g. rrBLUP models) covariance structure huge p x p matrix can avoided performing matrix operations. setting argument FALSE allows skip forming covariance matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"variance structure specification — vs","text":"providing initial values Gti argument user provide scaled variance component values. user can provide values previous model accessing sigma_scaled output mmer model specific value desired user can obtain scaled value : m = x/var(y) x desired initial value y response variable. can find example DT_cpdata dataset.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"variance structure specification — vs","text":"$res list neccesary elements (incidence matrices, known var-cov structures, unknown covariance structures estimated constraints) used mmer solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"variance structure specification — vs","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Covarrubias-Pazaran G (2018) Software update: Moving R package sommer   multivariate mixed models genome-assisted prediction. doi:   https://doi.org/10.1101/354639","code":""},{"path":"https://github.com/covaruber/sommer/reference/vs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"variance structure specification — vs","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/vs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"variance structure specification — vs","text":"","code":"# Please use the function vsr() for mmer() and vsc() for mmec."},{"path":"https://github.com/covaruber/sommer/reference/vsc.html","id":null,"dir":"Reference","previous_headings":"","what":"variance structure specification — vsc","title":"variance structure specification — vsc","text":"vsc main function build variance-covariance structure random effects fitted mmec solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vsc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"variance structure specification — vsc","text":"","code":"vsc(..., Gu=NULL, buildGu=TRUE, meN=1, meTheta=NULL, meThetaC=NULL,        sp=FALSE, isFixed=FALSE, verbose=TRUE)"},{"path":"https://github.com/covaruber/sommer/reference/vsc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"variance structure specification — vsc","text":"... variance structure specified following logic desired internal kronecker product. example, user wants define diagonal variance structure random effect 'genotypes'(g) respect random effect 'environments'(e), : var(g) = G.e @ .g G.e  matrix containing variance covariance components g (genotypes) level e (environments), .g covariance among levels g (genotypes; .e. relationship matrix), @ kronecker product. specified mmec solver : random=~vsc(dsc(e),g) One strength sommer ability specify complex structures many kronecker products desired. example: var(g) = G.e @ G.f @ G.h @ .g equivalent random=~vsc(e,f,h,g) different covariance structures can applied levels e,f,h (.e. dsc, usc, csc, atr combination ). examples please see vignettes 'sommer.start' available package. Gu matrix inverse known variance-covariance values levels u.th random effect (e.g., inverse relationship matrix among individuals known inverse covariance matrix). NULL, identity matrix assumed. Gu matrix can levels ones present random effect linked way around. Otherwise, error message missing level Gu returned. buildGu TRUE/FALSE statement indicate Gu matrix built R value argument Gu=NULL. Repeat, value argument Gu equal NULL. cases incidence matrix wide (e.g. rrBLUP models) covariance structure huge p x p matrix can avoided performing matrix operations. setting argument FALSE allows skip forming covariance matrix. meN number main effects variance structure. always counted last first. meTheta variance covariance matrix main effects desired. Just modified number main effects greater 1 (e.g., indirect genetic effects). meThetaC constraints variance covariance matrix main effects desired. Just modified number main effects greater 1 (e.g., indirect genetic effects). sp TRUE/FALSE statement indicate VC structure multiplied scale parameter added mmec function addScaleParam argument mmec function . isFixed TRUE/FALSE statement indicate vsc function used fixed part model. TRUE, function returns model matrix avoid error messages associated returning elements random effect. FALSE default since assumed used variance structure random effect. verbose TRUE/FALSE statement indicate messages printed special situations accur. example, adding unphenotyped individuals incidence matrices present relationship  matrices.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vsc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"variance structure specification — vsc","text":"...","code":""},{"path":"https://github.com/covaruber/sommer/reference/vsc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"variance structure specification — vsc","text":"$res list neccesary elements (incidence matrices, known var-cov structures, unknown covariance structures estimated constraints) used mmec solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vsc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"variance structure specification — vsc","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Covarrubias-Pazaran G (2018) Software update: Moving R package sommer   multivariate mixed models genome-assisted prediction. doi:   https://doi.org/10.1101/354639","code":""},{"path":"https://github.com/covaruber/sommer/reference/vsc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"variance structure specification — vsc","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/vsc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"variance structure specification — vsc","text":"","code":"data(DT_example) DT <- DT_example DT=DT[with(DT, order(Env)), ] A <- A_example  x <- as.character(unique(DT$Name)) DT <- droplevels(DT[which(!is.na(match(DT$Name, x[1:5]))),]) ## ============================ ## ## example without structure ## ============================ ## isc(DT$Name) #> $Z #> 28 x 5 sparse Matrix of class \"dgCMatrix\" #>    AC03433-1W MSK061-4 MSL007-B MSR169-8Y NY148 #> 1           .        .        1         .     . #> 2           .        .        1         .     . #> 3           .        1        .         .     . #> 4           .        1        .         .     . #> 5           .        .        .         1     . #> 6           .        .        .         .     1 #> 7           .        .        .         1     . #> 8           1        .        .         .     . #> 9           1        .        .         .     . #> 10          .        .        .         .     1 #> 11          .        1        .         .     . #> 12          .        .        .         1     . #> 13          .        1        .         .     . #> 14          .        .        1         .     . #> 15          .        .        1         .     . #> 16          .        .        .         .     1 #> 17          1        .        .         .     . #> 18          .        .        .         1     . #> 19          1        .        .         .     . #> 20          .        .        .         .     1 #> 21          .        .        .         1     . #> 22          .        .        1         .     . #> 23          .        .        1         .     . #> 24          .        .        .         1     . #> 25          1        .        .         .     . #> 26          1        .        .         .     . #> 27          .        1        .         .     . #> 28          .        1        .         .     . #>  #> $thetaC #>     isc #> isc   1 #>  #> $theta #>      isc #> isc 0.15 #>  mix <- mmec(Yield~Env,             random= ~ vsc(isc(Name)),             rcov=~ units,             nIters=3,             data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -36.5805   1:17:26      0           0 #>     2      -36.4695   1:17:26      0           0 #>     3      -36.3832   1:17:26      0           0  ## ============================ ## ## example to without structure but ## using covariance among levels in the ## random effect Name ## ============================ ## Ai <- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class=\"dgCMatrix\") mix <- mmec(Yield~Env,             random= ~ vsc(isc(Name), Gu=Ai),             rcov=~ units,             nIters=3,             data=DT) #> Adding additional levels of Gu in the model matrix of 'Name'  #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -36.5804   1:17:26      0           0 #>     2      -36.5226   1:17:26      0           0 #>     3      -36.4128   1:17:26      0           0 summary(mix)$varcomp #>                  VarComp VarCompSE   Zratio Constraint #> Name:Ai:isc:isc 1.519139  1.220564 1.244621   Positive #> units:isc:isc   4.261443  1.542953 2.761875   Positive ## ============================ ## ## example to use dsc() structure (DIAGONAL) ## ============================ ## dsc(DT$Year) #> $Z #> 28 x 3 sparse Matrix of class \"dgCMatrix\" #>    2011 2012 2013 #> 1     1    .    . #> 2     1    .    . #> 3     1    .    . #> 4     1    .    . #> 5     1    .    . #> 6     1    .    . #> 7     1    .    . #> 8     1    .    . #> 9     1    .    . #> 10    1    .    . #> 11    .    1    . #> 12    .    1    . #> 13    .    1    . #> 14    .    1    . #> 15    .    1    . #> 16    .    1    . #> 17    .    1    . #> 18    .    1    . #> 19    .    1    . #> 20    .    1    . #> 21    .    .    1 #> 22    .    .    1 #> 23    .    .    1 #> 24    .    .    1 #> 25    .    .    1 #> 26    .    .    1 #> 27    .    .    1 #> 28    .    .    1 #>  #> $thetaC #>      2011 2012 2013 #> 2011    1    0    0 #> 2012    0    1    0 #> 2013    0    0    1 #>  #> $theta #>      2011 2012 2013 #> 2011 0.15 0.00 0.00 #> 2012 0.00 0.15 0.00 #> 2013 0.00 0.00 0.15 #>  mix <- mmec(Yield~Env,             random= ~ vsc(dsc(Year),isc(Name)),             rcov=~ vsc(dsc(Year),isc(units)),             nIters=3,             data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -81.1114   1:17:26      0           0 #>     2      -78.833   1:17:26      0           0 #>     3      -51.7498   1:17:26      0           0 summary(mix)$varcomp #>                        VarComp VarCompSE     Zratio Constraint #> Year:Name:2011:2011  6.1234579  2.667732 2.29537993   Positive #> Year:Name:2012:2012  0.1233875  1.247469 0.09891023   Positive #> Year:Name:2013:2013  2.7438862  2.595297 1.05725337   Positive #> Year:units:2011:2011 1.9291529  1.092640 1.76558852   Positive #> Year:units:2012:2012 2.3721559  1.608078 1.47514977   Positive #> Year:units:2013:2013 1.7597959  1.266403 1.38960184   Positive ## ============================ ## ## example to use atc() structure (level-specific) ## ============================ ## # unique(DT$Year) # mix <- mmec(Yield~Env, #             random= ~ vsc(atc(Year,c(\"2011\",\"2012\")),isc(Name)), #             rcov=~ vsc(dsc(Year),isc(units)), #             data=DT) ## ============================ ## ## example to use usc() structure (UNSTRUCTURED) ## ============================ ## usc(DT$Year) #> $Z #> 28 x 3 sparse Matrix of class \"dgCMatrix\" #>    2011 2012 2013 #> 1     1    .    . #> 2     1    .    . #> 3     1    .    . #> 4     1    .    . #> 5     1    .    . #> 6     1    .    . #> 7     1    .    . #> 8     1    .    . #> 9     1    .    . #> 10    1    .    . #> 11    .    1    . #> 12    .    1    . #> 13    .    1    . #> 14    .    1    . #> 15    .    1    . #> 16    .    1    . #> 17    .    1    . #> 18    .    1    . #> 19    .    1    . #> 20    .    1    . #> 21    .    .    1 #> 22    .    .    1 #> 23    .    .    1 #> 24    .    .    1 #> 25    .    .    1 #> 26    .    .    1 #> 27    .    .    1 #> 28    .    .    1 #>  #> $thetaC #>      2011 2012 2013 #> 2011    1    2    2 #> 2012    0    1    2 #> 2013    0    0    1 #>  #> $theta #>      [,1] [,2] [,3] #> [1,] 0.15 0.10 0.10 #> [2,] 0.10 0.15 0.10 #> [3,] 0.10 0.10 0.15 #>  mix <- mmec(Yield~Env,             random= ~ vsc(usc(Year),isc(Name)),             rcov=~ vsc(dsc(Year),isc(units)),             nIters = 3,             data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -80.9478   1:17:26      0           0 #>     2      -78.6609   1:17:26      0           0 #> Updated VC is not positive definite, changing to EM step #>     3      -48.1972   1:17:26      0           0 ## ============================ ## ## example using structure in fixed effect ## (notice the isFixed argument) ## ============================ ## mix <- mmec(Yield~ vsc(atc(Env,\"CA.2011\"), isc(Name), isFixed = TRUE),             rcov=~ units,             nIters=3,             data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -27.769   1:17:26      0           0 #>     2      -26.9659   1:17:26      0           0 #>     3      -26.8488   1:17:26      0           0"},{"path":"https://github.com/covaruber/sommer/reference/vsr.html","id":null,"dir":"Reference","previous_headings":"","what":"variance structure specification — vsr","title":"variance structure specification — vsr","text":"vsr main function build variance-covariance structure random effects fitted mmer solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vsr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"variance structure specification — vsr","text":"","code":"vsr(..., Gu=NULL, Gti=NULL, Gtc=NULL, reorderGu=TRUE, buildGu=TRUE)"},{"path":"https://github.com/covaruber/sommer/reference/vsr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"variance structure specification — vsr","text":"... variance structure specified following logic desired internal kronecker product. example, user wants define diagonal variance structure random effect 'genotypes'(g) respect random effect 'environments'(e), : var(g) = G.e @ .g G.e  matrix containing variance covariance components g (genotypes) level e (environments), .g covariance among levels g (genotypes; .e. relationship matrix), @ kronecker product. specified mmer solver : random=~vsr(dsr(e),g) One strength sommer ability specify complex structures many kronecker products desired. example: var(g) = G.e @ G.f @ G.h @ .g equivalent random=~vsr(e,f,h,g) different covariance structures can applied levels e,f,h (.e. dsr, usr, csr, atr combination ). examples please see vignettes 'sommer.start' available package. Gu matrix known variance-covariance values levels u.th random effect (.e. relationship matrix among individuals known covariance matrix). NULL, identity matrix assumed. Gu matrix can levels ones present random effect linked way around. Otherwise, error message missing level Gu returned. Gti matrix dimensions t x t (t equal number traits) initial values variance-covariance components random effect specified .... argument. NULL program provide initial values. values need scaled, see Details section. Gtc matrix dimensions t x t (t equal number traits) constraints variance-covariance components random effect specified ... argument according following rules: 0: estimated 1: estimated constrained positive (.e. variance component) 2: estimated unconstrained (can negative positive, .e. covariance component) 3: estimated fixed (value provided Gti argument) multi-response scenario user specify argument default build unstructured matrix (using unsm() function). argument needs used wisely since covariance among responses may make sense. Useful functions specify constraints ; diag(), unsm(), fixm(). reorderGu TRUE/FALSE statement Gu matrix reordered based names design matrix random effect passed custom order user. may important fitting covariance components customized fashion. advanced users. buildGu TRUE/FALSE statement indicate Gu matrix built R value argument Gu=NULL. Repeat, value argument Gu equal NULL. cases incidence matrix wide (e.g. rrBLUP models) covariance structure huge p x p matrix can avoided performing matrix operations. setting argument FALSE allows skip forming covariance matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vsr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"variance structure specification — vsr","text":"providing initial values Gti argument user provide scaled variance component values. user can provide values previous model accessing sigma_scaled output mmer model specific value desired user can obtain scaled value : m = x/var(y) x desired initial value y response variable. can find example DT_cpdata dataset.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vsr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"variance structure specification — vsr","text":"$res list neccesary elements (incidence matrices, known var-cov structures, unknown covariance structures estimated constraints) used mmer solver.","code":""},{"path":"https://github.com/covaruber/sommer/reference/vsr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"variance structure specification — vsr","text":"Covarrubias-Pazaran G (2016) Genome assisted prediction quantitative traits using R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 Covarrubias-Pazaran G (2018) Software update: Moving R package sommer   multivariate mixed models genome-assisted prediction. doi:   https://doi.org/10.1101/354639","code":""},{"path":"https://github.com/covaruber/sommer/reference/vsr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"variance structure specification — vsr","text":"Giovanny Covarrubias-Pazaran","code":""},{"path":[]},{"path":"https://github.com/covaruber/sommer/reference/vsr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"variance structure specification — vsr","text":"","code":"data(DT_example) DT <- DT_example A <- A_example  ## ============================ ## ## example to without structure ## ============================ ## dsr(DT$Year) #> $Z #>     2011 2012 2013 #> 1      0    0    1 #> 2      0    0    1 #> 3      0    0    1 #> 4      1    0    0 #> 5      0    0    1 #> 6      0    0    1 #> 7      0    1    0 #> 8      1    0    0 #> 9      0    1    0 #> 10     0    1    0 #> 11     0    1    0 #> 12     0    0    1 #> 13     0    0    1 #> 14     0    0    1 #> 15     0    0    1 #> 16     0    1    0 #> 17     0    0    1 #> 18     0    0    1 #> 19     0    0    1 #> 20     0    0    1 #> 21     0    1    0 #> 22     0    1    0 #> 23     0    0    1 #> 24     0    1    0 #> 25     0    0    1 #> 26     0    0    1 #> 27     0    0    1 #> 28     0    0    1 #> 29     0    1    0 #> 30     0    1    0 #> 31     0    1    0 #> 32     0    0    1 #> 33     0    0    1 #> 34     0    1    0 #> 35     0    1    0 #> 36     0    0    1 #> 37     0    0    1 #> 38     0    1    0 #> 39     0    1    0 #> 40     0    1    0 #> 41     0    0    1 #> 42     0    1    0 #> 43     0    1    0 #> 44     0    0    1 #> 45     0    1    0 #> 46     0    1    0 #> 47     0    0    1 #> 48     0    1    0 #> 49     0    1    0 #> 50     0    0    1 #> 51     0    1    0 #> 52     0    0    1 #> 53     1    0    0 #> 54     0    1    0 #> 55     0    0    1 #> 56     0    1    0 #> 57     0    1    0 #> 58     0    0    1 #> 59     0    0    1 #> 60     0    0    1 #> 61     0    1    0 #> 62     0    1    0 #> 63     0    1    0 #> 64     0    1    0 #> 65     0    0    1 #> 66     0    1    0 #> 67     0    0    1 #> 68     0    0    1 #> 69     0    1    0 #> 70     0    1    0 #> 71     0    1    0 #> 72     0    1    0 #> 73     0    1    0 #> 74     0    0    1 #> 75     0    1    0 #> 76     0    1    0 #> 77     1    0    0 #> 78     0    0    1 #> 79     0    0    1 #> 80     0    1    0 #> 81     0    0    1 #> 82     0    1    0 #> 83     0    1    0 #> 84     0    1    0 #> 85     0    1    0 #> 86     0    0    1 #> 87     0    1    0 #> 88     0    0    1 #> 89     0    1    0 #> 90     0    0    1 #> 91     0    1    0 #> 92     0    1    0 #> 93     0    1    0 #> 94     0    0    1 #> 95     0    1    0 #> 96     0    0    1 #> 97     0    0    1 #> 98     1    0    0 #> 99     0    1    0 #> 100    1    0    0 #> 101    0    1    0 #> 102    0    0    1 #> 103    0    0    1 #> 104    0    0    1 #> 105    0    0    1 #> 106    0    1    0 #> 107    0    0    1 #> 108    0    1    0 #> 109    0    1    0 #> 110    0    1    0 #> 111    0    0    1 #> 112    1    0    0 #> 113    0    1    0 #> 114    0    1    0 #> 115    0    1    0 #> 116    0    0    1 #> 117    0    1    0 #> 118    0    1    0 #> 119    1    0    0 #> 120    1    0    0 #> 121    0    0    1 #> 122    0    1    0 #> 123    1    0    0 #> 124    0    1    0 #> 125    0    1    0 #> 126    0    1    0 #> 127    0    1    0 #> 128    0    1    0 #> 129    0    0    1 #> 130    0    0    1 #> 131    0    1    0 #> 132    0    0    1 #> 133    1    0    0 #> 134    0    1    0 #> 135    0    1    0 #> 136    0    0    1 #> 137    0    0    1 #> 138    0    0    1 #> 139    0    1    0 #> 140    0    0    1 #> 141    0    0    1 #> 142    0    1    0 #> 143    0    0    1 #> 144    1    0    0 #> 145    1    0    0 #> 146    0    1    0 #> 147    1    0    0 #> 148    1    0    0 #> 149    1    0    0 #> 150    0    0    1 #> 151    0    0    1 #> 152    0    1    0 #> 153    1    0    0 #> 154    1    0    0 #> 155    0    1    0 #> 156    1    0    0 #> 157    0    0    1 #> 158    1    0    0 #> 159    1    0    0 #> 160    1    0    0 #> 161    1    0    0 #> 162    1    0    0 #> 163    1    0    0 #> 164    0    1    0 #> 165    1    0    0 #> 166    1    0    0 #> 167    1    0    0 #> 168    0    1    0 #> 169    1    0    0 #> 170    1    0    0 #> 171    1    0    0 #> 172    1    0    0 #> 173    1    0    0 #> 174    1    0    0 #> 175    1    0    0 #> 176    1    0    0 #> 177    1    0    0 #> 178    1    0    0 #> 179    1    0    0 #> 180    1    0    0 #> 181    0    0    1 #> 182    1    0    0 #> 183    1    0    0 #> 184    0    1    0 #> 185    1    0    0 #> attr(,\"assign\") #> [1] 1 1 1 #> attr(,\"contrasts\") #> attr(,\"contrasts\")$dummy #> [1] \"contr.treatment\" #>  #>  #> $thetaC #>      2011 2012 2013 #> 2011    1    0    0 #> 2012    0    1    0 #> 2013    0    0    1 #>  mix <- mmer(Yield~Env,              random= ~ vsr(Name),             rcov=~ vsr(units),             data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -36.8096   1:17:27      0           0 #>     2      -33.211   1:17:27      0           0 #>     3      -32.6234   1:17:27      0           0 #>     4      -32.5942   1:17:27      0           0 #>     5      -32.5942   1:17:27      0           0              ## ============================ ## ## example to without structure but  ## using covariance among levels in the ## random effect Name ## ============================ ## dsr(DT$Year) #> $Z #>     2011 2012 2013 #> 1      0    0    1 #> 2      0    0    1 #> 3      0    0    1 #> 4      1    0    0 #> 5      0    0    1 #> 6      0    0    1 #> 7      0    1    0 #> 8      1    0    0 #> 9      0    1    0 #> 10     0    1    0 #> 11     0    1    0 #> 12     0    0    1 #> 13     0    0    1 #> 14     0    0    1 #> 15     0    0    1 #> 16     0    1    0 #> 17     0    0    1 #> 18     0    0    1 #> 19     0    0    1 #> 20     0    0    1 #> 21     0    1    0 #> 22     0    1    0 #> 23     0    0    1 #> 24     0    1    0 #> 25     0    0    1 #> 26     0    0    1 #> 27     0    0    1 #> 28     0    0    1 #> 29     0    1    0 #> 30     0    1    0 #> 31     0    1    0 #> 32     0    0    1 #> 33     0    0    1 #> 34     0    1    0 #> 35     0    1    0 #> 36     0    0    1 #> 37     0    0    1 #> 38     0    1    0 #> 39     0    1    0 #> 40     0    1    0 #> 41     0    0    1 #> 42     0    1    0 #> 43     0    1    0 #> 44     0    0    1 #> 45     0    1    0 #> 46     0    1    0 #> 47     0    0    1 #> 48     0    1    0 #> 49     0    1    0 #> 50     0    0    1 #> 51     0    1    0 #> 52     0    0    1 #> 53     1    0    0 #> 54     0    1    0 #> 55     0    0    1 #> 56     0    1    0 #> 57     0    1    0 #> 58     0    0    1 #> 59     0    0    1 #> 60     0    0    1 #> 61     0    1    0 #> 62     0    1    0 #> 63     0    1    0 #> 64     0    1    0 #> 65     0    0    1 #> 66     0    1    0 #> 67     0    0    1 #> 68     0    0    1 #> 69     0    1    0 #> 70     0    1    0 #> 71     0    1    0 #> 72     0    1    0 #> 73     0    1    0 #> 74     0    0    1 #> 75     0    1    0 #> 76     0    1    0 #> 77     1    0    0 #> 78     0    0    1 #> 79     0    0    1 #> 80     0    1    0 #> 81     0    0    1 #> 82     0    1    0 #> 83     0    1    0 #> 84     0    1    0 #> 85     0    1    0 #> 86     0    0    1 #> 87     0    1    0 #> 88     0    0    1 #> 89     0    1    0 #> 90     0    0    1 #> 91     0    1    0 #> 92     0    1    0 #> 93     0    1    0 #> 94     0    0    1 #> 95     0    1    0 #> 96     0    0    1 #> 97     0    0    1 #> 98     1    0    0 #> 99     0    1    0 #> 100    1    0    0 #> 101    0    1    0 #> 102    0    0    1 #> 103    0    0    1 #> 104    0    0    1 #> 105    0    0    1 #> 106    0    1    0 #> 107    0    0    1 #> 108    0    1    0 #> 109    0    1    0 #> 110    0    1    0 #> 111    0    0    1 #> 112    1    0    0 #> 113    0    1    0 #> 114    0    1    0 #> 115    0    1    0 #> 116    0    0    1 #> 117    0    1    0 #> 118    0    1    0 #> 119    1    0    0 #> 120    1    0    0 #> 121    0    0    1 #> 122    0    1    0 #> 123    1    0    0 #> 124    0    1    0 #> 125    0    1    0 #> 126    0    1    0 #> 127    0    1    0 #> 128    0    1    0 #> 129    0    0    1 #> 130    0    0    1 #> 131    0    1    0 #> 132    0    0    1 #> 133    1    0    0 #> 134    0    1    0 #> 135    0    1    0 #> 136    0    0    1 #> 137    0    0    1 #> 138    0    0    1 #> 139    0    1    0 #> 140    0    0    1 #> 141    0    0    1 #> 142    0    1    0 #> 143    0    0    1 #> 144    1    0    0 #> 145    1    0    0 #> 146    0    1    0 #> 147    1    0    0 #> 148    1    0    0 #> 149    1    0    0 #> 150    0    0    1 #> 151    0    0    1 #> 152    0    1    0 #> 153    1    0    0 #> 154    1    0    0 #> 155    0    1    0 #> 156    1    0    0 #> 157    0    0    1 #> 158    1    0    0 #> 159    1    0    0 #> 160    1    0    0 #> 161    1    0    0 #> 162    1    0    0 #> 163    1    0    0 #> 164    0    1    0 #> 165    1    0    0 #> 166    1    0    0 #> 167    1    0    0 #> 168    0    1    0 #> 169    1    0    0 #> 170    1    0    0 #> 171    1    0    0 #> 172    1    0    0 #> 173    1    0    0 #> 174    1    0    0 #> 175    1    0    0 #> 176    1    0    0 #> 177    1    0    0 #> 178    1    0    0 #> 179    1    0    0 #> 180    1    0    0 #> 181    0    0    1 #> 182    1    0    0 #> 183    1    0    0 #> 184    0    1    0 #> 185    1    0    0 #> attr(,\"assign\") #> [1] 1 1 1 #> attr(,\"contrasts\") #> attr(,\"contrasts\")$dummy #> [1] \"contr.treatment\" #>  #>  #> $thetaC #>      2011 2012 2013 #> 2011    1    0    0 #> 2012    0    1    0 #> 2013    0    0    1 #>  mix <- mmer(Yield~Env,              random= ~ vsr(Name, Gu=A),             rcov=~ vsr(units),             data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -36.8096   1:17:27      0           0 #>     2      -33.211   1:17:27      0           0 #>     3      -32.6234   1:17:27      0           0 #>     4      -32.5942   1:17:27      0           0 #>     5      -32.5942   1:17:27      0           0              ## ============================ ## ## example to use dsr() structure (DIAGONAL) ## ============================ ## dsr(DT$Year) #> $Z #>     2011 2012 2013 #> 1      0    0    1 #> 2      0    0    1 #> 3      0    0    1 #> 4      1    0    0 #> 5      0    0    1 #> 6      0    0    1 #> 7      0    1    0 #> 8      1    0    0 #> 9      0    1    0 #> 10     0    1    0 #> 11     0    1    0 #> 12     0    0    1 #> 13     0    0    1 #> 14     0    0    1 #> 15     0    0    1 #> 16     0    1    0 #> 17     0    0    1 #> 18     0    0    1 #> 19     0    0    1 #> 20     0    0    1 #> 21     0    1    0 #> 22     0    1    0 #> 23     0    0    1 #> 24     0    1    0 #> 25     0    0    1 #> 26     0    0    1 #> 27     0    0    1 #> 28     0    0    1 #> 29     0    1    0 #> 30     0    1    0 #> 31     0    1    0 #> 32     0    0    1 #> 33     0    0    1 #> 34     0    1    0 #> 35     0    1    0 #> 36     0    0    1 #> 37     0    0    1 #> 38     0    1    0 #> 39     0    1    0 #> 40     0    1    0 #> 41     0    0    1 #> 42     0    1    0 #> 43     0    1    0 #> 44     0    0    1 #> 45     0    1    0 #> 46     0    1    0 #> 47     0    0    1 #> 48     0    1    0 #> 49     0    1    0 #> 50     0    0    1 #> 51     0    1    0 #> 52     0    0    1 #> 53     1    0    0 #> 54     0    1    0 #> 55     0    0    1 #> 56     0    1    0 #> 57     0    1    0 #> 58     0    0    1 #> 59     0    0    1 #> 60     0    0    1 #> 61     0    1    0 #> 62     0    1    0 #> 63     0    1    0 #> 64     0    1    0 #> 65     0    0    1 #> 66     0    1    0 #> 67     0    0    1 #> 68     0    0    1 #> 69     0    1    0 #> 70     0    1    0 #> 71     0    1    0 #> 72     0    1    0 #> 73     0    1    0 #> 74     0    0    1 #> 75     0    1    0 #> 76     0    1    0 #> 77     1    0    0 #> 78     0    0    1 #> 79     0    0    1 #> 80     0    1    0 #> 81     0    0    1 #> 82     0    1    0 #> 83     0    1    0 #> 84     0    1    0 #> 85     0    1    0 #> 86     0    0    1 #> 87     0    1    0 #> 88     0    0    1 #> 89     0    1    0 #> 90     0    0    1 #> 91     0    1    0 #> 92     0    1    0 #> 93     0    1    0 #> 94     0    0    1 #> 95     0    1    0 #> 96     0    0    1 #> 97     0    0    1 #> 98     1    0    0 #> 99     0    1    0 #> 100    1    0    0 #> 101    0    1    0 #> 102    0    0    1 #> 103    0    0    1 #> 104    0    0    1 #> 105    0    0    1 #> 106    0    1    0 #> 107    0    0    1 #> 108    0    1    0 #> 109    0    1    0 #> 110    0    1    0 #> 111    0    0    1 #> 112    1    0    0 #> 113    0    1    0 #> 114    0    1    0 #> 115    0    1    0 #> 116    0    0    1 #> 117    0    1    0 #> 118    0    1    0 #> 119    1    0    0 #> 120    1    0    0 #> 121    0    0    1 #> 122    0    1    0 #> 123    1    0    0 #> 124    0    1    0 #> 125    0    1    0 #> 126    0    1    0 #> 127    0    1    0 #> 128    0    1    0 #> 129    0    0    1 #> 130    0    0    1 #> 131    0    1    0 #> 132    0    0    1 #> 133    1    0    0 #> 134    0    1    0 #> 135    0    1    0 #> 136    0    0    1 #> 137    0    0    1 #> 138    0    0    1 #> 139    0    1    0 #> 140    0    0    1 #> 141    0    0    1 #> 142    0    1    0 #> 143    0    0    1 #> 144    1    0    0 #> 145    1    0    0 #> 146    0    1    0 #> 147    1    0    0 #> 148    1    0    0 #> 149    1    0    0 #> 150    0    0    1 #> 151    0    0    1 #> 152    0    1    0 #> 153    1    0    0 #> 154    1    0    0 #> 155    0    1    0 #> 156    1    0    0 #> 157    0    0    1 #> 158    1    0    0 #> 159    1    0    0 #> 160    1    0    0 #> 161    1    0    0 #> 162    1    0    0 #> 163    1    0    0 #> 164    0    1    0 #> 165    1    0    0 #> 166    1    0    0 #> 167    1    0    0 #> 168    0    1    0 #> 169    1    0    0 #> 170    1    0    0 #> 171    1    0    0 #> 172    1    0    0 #> 173    1    0    0 #> 174    1    0    0 #> 175    1    0    0 #> 176    1    0    0 #> 177    1    0    0 #> 178    1    0    0 #> 179    1    0    0 #> 180    1    0    0 #> 181    0    0    1 #> 182    1    0    0 #> 183    1    0    0 #> 184    0    1    0 #> 185    1    0    0 #> attr(,\"assign\") #> [1] 1 1 1 #> attr(,\"contrasts\") #> attr(,\"contrasts\")$dummy #> [1] \"contr.treatment\" #>  #>  #> $thetaC #>      2011 2012 2013 #> 2011    1    0    0 #> 2012    0    1    0 #> 2013    0    0    1 #>  mix <- mmer(Yield~Env,              random= ~ vsr(dsr(Year),Name),             rcov=~ vsr(dsr(Year),units),             data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -42.26   1:17:27      0           0 #>     2      -25.3744   1:17:27      0           0 #>     3      -19.1877   1:17:27      0           0 #>     4      -18.3538   1:17:27      0           0 #>     5      -18.3432   1:17:27      0           0 #>     6      -18.343   1:17:27      0           0  ## ============================ ## ## example to use atr() structure (level-specific) ## ============================ ## unique(DT$Year) #> [1] 2013 2011 2012 #> Levels: 2011 2012 2013 mix <- mmer(Yield~Env,              random= ~ vsr(atr(Year,c(\"2011\",\"2012\")),Name),             rcov=~ vsr(dsr(Year),units),             data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -45.5289   1:17:27      0           0 #>     2      -35.9052   1:17:27      0           0 #>     3      -33.3779   1:17:27      0           0 #>     4      -33.0963   1:17:27      0           0 #>     5      -33.0911   1:17:27      0           0 #>     6      -33.091   1:17:27      0           0  ## ============================ ## ## example to use usr() structure (UNSTRUCTURED) ## ============================ ## usr(DT$Year) #> $Z #>     2011 2012 2013 #> 1      0    0    1 #> 2      0    0    1 #> 3      0    0    1 #> 4      1    0    0 #> 5      0    0    1 #> 6      0    0    1 #> 7      0    1    0 #> 8      1    0    0 #> 9      0    1    0 #> 10     0    1    0 #> 11     0    1    0 #> 12     0    0    1 #> 13     0    0    1 #> 14     0    0    1 #> 15     0    0    1 #> 16     0    1    0 #> 17     0    0    1 #> 18     0    0    1 #> 19     0    0    1 #> 20     0    0    1 #> 21     0    1    0 #> 22     0    1    0 #> 23     0    0    1 #> 24     0    1    0 #> 25     0    0    1 #> 26     0    0    1 #> 27     0    0    1 #> 28     0    0    1 #> 29     0    1    0 #> 30     0    1    0 #> 31     0    1    0 #> 32     0    0    1 #> 33     0    0    1 #> 34     0    1    0 #> 35     0    1    0 #> 36     0    0    1 #> 37     0    0    1 #> 38     0    1    0 #> 39     0    1    0 #> 40     0    1    0 #> 41     0    0    1 #> 42     0    1    0 #> 43     0    1    0 #> 44     0    0    1 #> 45     0    1    0 #> 46     0    1    0 #> 47     0    0    1 #> 48     0    1    0 #> 49     0    1    0 #> 50     0    0    1 #> 51     0    1    0 #> 52     0    0    1 #> 53     1    0    0 #> 54     0    1    0 #> 55     0    0    1 #> 56     0    1    0 #> 57     0    1    0 #> 58     0    0    1 #> 59     0    0    1 #> 60     0    0    1 #> 61     0    1    0 #> 62     0    1    0 #> 63     0    1    0 #> 64     0    1    0 #> 65     0    0    1 #> 66     0    1    0 #> 67     0    0    1 #> 68     0    0    1 #> 69     0    1    0 #> 70     0    1    0 #> 71     0    1    0 #> 72     0    1    0 #> 73     0    1    0 #> 74     0    0    1 #> 75     0    1    0 #> 76     0    1    0 #> 77     1    0    0 #> 78     0    0    1 #> 79     0    0    1 #> 80     0    1    0 #> 81     0    0    1 #> 82     0    1    0 #> 83     0    1    0 #> 84     0    1    0 #> 85     0    1    0 #> 86     0    0    1 #> 87     0    1    0 #> 88     0    0    1 #> 89     0    1    0 #> 90     0    0    1 #> 91     0    1    0 #> 92     0    1    0 #> 93     0    1    0 #> 94     0    0    1 #> 95     0    1    0 #> 96     0    0    1 #> 97     0    0    1 #> 98     1    0    0 #> 99     0    1    0 #> 100    1    0    0 #> 101    0    1    0 #> 102    0    0    1 #> 103    0    0    1 #> 104    0    0    1 #> 105    0    0    1 #> 106    0    1    0 #> 107    0    0    1 #> 108    0    1    0 #> 109    0    1    0 #> 110    0    1    0 #> 111    0    0    1 #> 112    1    0    0 #> 113    0    1    0 #> 114    0    1    0 #> 115    0    1    0 #> 116    0    0    1 #> 117    0    1    0 #> 118    0    1    0 #> 119    1    0    0 #> 120    1    0    0 #> 121    0    0    1 #> 122    0    1    0 #> 123    1    0    0 #> 124    0    1    0 #> 125    0    1    0 #> 126    0    1    0 #> 127    0    1    0 #> 128    0    1    0 #> 129    0    0    1 #> 130    0    0    1 #> 131    0    1    0 #> 132    0    0    1 #> 133    1    0    0 #> 134    0    1    0 #> 135    0    1    0 #> 136    0    0    1 #> 137    0    0    1 #> 138    0    0    1 #> 139    0    1    0 #> 140    0    0    1 #> 141    0    0    1 #> 142    0    1    0 #> 143    0    0    1 #> 144    1    0    0 #> 145    1    0    0 #> 146    0    1    0 #> 147    1    0    0 #> 148    1    0    0 #> 149    1    0    0 #> 150    0    0    1 #> 151    0    0    1 #> 152    0    1    0 #> 153    1    0    0 #> 154    1    0    0 #> 155    0    1    0 #> 156    1    0    0 #> 157    0    0    1 #> 158    1    0    0 #> 159    1    0    0 #> 160    1    0    0 #> 161    1    0    0 #> 162    1    0    0 #> 163    1    0    0 #> 164    0    1    0 #> 165    1    0    0 #> 166    1    0    0 #> 167    1    0    0 #> 168    0    1    0 #> 169    1    0    0 #> 170    1    0    0 #> 171    1    0    0 #> 172    1    0    0 #> 173    1    0    0 #> 174    1    0    0 #> 175    1    0    0 #> 176    1    0    0 #> 177    1    0    0 #> 178    1    0    0 #> 179    1    0    0 #> 180    1    0    0 #> 181    0    0    1 #> 182    1    0    0 #> 183    1    0    0 #> 184    0    1    0 #> 185    1    0    0 #> attr(,\"assign\") #> [1] 1 1 1 #> attr(,\"contrasts\") #> attr(,\"contrasts\")$dummy #> [1] \"contr.treatment\" #>  #>  #> $thetaC #>      2011 2012 2013 #> 2011    1    2    2 #> 2012    2    1    2 #> 2013    2    2    1 #>  mix <- mmer(Yield~Env,              random= ~ vsr(usr(Year),Name),             rcov=~ vsr(dsr(Year),units),             data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -37.9059   1:17:28      0           0 #>     2      -17.9745   1:17:28      0           0 #>     3      -12.2427   1:17:28      0           0 #>     4      -11.5121   1:17:28      0           0 #>     5      -11.5001   1:17:28      0           0 #>     6      -11.4997   1:17:28      0           0  ## ============================ ## ## example to use csr() structure (CUSTOMIZED) ## ============================ ## unique(DT$Year) #> [1] 2013 2011 2012 #> Levels: 2011 2012 2013 mm <- matrix(1,3,3); mm[1,3] <- mm[3,1] <- 0;mm #don't estimate cov 2011-2013 #>      [,1] [,2] [,3] #> [1,]    1    1    0 #> [2,]    1    1    1 #> [3,]    0    1    1 mix <- mmer(Yield~Env,              random= ~ vsr(csr(Year,mm),Name),             rcov=~ vsr(dsr(Year),units),             data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -40.2254   1:17:28      0           0 #>     2      -22.056   1:17:28      0           0 #>     3      -15.6387   1:17:28      0           0 #>     4      -14.6846   1:17:28      0           0 #>     5      -14.6138   1:17:28      0           0 #>     6      -14.594   1:17:28      0           0 #>     7      -14.5877   1:17:29      1           0 #>     8      -14.5857   1:17:29      1           0 #>     9      -14.5851   1:17:29      1           0  ## ============================ ## ## example to use overlay() + vsr() structure ## ============================ ## data(\"DT_halfdiallel\") DT <- DT_halfdiallel head(DT) #>   rep geno male female     sugar #> 1   1   12    1      2 13.950509 #> 2   2   12    1      2  9.756918 #> 3   1   13    1      3 13.906355 #> 4   2   13    1      3  9.119455 #> 5   1   14    1      4  5.174483 #> 6   2   14    1      4  8.452221 DT$femalef <- as.factor(DT$female) DT$malef <- as.factor(DT$male) DT$genof <- as.factor(DT$geno) A <- diag(7); colnames(A) <- rownames(A) <- 1:7;A # if you want to provide a covariance matrix #>   1 2 3 4 5 6 7 #> 1 1 0 0 0 0 0 0 #> 2 0 1 0 0 0 0 0 #> 3 0 0 1 0 0 0 0 #> 4 0 0 0 1 0 0 0 #> 5 0 0 0 0 1 0 0 #> 6 0 0 0 0 0 1 0 #> 7 0 0 0 0 0 0 1 #### model using overlay modh <- mmer(sugar~1,               random=~vsr(overlay(femalef,malef,sparse=FALSE), Gu=A)                       + genof,               data=DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -10.425   1:17:29      0           0 #>     2      -6.487   1:17:29      0           0 #>     3      -5.732   1:17:29      0           0 #>     4      -5.67494   1:17:29      0           0 #>     5      -5.67441   1:17:29      0           0  ## ============================ ## ## example to use vsr() + dsr() + spl2D() structure ## ============================ ##             # ### mimic two fields # data(DT_cpdata) # DT <- DT_cpdata # GT <- GT_cpdata # MP <- MP_cpdata # aa <- DT; bb <- DT # aa$FIELD <- \"A\";bb$FIELD <- \"B\" # set.seed(1234) # aa$Yield <- aa$Yield + rnorm(length(aa$Yield),0,4) # DT2 <- rbind(aa,bb) # head(DT2) #  # mix <- mmer(Yield~1, #             random=~vsr(dsr(FIELD),id, Gu=A) +  #               vsr(dsr(FIELD),Rowf) + #               vsr(dsr(FIELD),Colf) + #                 vsr(dsr(FIELD),spl2D(Row,Col)), #             rcov=~vsr(dsr(FIELD),units), #             data=DT2)"},{"path":"https://github.com/covaruber/sommer/reference/wald.html","id":null,"dir":"Reference","previous_headings":"","what":"Wald Test for Model Coefficients — wald.test","title":"Wald Test for Model Coefficients — wald.test","text":"Computes Wald \\(\\chi^2\\) test 1 coefficients, given variance-covariance matrix.","code":""},{"path":"https://github.com/covaruber/sommer/reference/wald.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wald Test for Model Coefficients — wald.test","text":"","code":"wald.test(Sigma, b, Terms = NULL, L = NULL, H0 = NULL,               df = NULL, verbose = FALSE)   # S3 method for class 'wald.test' print(x, digits = 2, ...)"},{"path":"https://github.com/covaruber/sommer/reference/wald.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wald Test for Model Coefficients — wald.test","text":"Sigma var-cov matrix, usually extracted one fitting functions (e.g., lm, glm, ...). b vector coefficients var-cov matrix Sigma. coefficients usually extracted     one fitting functions available R (e.g., lm, glm,...). Terms optional integer vector specifying coefficients jointly tested, using Wald     \\(\\chi^2\\) \\(F\\) test. elements correspond columns rows var-cov     matrix given Sigma. Default NULL. L optional matrix conformable b, product b .e., L %*% b     gives linear combinations coefficients tested. Default NULL. H0 numeric vector giving null hypothesis test. must long Terms     must number columns L. Default 0 coefficients tested. df numeric vector giving degrees freedom used \\(F\\) test, .e. degrees freedom     residuals model b Sigma fitted. Default NULL,     \\(F\\) test. See section Details information. verbose logical scalar controlling amount output information. default FALSE, providing minimum output. x Object class “wald.test” digits Number decimal places displaying test results. Default 2. ... Additional arguments print.","code":""},{"path":"https://github.com/covaruber/sommer/reference/wald.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wald Test for Model Coefficients — wald.test","text":"key assumption coefficients asymptotically follow (multivariate) normal distribution mean =   model coefficients variance = var-cov matrix.   One (one) Terms L must given. L given, must number   columns length b, number rows number linear combinations coefficients.   df given, \\(\\chi^2\\) Wald statistic divided m = number   linear combinations coefficients tested (.e., length(Terms) nrow(L)). null   hypothesis H0, new statistic follows \\(F(m, df)\\) distribution.","code":""},{"path":"https://github.com/covaruber/sommer/reference/wald.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wald Test for Model Coefficients — wald.test","text":"object class wald.test, printed print.wald.test.","code":""},{"path":"https://github.com/covaruber/sommer/reference/wald.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Wald Test for Model Coefficients — wald.test","text":"Diggle, P.J., Liang, K.-Y., Zeger, S.L., 1994. Analysis longitudinal data. Oxford, Clarendon Press, 253 p.   Draper, N.R., Smith, H., 1998. Applied Regression Analysis. New York, John Wiley & Sons, Inc., 706 p.","code":""},{"path":"https://github.com/covaruber/sommer/reference/wald.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wald Test for Model Coefficients — wald.test","text":"","code":"data(DT_yatesoats) DT <- DT_yatesoats  m3 <- mmer(fixed=Y ~ V + N + V:N-1,            random = ~ B + B:MP,            rcov=~units,            data = DT) #> iteration    LogLik     wall    cpu(sec)   restrained #>     1      -4.46709   1:17:29      0           0 #>     2      -1.34644   1:17:29      0           0 #>     3      -0.788146   1:17:29      0           0 #>     4      -0.746308   1:17:29      0           0 #>     5      -0.745925   1:17:29      0           0  wald.test(b = m3$Beta$Estimate, Sigma = m3$VarBeta, Terms = 2) #> Wald test: #> ---------- #>  #> Chi-squared test: #> X2 = 90.6, df = 1, P(> X2) = 0.0  LL <- matrix(0,nrow=1, ncol=12) LL[1,2] <- 1 LL[1,3] <- -1 LL #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #> [1,]    0    1   -1    0    0    0    0    0    0     0     0     0  wald.test(b = m3$Beta$Estimate, Sigma = m3$VarBeta, L=LL) #> Wald test: #> ---------- #>  #> Chi-squared test: #> X2 = 2.4, df = 1, P(> X2) = 0.12"}]
